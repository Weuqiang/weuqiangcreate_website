
:::info

DOMDiffDOM

****`memorizedState`HookHookHook

:::
## useState

 

`count`****0`setCount`****`count`

``` jsx live
function Example(props) {
    let [count, setCount] = useState(0) // 0
    return (
        <div>
            <div>{ count }</div>
            <button onClick={() => setCount(count + 1)}>
              
            </button>
        </div>
    )
}
```

`setState`

``` js
setState(count => count + 1)
```

## useEffect



`useEffect`****


``` jsx live
function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

`useEffect``useEffect`

``` javascript
useEffect(() => {
    const timer = setTimeout(() => {
      // doSomething
    }, 1000);
    // 
    return () => {
        clearTimeout(timer)
    }
})
```

## useRef

`useRef``useState``useState``useRef`


``` jsx live
function App(props) {
    const [count, setCount] = useState(0)
    // highlight-next-line
    let ref = useRef(0) // ref: MutableRefObject<number>
    return (
      <>
        <div>ref: { ref.current }</div>
        <div>count: { count }</div>
        <button onClick={() => ref.current += 1}>ref.current+1</button>
        <button onClick={() => setCount(count => count + 1)}>count+1</button>
      </>
    )
}
```

`useRef``DOM`
``` tsx
function Test() {
    // highlight-next-line
    const ref = useRef<HTMLDivElement>(null!) // ref: RefObject<HTMLDivElement>
    
    return <div ref={ref} onClick={() => console.log(ref.current.innerText)}></div>
}
```
:::note
`useRef`
:::
``` ts 
interface MutableRefObject<T> {
    current: T;
}

interface RefObject<T> {
    readonly current: T | null;
}

``` 





## useMemo



``` js
const revertMsg = useMemo(() => msg.split('').reverse().join(''), [msg])
```



## useCallback



`props``props`****

``` jsx
function Father () {
    const [count, setCount] = useState(0)
    return (
    	<PureChildComponent onClick={() => { setCount(1) }}/>
    )
}
```

`useCallback`

``` jsx
function Father () {
    const [count, setCount] = useState(0)
    const cb = useCallback(() => {
       setCount(count => count + 1)
    }, [])
    return (
    	<PureChildComponent onClick={cb}/>
    )
}
```

`useMemo``useCallback`

``` jsx
function Father () {
    const [count, setCount] = useState(0)
    const cb = useMemo(() => {
       return () => setCount(count => count + 1)
    }, [])
    return (
    	<PureChildComponent onClick={cb}/>
    )
}
```
:::note
`useCallback(fn, deps)`  `useMemo(() => fn, deps)`
:::
## useContext
`useContext``<MyContext.Provider value={value}>``props`

:::caution
`useContext()``Provider``value`
:::
``` jsx 
const MyContext = createContext(null);

function App() {
  const [count, setCount] = useState(0);

  return (
    // countvalue`useContext`
    // highlight-start
    <MyContext.Provider value={{ 
        name: 'aka',
        age: 20
    }}>
    // highlight-end
      <button onClick={() => setCount(count => count + 1)}></button>
      <Child />
    </MyContext.Provider>
  );
}

const Child = memo(() => {
  useContext(MyContext);
  console.log('render'); 
  return <div>hello</div>;
});
```

:::info
[](https://github.com/facebook/react/issues/15156#issuecomment-474590693)[](https://blog.axlight.com/posts/4-options-to-prevent-extra-rerenders-with-react-context/)
:::

## useReducer

`useState`

``` jsx
function Todos() {
  const [todos, dispatch] = useReducer(todosReducer, []);

  function handleAddClick(text) {
    dispatch({ type: 'add', text });
  }

  // ...
}

function todosReducer(state, action) {
  switch (action.type) {
    case 'add':
      return [...state, {
        text: action.text,
        completed: false
      }];
    // ... other actions ...
    default:
      return state;
  }
}
```

`useReducer`

```js
function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    const nextState = reducer(state, action);
    setState(nextState);
  }

  return [state, dispatch];
}
```

## useImperativeHandle

:::note
`useImperativeHandle``forwordRef`
:::
``` js
// forwardRef + useImperativeHandle
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} />;
}
FancyInput = forwardRef(FancyInput);
```

## Hook
HookHook`use`

Hookeg: `useState``useEffect`Hook****


## Hook



### 1 
``` jsx live 
// 1
function Test1() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        setTimeout(() => {
            console.log(count)
        }, 3000)
    }, [])

    return (
        <div>
            <div>{count}</div>
            <button onClick={() => setCount(10)}></button>
        </div>
    )
}
```
`count`0`Fiber Node``memorizedState``10``count`10

`count`0

:::info 
``` jsx
useEffect(() => {
    const timer = setTimeout(() => {
        console.log(count)
    }, 3000)

    return () => clearTimeout(timer)
}, [count])
```
:::


### 2 
``` jsx live
// 2
function Test2() {
    const [count, setCount] = useState(0)
    const fn = useCallback(() => {
      alert(count)
    }, []) // 
    return (
        <div>
            <div>{count}</div>
            <button onClick={() => setCount(100)}></button>
            <button onClick={fn}></button> 
        </div>
    )
}
``` 

`count`0`useCallback``memorizedState``useCallback``fn``count`0

:::info 
``` jsx
const fn = useCallback(() => {
    console.log(count)
}, [count]) 
```
`memorizedState`
:::

`useCallback``props``count`

`useRef``count``ref.current``ref.current`

``` jsx live
function App() {
  const [count, setCount] = useState(0);
  const ref = useRef(count);
  ref.current = count;

  const fn = useCallback(() => {
    console.log(ref.current);
  }, [ref]); // ref

  return (
    <>
      {count}
      <button onClick={() => setCount(100)}></button>
      <button onClick={fn}></button>
    </>
  );
}
```



`ahooks``usePersistFn`

``` js
export type noop = (...args: any[]) => any;

function usePersistFn<T extends noop>(fn: T) {
  const ref = useRef<any>(() => {
    throw new Error('Cannot call function while rendering.');
  });

  ref.current = fn;

  const persistFn = useCallback(((...args) => ref.current(...args)) as T, [ref]);

  return persistFn;
}

// 
const [count, setCount] = useState(0);
const showCountPersistFn = usePersistFn(() => {
    alert(`Current count is ${count}`);
});
```

`ref``current``fn`





[React Hook](https://github.com/brickspert/blog/issues/26)

[React useEffect](https://zhuanlan.zhihu.com/p/84697185)


