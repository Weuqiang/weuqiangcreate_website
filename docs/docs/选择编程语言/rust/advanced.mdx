# 

## Unsafe Rust

Rust`unsafe`

### Unsafe

`unsafe`

1. ****
2. **unsafe**
3. ****
4. **unsafe trait**
5. **union**

### Raw Pointers



```rust
fn main() {
    let mut num = 5;

    // 
    let r1 = &num as *const i32;        // 
    let r2 = &mut num as *mut i32;      // 

    // unsafe
    unsafe {
        println!("r1: {}", *r1);
        println!("r2: {}", *r2);
    }
}
```

****
- 
- 
- 
- 

### Unsafe

```rust
unsafe fn dangerous() {
    println!("unsafe");
}

fn main() {
    unsafe {
        dangerous();
    }
}
```

### Unsafe

```rust
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    let (left, right) = split_at_mut(&mut v, 3);
    
    println!("left: {:?}", left);   // [1, 2, 3]
    println!("right: {:?}", right); // [4, 5, 6]
}
```

### extern

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Cabs(-3) = {}", abs(-3));
    }
}
```

### 

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

### Unsafe Trait

```rust
unsafe trait Foo {
    // 
}

unsafe impl Foo for i32 {
    // 
}
```

### Union

```rust
#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}

fn main() {
    let u = MyUnion { f1: 1 };
    
    unsafe {
        println!("u.f1: {}", u.f1);
        println!("u.f2: {}", u.f2);
    }
}
```

## Advanced Traits

### Associated Types

traittrait

```rust
pub trait Iterator {
    type Item;  // 

    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;  // 

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
```

** vs **

```rust
// 
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}

// 
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

### 

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    
    println!("{:?}", p1 + p2);  // Point { x: 4, y: 6 }
}
```

****

```rust
trait Add<Rhs=Self> {  // RhsSelf
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}

// 
struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

### Fully Qualified Syntax

trait

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("");
    }
}

impl Human {
    fn fly(&self) {
        println!("**");
    }
}

fn main() {
    let person = Human;
    
    person.fly();           // Humanfly
    Pilot::fly(&person);    // Pilotfly
    Wizard::fly(&person);   // Wizardfly
}
```

****

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
    // 
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

### Supertraits

traittrait

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {  // Display
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl OutlinePrint for Point {}

fn main() {
    let p = Point { x: 1, y: 3 };
    p.outline_print();
}
```

### Newtype

trait

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```

## Advanced Types

### Type Aliases

`type`

```rust
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!("x + y = {}", x + y);
```

****

```rust
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -> Thunk {
    // --snip--
    Box::new(|| ())
}
```

### Never!

`!`

```rust
fn bar() -> ! {
    panic!("");
}

fn main() {
    let guess: u32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,  // continue!
    };
}
```

### DST

Rust

```rust
// strDST
let s1: str = "Hello";  // 

// &str+
let s2: &str = "Hello";  // 
```

**Sized Trait**

```rust
// T: Sized
fn generic<T>(t: T) {
    // --snip--
}

// 
fn generic<T: Sized>(t: T) {
    // --snip--
}

// 
fn generic<T: ?Sized>(t: &T) {  // ?SizedDST
    // --snip--
}
```

## Advanced Functions

### 



```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer);  // 12
}
```

** vs **

```rust
// traitFnFnMutFnOnce
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

// 
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(|i| i.to_string())  // 
    .collect();

let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(ToString::to_string)  // 
    .collect();
```

### 

traittrait

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn main() {
    let f = returns_closure();
    println!("{}", f(5));  // 6
}
```

## Macro

Rust*****declarative macros***** *procedural macros*

- *Custom `#[derive]` macros*
- *Attribute-like macros*
- *Function-like macros*

Token

### 

#### 

``` rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

#### 

``` rust
let v: Vec<u32> = vec![1, 2, 3];
```



### 

#### 

Trait

#### 

``` rust
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

#### 

``` rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```





#### 



#### 

``` rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
}
```



#### 

``` rust
#[route(GET, "/")]
fn index() {
}
```





#### 



#### 

``` rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
}
```



#### 

``` rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```






