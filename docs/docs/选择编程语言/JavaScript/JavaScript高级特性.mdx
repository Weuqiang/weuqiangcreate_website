---
sidebar_position: 13
title: JavaScript高级特性深度解析
tags: [JavaScript, 高级特性, 闭包, 原型链, Event Loop]
---

# JavaScript高级特性深度解析

## 概述

深入理解JavaScript的核心机制，掌握高级特性，是成为JavaScript专家的必经之路。

## 闭包（Closure）

### 1. 闭包原理

闭包是指函数可以访问其外部作用域的变量，即使外部函数已经执行完毕。

```javascript
// 基础闭包
function createCounter() {
  let count = 0;
  
  return {
    increment() {
      return ++count;
    },
    decrement() {
      return --count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
// count 变量无法从外部直接访问

// 闭包陷阱
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出 5 5 5 5 5
  }, 100);
}

// 解决方案1：使用 let
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出 0 1 2 3 4
  }, 100);
}

// 解决方案2：使用闭包
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j); // 输出 0 1 2 3 4
    }, 100);
  })(i);
}
```

### 2. 闭包应用

```javascript
// 私有变量
function createPerson(name) {
  let _age = 0; // 私有变量
  
  return {
    getName() {
      return name;
    },
    getAge() {
      return _age;
    },
    setAge(age) {
      if (age >= 0 && age <= 150) {
        _age = age;
      }
    }
  };
}

const person = createPerson('John');
person.setAge(30);
console.log(person.getAge()); // 30
// console.log(person._age); // undefined

// 函数柯里化
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6

// 偏函数
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

function multiply(a, b, c) {
  return a * b * c;
}

const double = partial(multiply, 2);
console.log(double(3, 4)); // 24

// 记忆化（Memoization）
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('从缓存获取');
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);
console.log(memoizedFib(40)); // 计算
console.log(memoizedFib(40)); // 从缓存获取

// 防抖（Debounce）
function debounce(fn, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const handleSearch = debounce((query) => {
  console.log('搜索:', query);
}, 300);

// 节流（Throttle）
function throttle(fn, delay) {
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用
const handleScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 200);
```

## 原型与原型链

### 1. 原型机制

```javascript
// 构造函数和原型
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const person1 = new Person('Alice');
const person2 = new Person('Bob');

person1.sayHello(); // Hello, I'm Alice
person2.sayHello(); // Hello, I'm Bob

// 原型链
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true

// 检查原型
console.log(person1 instanceof Person); // true
console.log(Person.prototype.isPrototypeOf(person1)); // true
console.log(Object.getPrototypeOf(person1) === Person.prototype); // true

// 原型继承
function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}

// 继承原型
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.study = function() {
  console.log(`${this.name} is studying in grade ${this.grade}`);
};

const student = new Student('Charlie', 10);
student.sayHello(); // Hello, I'm Charlie
student.study();    // Charlie is studying in grade 10
```

### 2. 类与继承

```javascript
// ES6 类
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} makes a sound`);
  }
  
  // 静态方法
  static create(name) {
    return new Animal(name);
  }
  
  // Getter
  get displayName() {
    return this.name.toUpperCase();
  }
  
  // Setter
  set displayName(name) {
    this.name = name;
  }
}

// 继承
class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  
  speak() {
    console.log(`${this.name} barks`);
  }
  
  fetch() {
    console.log(`${this.name} fetches the ball`);
  }
}

const dog = new Dog('Max', 'Golden Retriever');
dog.speak(); // Max barks
dog.fetch(); // Max fetches the ball

// 私有字段（ES2022）
class BankAccount {
  #balance = 0; // 私有字段
  
  constructor(initialBalance) {
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      return amount;
    }
    return 0;
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
// console.log(account.#balance); // SyntaxError

// Mixin 模式
const canEat = {
  eat(food) {
    console.log(`${this.name} is eating ${food}`);
  }
};

const canWalk = {
  walk() {
    console.log(`${this.name} is walking`);
  }
};

const canSwim = {
  swim() {
    console.log(`${this.name} is swimming`);
  }
};

class Duck {
  constructor(name) {
    this.name = name;
  }
}

// 混入多个功能
Object.assign(Duck.prototype, canEat, canWalk, canSwim);

const duck = new Duck('Donald');
duck.eat('bread');
duck.walk();
duck.swim();
```

## this 绑定

### 1. this 的四种绑定规则

```javascript
// 1. 默认绑定
function foo() {
  console.log(this); // 严格模式: undefined, 非严格模式: window
}
foo();

// 2. 隐式绑定
const obj = {
  name: 'Object',
  sayName() {
    console.log(this.name);
  }
};
obj.sayName(); // Object

// 隐式绑定丢失
const sayName = obj.sayName;
sayName(); // undefined (严格模式)

// 3. 显式绑定
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: 'John' };
greet.call(person, 'Hello');    // Hello, John
greet.apply(person, ['Hi']);    // Hi, John

const boundGreet = greet.bind(person, 'Hey');
boundGreet(); // Hey, John

// 4. new 绑定
function Person(name) {
  this.name = name;
}

const p = new Person('Alice');
console.log(p.name); // Alice

// 箭头函数的 this
const obj2 = {
  name: 'Object2',
  regularFunc() {
    console.log(this.name); // Object2
  },
  arrowFunc: () => {
    console.log(this.name); // undefined (继承外层作用域)
  },
  nested() {
    const arrow = () => {
      console.log(this.name); // Object2 (继承 nested 的 this)
    };
    arrow();
  }
};

obj2.regularFunc();
obj2.arrowFunc();
obj2.nested();
```

### 2. 手写 call、apply、bind

```javascript
// 手写 call
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};

// 手写 apply
Function.prototype.myApply = function(context, args) {
  context = context || window;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};

// 手写 bind
Function.prototype.myBind = function(context, ...args) {
  const fn = this;
  return function(...newArgs) {
    return fn.apply(context, [...args, ...newArgs]);
  };
};

// 测试
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'John' };

greet.myCall(person, 'Hello', '!');
greet.myApply(person, ['Hi', '?']);
const boundGreet = greet.myBind(person, 'Hey');
boundGreet('!!!');
```

## Event Loop

### 1. 事件循环机制

```javascript
// 宏任务和微任务
console.log('1'); // 同步任务

setTimeout(() => {
  console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // 微任务
});

console.log('4'); // 同步任务

// 输出顺序: 1 4 3 2

// 复杂示例
console.log('start');

setTimeout(() => {
  console.log('setTimeout 1');
  Promise.resolve().then(() => {
    console.log('promise 1');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('promise 2');
  setTimeout(() => {
    console.log('setTimeout 2');
  }, 0);
});

console.log('end');

// 输出顺序:
// start
// end
// promise 2
// setTimeout 1
// promise 1
// setTimeout 2
```

### 2. 异步编程

```javascript
// Promise
function fetchData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url) {
        resolve({ data: 'success' });
      } else {
        reject(new Error('URL is required'));
      }
    }, 1000);
  });
}

fetchData('/api/users')
  .then(result => console.log(result))
  .catch(error => console.error(error));

// async/await
async function getData() {
  try {
    const result = await fetchData('/api/users');
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}

// 并行执行
async function fetchMultiple() {
  const [users, posts, comments] = await Promise.all([
    fetchData('/api/users'),
    fetchData('/api/posts'),
    fetchData('/api/comments')
  ]);
  
  return { users, posts, comments };
}

// 串行执行
async function fetchSequential() {
  const users = await fetchData('/api/users');
  const posts = await fetchData('/api/posts');
  const comments = await fetchData('/api/comments');
  
  return { users, posts, comments };
}

// Promise 工具函数
class PromiseUtils {
  // 延迟执行
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // 超时控制
  static timeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), ms)
      )
    ]);
  }
  
  // 重试
  static async retry(fn, maxRetries = 3, delay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === maxRetries - 1) throw error;
        await this.delay(delay * (i + 1));
      }
    }
  }
  
  // 限制并发
  static async limit(tasks, concurrency) {
    const results = [];
    const executing = [];
    
    for (const task of tasks) {
      const p = Promise.resolve().then(() => task());
      results.push(p);
      
      if (concurrency <= tasks.length) {
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e);
        
        if (executing.length >= concurrency) {
          await Promise.race(executing);
        }
      }
    }
    
    return Promise.all(results);
  }
}

// 使用
await PromiseUtils.delay(1000);

const result = await PromiseUtils.timeout(
  fetchData('/api/users'),
  5000
);

const data = await PromiseUtils.retry(
  () => fetchData('/api/users'),
  3,
  1000
);
```

## 模块化

### 1. ES6 模块

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const PI = 3.14159;

export default class Calculator {
  add(a, b) {
    return a + b;
  }
}

// main.js
import Calculator, { add, subtract, PI } from './math.js';
import * as math from './math.js';

console.log(add(1, 2));
console.log(math.PI);

const calc = new Calculator();
console.log(calc.add(3, 4));

// 动态导入
async function loadModule() {
  const module = await import('./math.js');
  console.log(module.add(5, 6));
}
```

### 2. CommonJS 模块

```javascript
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

module.exports = {
  add,
  subtract,
  PI: 3.14159
};

// main.js
const math = require('./math');
console.log(math.add(1, 2));
console.log(math.PI);
```

## 性能优化

### 1. 代码优化

```javascript
// 避免全局查找
function optimized() {
  const doc = document; // 缓存全局对象
  const element = doc.getElementById('myElement');
}

// 使用事件委托
document.getElementById('parent').addEventListener('click', (e) => {
  if (e.target.matches('.child')) {
    console.log('Child clicked');
  }
});

// 使用 DocumentFragment
function addMultipleElements(items) {
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  
  document.getElementById('list').appendChild(fragment);
}

// 使用 requestAnimationFrame
function animate() {
  // 动画逻辑
  requestAnimationFrame(animate);
}

// 使用 Web Workers
const worker = new Worker('worker.js');
worker.postMessage({ data: 'heavy computation' });
worker.onmessage = (e) => {
  console.log('Result:', e.data);
};
```

### 2. 内存优化

```javascript
// 避免内存泄漏
class Component {
  constructor() {
    this.listeners = [];
  }
  
  addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    this.listeners.push({ element, event, handler });
  }
  
  destroy() {
    // 清理事件监听器
    this.listeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this.listeners = [];
  }
}

// 使用 WeakMap 避免内存泄漏
const cache = new WeakMap();

function process(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  
  const result = heavyComputation(obj);
  cache.set(obj, result);
  return result;
}
```

## 总结

掌握JavaScript高级特性需要：

1. **深入理解核心机制**：闭包、原型链、this、Event Loop
2. **熟练运用异步编程**：Promise、async/await
3. **掌握模块化开发**：ES6 模块、CommonJS
4. **注重性能优化**：代码优化、内存管理

## 延伸阅读

- [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS)
- [JavaScript高级程序设计](https://www.ituring.com.cn/book/2472)
- [深入理解ES6](https://www.ituring.com.cn/book/1986)

