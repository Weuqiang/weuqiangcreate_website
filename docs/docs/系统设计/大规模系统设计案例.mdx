---
sidebar_position: 11
title: å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡æ¡ˆä¾‹
tags: [ç³»ç»Ÿè®¾è®¡, é«˜å¹¶å‘, åˆ†å¸ƒå¼ç³»ç»Ÿ, æ¶æ„è®¾è®¡]
---

# å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡æ¡ˆä¾‹

æœ¬æ–‡å°†é€šè¿‡å®é™…æ¡ˆä¾‹ï¼Œè¯¦ç»†è®²è§£å¦‚ä½•è®¾è®¡æ”¯æŒäº¿çº§ç”¨æˆ·çš„å¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿã€‚

## æ¡ˆä¾‹1ï¼šå¾®åšç³»ç»Ÿè®¾è®¡

### éœ€æ±‚åˆ†æ

```javascript
const requirements = {
  // åŠŸèƒ½éœ€æ±‚
  features: {
    post: 'å‘å¸ƒå¾®åš',
    timeline: 'æŸ¥çœ‹æ—¶é—´çº¿',
    follow: 'å…³æ³¨ç”¨æˆ·',
    like: 'ç‚¹èµè¯„è®º',
    search: 'æœç´¢å¾®åš'
  },
  
  // è§„æ¨¡ä¼°ç®—
  scale: {
    users: 500_000_000,        // 5äº¿ç”¨æˆ·
    dau: 100_000_000,          // 1äº¿DAU
    postsPerDay: 100_000_000,  // 1äº¿æ¡å¾®åš/å¤©
    avgFollowers: 200,         // å¹³å‡200å…³æ³¨
    readWriteRatio: 100        // è¯»å†™æ¯”100:1
  },
  
  // æ€§èƒ½è¦æ±‚
  performance: {
    timelineLatency: 200,      // æ—¶é—´çº¿200ms
    postLatency: 500,          // å‘å¸ƒ500ms
    availability: 99.99        // 4ä¸ª9å¯ç”¨æ€§
  }
};
```

### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CDNå±‚                       â”‚
â”‚  é™æ€èµ„æº â”‚ å›¾ç‰‡ â”‚ è§†é¢‘                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           è´Ÿè½½å‡è¡¡å±‚                     â”‚
â”‚  Nginx â”‚ LVS                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           åº”ç”¨æœåŠ¡å±‚                     â”‚
â”‚  å¾®åšæœåŠ¡ â”‚ ç”¨æˆ·æœåŠ¡ â”‚ å…³ç³»æœåŠ¡          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ç¼“å­˜å±‚                         â”‚
â”‚  Redis Cluster                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å­˜å‚¨å±‚                         â”‚
â”‚  MySQL â”‚ MongoDB â”‚ HBase                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒåŠŸèƒ½å®ç°

#### 1. å‘å¸ƒå¾®åš

```javascript
class PostService {
  async publishPost(userId, content, images) {
    // 1. ç”Ÿæˆå¾®åšID
    const postId = snowflake.generate();
    
    // 2. å­˜å‚¨å¾®åšå†…å®¹
    const post = {
      id: postId,
      userId,
      content,
      images,
      createdAt: Date.now()
    };
    
    await mongodb.posts.insertOne(post);
    
    // 3. æ¨é€åˆ°ç²‰ä¸æ—¶é—´çº¿ï¼ˆå¼‚æ­¥ï¼‰
    await this.fanoutToFollowers(userId, post);
    
    // 4. æ›´æ–°ç”¨æˆ·å¾®åšæ•°
    await redis.hincrby(`user:${userId}`, 'postCount', 1);
    
    return post;
  }
  
  async fanoutToFollowers(userId, post) {
    // è·å–ç²‰ä¸åˆ—è¡¨
    const followers = await this.getFollowers(userId);
    
    // åŒºåˆ†å¤§Vå’Œæ™®é€šç”¨æˆ·
    if (followers.length > 10000) {
      // å¤§Vï¼šæ‹‰æ¨¡å¼ï¼ˆä¸æ¨é€ï¼ŒæŸ¥è¯¢æ—¶å®æ—¶æ‹‰å–ï¼‰
      await redis.zadd(`bigv:posts:${userId}`, post.createdAt, post.id);
    } else {
      // æ™®é€šç”¨æˆ·ï¼šæ¨æ¨¡å¼ï¼ˆæ¨é€åˆ°ç²‰ä¸æ—¶é—´çº¿ï¼‰
      const pipeline = redis.pipeline();
      
      for (const followerId of followers) {
        pipeline.zadd(
          `timeline:${followerId}`,
          post.createdAt,
          JSON.stringify(post)
        );
        
        // ä¿ç•™æœ€è¿‘1000æ¡
        pipeline.zremrangebyrank(`timeline:${followerId}`, 0, -1001);
      }
      
      await pipeline.exec();
    }
  }
}
```

#### 2. æ—¶é—´çº¿æŸ¥è¯¢

```javascript
class TimelineService {
  async getTimeline(userId, page = 1, pageSize = 20) {
    // 1. ä»Redisè·å–æ—¶é—´çº¿
    const cacheKey = `timeline:${userId}`;
    const start = (page - 1) * pageSize;
    const end = start + pageSize - 1;
    
    let posts = await redis.zrevrange(cacheKey, start, end);
    
    if (posts.length === 0) {
      // 2. ç¼“å­˜æœªå‘½ä¸­ï¼Œé‡å»ºæ—¶é—´çº¿
      posts = await this.rebuildTimeline(userId);
    }
    
    // 3. æ··åˆå¤§Vå†…å®¹
    const bigVPosts = await this.getBigVPosts(userId);
    posts = this.mergePosts(posts, bigVPosts);
    
    // 4. è¡¥å……è¯¦ç»†ä¿¡æ¯
    return await this.enrichPosts(posts);
  }
  
  async rebuildTimeline(userId) {
    // è·å–å…³æ³¨åˆ—è¡¨
    const followings = await this.getFollowings(userId);
    
    const allPosts = [];
    
    for (const followingId of followings) {
      // è·å–æ¯ä¸ªå…³æ³¨ç”¨æˆ·çš„æœ€è¿‘å¾®åš
      const posts = await mongodb.posts
        .find({ userId: followingId })
        .sort({ createdAt: -1 })
        .limit(100)
        .toArray();
      
      allPosts.push(...posts);
    }
    
    // æŒ‰æ—¶é—´æ’åº
    allPosts.sort((a, b) => b.createdAt - a.createdAt);
    
    // å†™å…¥ç¼“å­˜
    const pipeline = redis.pipeline();
    for (const post of allPosts.slice(0, 1000)) {
      pipeline.zadd(
        `timeline:${userId}`,
        post.createdAt,
        JSON.stringify(post)
      );
    }
    await pipeline.exec();
    
    return allPosts.slice(0, 20);
  }
  
  async getBigVPosts(userId) {
    // è·å–å…³æ³¨çš„å¤§V
    const bigVs = await redis.smembers(`user:${userId}:bigv_followings`);
    
    const posts = [];
    
    for (const bigVId of bigVs) {
      // å®æ—¶æ‹‰å–å¤§Væœ€æ–°å¾®åš
      const bigVPosts = await redis.zrevrange(
        `bigv:posts:${bigVId}`,
        0,
        9
      );
      posts.push(...bigVPosts);
    }
    
    return posts;
  }
  
  mergePosts(normalPosts, bigVPosts) {
    // åˆå¹¶å¹¶æŒ‰æ—¶é—´æ’åº
    const all = [...normalPosts, ...bigVPosts];
    return all.sort((a, b) => b.createdAt - a.createdAt);
  }
}
```

#### 3. å…³æ³¨å…³ç³»

```javascript
class RelationService {
  async follow(followerId, followeeId) {
    // 1. æ£€æŸ¥æ˜¯å¦å·²å…³æ³¨
    const isFollowing = await redis.sismember(
      `user:${followerId}:followings`,
      followeeId
    );
    
    if (isFollowing) {
      return { success: false, message: 'Already following' };
    }
    
    // 2. æ›´æ–°å…³æ³¨å…³ç³»
    const pipeline = redis.pipeline();
    
    // å…³æ³¨åˆ—è¡¨
    pipeline.sadd(`user:${followerId}:followings`, followeeId);
    
    // ç²‰ä¸åˆ—è¡¨
    pipeline.sadd(`user:${followeeId}:followers`, followerId);
    
    // è®¡æ•°
    pipeline.hincrby(`user:${followerId}`, 'followingCount', 1);
    pipeline.hincrby(`user:${followeeId}`, 'followerCount', 1);
    
    await pipeline.exec();
    
    // 3. å¼‚æ­¥æ¨é€æœ€è¿‘å¾®åšåˆ°æ—¶é—´çº¿
    await this.pushRecentPosts(followerId, followeeId);
    
    return { success: true };
  }
  
  async unfollow(followerId, followeeId) {
    const pipeline = redis.pipeline();
    
    pipeline.srem(`user:${followerId}:followings`, followeeId);
    pipeline.srem(`user:${followeeId}:followers`, followerId);
    pipeline.hincrby(`user:${followerId}`, 'followingCount', -1);
    pipeline.hincrby(`user:${followeeId}`, 'followerCount', -1);
    
    await pipeline.exec();
    
    // ä»æ—¶é—´çº¿ç§»é™¤è¯¥ç”¨æˆ·çš„å¾®åš
    await this.removePostsFromTimeline(followerId, followeeId);
  }
}
```

## æ¡ˆä¾‹2ï¼šç”µå•†ç³»ç»Ÿè®¾è®¡

### æ¶æ„è®¾è®¡

```javascript
const ecommerceArchitecture = {
  // å‰ç«¯å±‚
  frontend: {
    web: 'React SPA',
    mobile: 'React Native',
    cdn: 'CloudFlare'
  },
  
  // ç½‘å…³å±‚
  gateway: {
    apiGateway: 'Kong',
    rateLimiting: true,
    authentication: 'JWT'
  },
  
  // å¾®æœåŠ¡å±‚
  services: {
    user: 'ç”¨æˆ·æœåŠ¡',
    product: 'å•†å“æœåŠ¡',
    order: 'è®¢å•æœåŠ¡',
    payment: 'æ”¯ä»˜æœåŠ¡',
    inventory: 'åº“å­˜æœåŠ¡',
    cart: 'è´­ç‰©è½¦æœåŠ¡',
    search: 'æœç´¢æœåŠ¡'
  },
  
  // æ•°æ®å±‚
  data: {
    mysql: 'è®¢å•ã€ç”¨æˆ·',
    mongodb: 'å•†å“ã€è¯„è®º',
    redis: 'ç¼“å­˜ã€ä¼šè¯',
    elasticsearch: 'å•†å“æœç´¢'
  }
};
```

### ç§’æ€ç³»ç»Ÿ

```javascript
class SeckillService {
  async initSeckill(productId, stock) {
    // 1. é¢„çƒ­åº“å­˜åˆ°Redis
    await redis.set(`seckill:${productId}:stock`, stock);
    
    // 2. åˆå§‹åŒ–ä»¤ç‰Œæ¡¶
    await redis.set(`seckill:${productId}:tokens`, stock * 2);
    
    // 3. é¢„çƒ­å•†å“ä¿¡æ¯
    const product = await this.getProduct(productId);
    await redis.setex(
      `seckill:${productId}:info`,
      3600,
      JSON.stringify(product)
    );
  }
  
  async seckill(userId, productId) {
    // 1. è·å–ä»¤ç‰Œï¼ˆé™æµï¼‰
    const hasToken = await this.acquireToken(productId);
    if (!hasToken) {
      return { success: false, message: 'è¯·æ±‚è¿‡äºé¢‘ç¹' };
    }
    
    // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²è´­ä¹°
    const hasBought = await redis.sismember(
      `seckill:${productId}:buyers`,
      userId
    );
    
    if (hasBought) {
      return { success: false, message: 'å·²ç»è´­ä¹°è¿‡äº†' };
    }
    
    // 3. æ‰£å‡åº“å­˜ï¼ˆLuaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
    const stockKey = `seckill:${productId}:stock`;
    const result = await redis.eval(`
      local stock = redis.call('get', KEYS[1])
      if tonumber(stock) > 0 then
        redis.call('decr', KEYS[1])
        return 1
      else
        return 0
      end
    `, 1, stockKey);
    
    if (result === 0) {
      return { success: false, message: 'åº“å­˜ä¸è¶³' };
    }
    
    // 4. åˆ›å»ºè®¢å•ï¼ˆå¼‚æ­¥ï¼‰
    await this.createOrderAsync(userId, productId);
    
    // 5. æ ‡è®°ç”¨æˆ·å·²è´­ä¹°
    await redis.sadd(`seckill:${productId}:buyers`, userId);
    
    return { success: true, message: 'æŠ¢è´­æˆåŠŸ' };
  }
  
  async acquireToken(productId) {
    const tokenKey = `seckill:${productId}:tokens`;
    const tokens = await redis.decr(tokenKey);
    
    if (tokens < 0) {
      await redis.incr(tokenKey);
      return false;
    }
    
    return true;
  }
  
  async createOrderAsync(userId, productId) {
    // å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    await kafka.send('seckill-orders', [{
      value: {
        userId,
        productId,
        timestamp: Date.now()
      }
    }]);
  }
}
```

### è®¢å•ç³»ç»Ÿ

```javascript
class OrderService {
  async createOrder(userId, items) {
    // 1. ç”Ÿæˆè®¢å•ID
    const orderId = snowflake.generate();
    
    // 2. å¼€å¯åˆ†å¸ƒå¼äº‹åŠ¡
    const transaction = await this.beginTransaction();
    
    try {
      // 3. é”å®šåº“å­˜
      for (const item of items) {
        const locked = await this.lockInventory(
          item.productId,
          item.quantity,
          transaction
        );
        
        if (!locked) {
          throw new Error(`åº“å­˜ä¸è¶³: ${item.productId}`);
        }
      }
      
      // 4. åˆ›å»ºè®¢å•
      const order = {
        id: orderId,
        userId,
        items,
        totalAmount: this.calculateTotal(items),
        status: 'pending',
        createdAt: Date.now()
      };
      
      await this.saveOrder(order, transaction);
      
      // 5. æäº¤äº‹åŠ¡
      await transaction.commit();
      
      // 6. å‘é€è®¢å•åˆ›å»ºäº‹ä»¶
      await this.publishOrderCreated(order);
      
      return order;
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
  
  async lockInventory(productId, quantity, transaction) {
    // ä½¿ç”¨SELECT FOR UPDATEé”å®šåº“å­˜
    const result = await transaction.query(`
      UPDATE inventory
      SET available = available - ?,
          locked = locked + ?
      WHERE product_id = ? AND available >= ?
    `, [quantity, quantity, productId, quantity]);
    
    return result.affectedRows > 0;
  }
  
  async payOrder(orderId, paymentInfo) {
    // 1. è°ƒç”¨æ”¯ä»˜æœåŠ¡
    const paymentResult = await paymentService.pay(paymentInfo);
    
    if (!paymentResult.success) {
      return { success: false, message: 'æ”¯ä»˜å¤±è´¥' };
    }
    
    // 2. æ›´æ–°è®¢å•çŠ¶æ€
    await this.updateOrderStatus(orderId, 'paid');
    
    // 3. æ‰£å‡åº“å­˜
    const order = await this.getOrder(orderId);
    for (const item of order.items) {
      await this.deductInventory(item.productId, item.quantity);
    }
    
    // 4. å‘é€è®¢å•æ”¯ä»˜æˆåŠŸäº‹ä»¶
    await this.publishOrderPaid(order);
    
    return { success: true };
  }
  
  async deductInventory(productId, quantity) {
    await db.query(`
      UPDATE inventory
      SET locked = locked - ?,
          sold = sold + ?
      WHERE product_id = ?
    `, [quantity, quantity, productId]);
  }
}
```

## æ¡ˆä¾‹3ï¼šè§†é¢‘ç½‘ç«™è®¾è®¡

### æ¶æ„è®¾è®¡

```javascript
const videoArchitecture = {
  // ä¸Šä¼ æµç¨‹
  upload: {
    client: 'åˆ†ç‰‡ä¸Šä¼ ',
    storage: 'OSSå¯¹è±¡å­˜å‚¨',
    transcode: 'è½¬ç æœåŠ¡',
    cdn: 'CDNåˆ†å‘'
  },
  
  // æ’­æ”¾æµç¨‹
  playback: {
    cdn: 'CDNåŠ é€Ÿ',
    adaptiveBitrate: 'è‡ªé€‚åº”ç ç‡',
    drm: 'DRMåŠ å¯†',
    analytics: 'æ’­æ”¾ç»Ÿè®¡'
  },
  
  // æ¨èç³»ç»Ÿ
  recommendation: {
    collaborative: 'ååŒè¿‡æ»¤',
    contentBased: 'åŸºäºå†…å®¹',
    trending: 'çƒ­é—¨æ¨è',
    personalized: 'ä¸ªæ€§åŒ–æ¨è'
  }
};
```

### è§†é¢‘ä¸Šä¼ 

```javascript
class VideoUploadService {
  async uploadVideo(file, metadata) {
    // 1. åˆ†ç‰‡ä¸Šä¼ 
    const chunks = this.splitFile(file, 5 * 1024 * 1024); // 5MB per chunk
    const uploadId = await this.initiateMultipartUpload(metadata);
    
    const uploadPromises = chunks.map((chunk, index) =>
      this.uploadChunk(uploadId, index, chunk)
    );
    
    const parts = await Promise.all(uploadPromises);
    
    // 2. å®Œæˆä¸Šä¼ 
    const videoUrl = await this.completeMultipartUpload(uploadId, parts);
    
    // 3. åˆ›å»ºè§†é¢‘è®°å½•
    const videoId = snowflake.generate();
    const video = {
      id: videoId,
      title: metadata.title,
      description: metadata.description,
      originalUrl: videoUrl,
      status: 'processing',
      createdAt: Date.now()
    };
    
    await mongodb.videos.insertOne(video);
    
    // 4. è§¦å‘è½¬ç ä»»åŠ¡
    await this.triggerTranscode(videoId, videoUrl);
    
    return video;
  }
  
  async triggerTranscode(videoId, videoUrl) {
    // å‘é€åˆ°è½¬ç é˜Ÿåˆ—
    await kafka.send('video-transcode', [{
      value: {
        videoId,
        videoUrl,
        formats: [
          { resolution: '1080p', bitrate: '5000k' },
          { resolution: '720p', bitrate: '2500k' },
          { resolution: '480p', bitrate: '1000k' },
          { resolution: '360p', bitrate: '500k' }
        ]
      }
    }]);
  }
}

// è½¬ç æœåŠ¡
class TranscodeService {
  async transcode(job) {
    const { videoId, videoUrl, formats } = job;
    
    const transcodePromises = formats.map(format =>
      this.transcodeFormat(videoUrl, format)
    );
    
    const results = await Promise.all(transcodePromises);
    
    // æ›´æ–°è§†é¢‘çŠ¶æ€
    await mongodb.videos.updateOne(
      { id: videoId },
      {
        $set: {
          status: 'ready',
          formats: results,
          updatedAt: Date.now()
        }
      }
    );
    
    // é¢„çƒ­CDN
    await this.warmupCDN(results);
  }
  
  async transcodeFormat(videoUrl, format) {
    // ä½¿ç”¨FFmpegè½¬ç 
    const outputUrl = await ffmpeg.transcode({
      input: videoUrl,
      output: `${videoUrl}_${format.resolution}`,
      videoCodec: 'h264',
      audioCodec: 'aac',
      resolution: format.resolution,
      bitrate: format.bitrate
    });
    
    return {
      resolution: format.resolution,
      url: outputUrl,
      size: await this.getFileSize(outputUrl)
    };
  }
}
```

### è§†é¢‘æ’­æ”¾

```javascript
class VideoPlaybackService {
  async getPlaybackInfo(videoId, userId) {
    // 1. è·å–è§†é¢‘ä¿¡æ¯
    const video = await this.getVideo(videoId);
    
    if (!video || video.status !== 'ready') {
      throw new Error('Video not available');
    }
    
    // 2. æ£€æŸ¥æƒé™
    const hasPermission = await this.checkPermission(userId, videoId);
    
    if (!hasPermission) {
      throw new Error('No permission');
    }
    
    // 3. é€‰æ‹©CDNèŠ‚ç‚¹
    const cdnNode = await this.selectCDNNode(userId);
    
    // 4. ç”Ÿæˆæ’­æ”¾URLï¼ˆå¸¦ç­¾åï¼‰
    const playbackUrls = video.formats.map(format => ({
      resolution: format.resolution,
      url: this.generateSignedUrl(format.url, cdnNode)
    }));
    
    // 5. è®°å½•æ’­æ”¾æ—¥å¿—
    await this.logPlayback(userId, videoId);
    
    return {
      videoId,
      title: video.title,
      duration: video.duration,
      playbackUrls
    };
  }
  
  generateSignedUrl(url, cdnNode) {
    const expireTime = Date.now() + 3600 * 1000; // 1å°æ—¶
    const signature = crypto
      .createHmac('sha256', process.env.CDN_SECRET)
      .update(`${url}${expireTime}`)
      .digest('hex');
    
    return `${cdnNode}${url}?expire=${expireTime}&sign=${signature}`;
  }
  
  async logPlayback(userId, videoId) {
    // å‘é€åˆ°Kafka
    await kafka.send('video-playback', [{
      value: {
        userId,
        videoId,
        timestamp: Date.now()
      }
    }]);
    
    // å¢åŠ æ’­æ”¾æ¬¡æ•°
    await redis.hincrby(`video:${videoId}`, 'playCount', 1);
  }
}
```

## æ€§èƒ½ä¼˜åŒ–æ€»ç»“

```javascript
const optimizationStrategies = {
  // ç¼“å­˜ç­–ç•¥
  caching: {
    cdn: 'CDNç¼“å­˜é™æ€èµ„æº',
    redis: 'Redisç¼“å­˜çƒ­ç‚¹æ•°æ®',
    localCache: 'æœ¬åœ°ç¼“å­˜å‡å°‘ç½‘ç»œå¼€é”€',
    cacheAside: 'Cache-Asideæ¨¡å¼',
    writeThrough: 'Write-Throughæ¨¡å¼'
  },
  
  // æ•°æ®åº“ä¼˜åŒ–
  database: {
    indexing: 'åˆç†å»ºç«‹ç´¢å¼•',
    sharding: 'åˆ†åº“åˆ†è¡¨',
    readWriteSplit: 'è¯»å†™åˆ†ç¦»',
    denormalization: 'é€‚åº¦åèŒƒå¼åŒ–',
    connectionPool: 'è¿æ¥æ± ç®¡ç†'
  },
  
  // å¼‚æ­¥å¤„ç†
  async: {
    messageQueue: 'æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦',
    asyncTask: 'å¼‚æ­¥ä»»åŠ¡å¤„ç†',
    eventDriven: 'äº‹ä»¶é©±åŠ¨æ¶æ„'
  },
  
  // é™æµé™çº§
  protection: {
    rateLimiting: 'é™æµä¿æŠ¤',
    circuitBreaker: 'ç†”æ–­é™çº§',
    bulkhead: 'èˆ±å£éš”ç¦»',
    timeout: 'è¶…æ—¶æ§åˆ¶'
  }
};
```

## æ€»ç»“

å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡çš„æ ¸å¿ƒï¼š
- ğŸ—ï¸ **æ¶æ„è®¾è®¡**ï¼šåˆ†å±‚æ¶æ„ + å¾®æœåŠ¡
- ğŸ“Š **æ•°æ®å­˜å‚¨**ï¼šåˆ†åº“åˆ†è¡¨ + è¯»å†™åˆ†ç¦»
- ğŸš€ **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ + å¼‚æ­¥å¤„ç†
- ğŸ›¡ï¸ **é«˜å¯ç”¨**ï¼šé™æµé™çº§ + å®¹ç¾å¤‡ä»½
- ğŸ“ˆ **å¯æ‰©å±•**ï¼šæ°´å¹³æ‰©å±• + å¼¹æ€§ä¼¸ç¼©
- ğŸ” **ç›‘æ§è¿ç»´**ï¼šå…¨é“¾è·¯ç›‘æ§ + å‘Šè­¦

è®°ä½ï¼š**å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡éœ€è¦åœ¨æ€§èƒ½ã€å¯ç”¨æ€§ã€ä¸€è‡´æ€§ä¹‹é—´åšæƒè¡¡ï¼**

