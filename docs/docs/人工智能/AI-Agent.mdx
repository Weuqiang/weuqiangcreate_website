---
sidebar_position: 12
title: AI Agent
---

# AI Agent

:::info 
AI AgentReActAutoGPTLangChain Agent
:::

## AI Agent

**AI Agent** AI

### Agent

**Autonomy**
- 
- 

**Reactivity**
- 
- 

**Proactivity**
- 
- 

**Social Ability**
- 
- Agent

### Agent vs AI

|  | AI | AI Agent |
|------|--------|----------|
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |

## Agent

### 1. 

```python
class Agent:
    """Agent"""
    
    def __init__(self, llm, tools, memory=None):
        self.llm = llm  # 
        self.tools = tools  # 
        self.memory = memory or []  # 
    
    def perceive(self, observation):
        """"""
        return observation
    
    def think(self, observation):
        """"""
        # prompt
        prompt = self._build_prompt(observation)
        
        # LLM
        response = self.llm.generate(prompt)
        
        return response
    
    def act(self, action):
        """"""
        # 
        tool_name, tool_input = self._parse_action(action)
        
        # 
        if tool_name in self.tools:
            result = self.tools[tool_name](tool_input)
        else:
            result = f"Tool {tool_name} not found"
        
        return result
    
    def run(self, task, max_iterations=10):
        """Agent"""
        observation = task
        
        for i in range(max_iterations):
            # 
            thought = self.think(observation)
            
            # 
            if self._is_finished(thought):
                return self._extract_answer(thought)
            
            # 
            action = self._extract_action(thought)
            observation = self.act(action)
            
            # 
            self.memory.append({
                'thought': thought,
                'action': action,
                'observation': observation
            })
        
        return "Max iterations reached"
```

### 2. ReAct

**ReAct = Reasoning + Acting**

```python
class ReActAgent:
    """ReAct Agent"""
    
    def __init__(self, llm, tools):
        self.llm = llm
        self.tools = tools
    
    def _build_react_prompt(self, task, history):
        """ReAct prompt"""
        prompt = f"""You are an AI assistant that can use tools to solve tasks.

Available tools:
{self._format_tools()}

Use the following format:

Thought: Think about what to do
Action: the action to take, should be one of [{', '.join(self.tools.keys())}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Task: {task}

{self._format_history(history)}
"""
        return prompt
    
    def _format_tools(self):
        """"""
        tool_desc = []
        for name, tool in self.tools.items():
            tool_desc.append(f"- {name}: {tool.description}")
        return '\n'.join(tool_desc)
    
    def _format_history(self, history):
        """"""
        formatted = []
        for step in history:
            formatted.append(f"Thought: {step['thought']}")
            formatted.append(f"Action: {step['action']}")
            formatted.append(f"Action Input: {step['action_input']}")
            formatted.append(f"Observation: {step['observation']}")
        return '\n'.join(formatted)
    
    def run(self, task, max_steps=10):
        """ReAct Agent"""
        history = []
        
        for step in range(max_steps):
            # 
            prompt = self._build_react_prompt(task, history)
            response = self.llm.generate(prompt)
            
            # 
            if "Final Answer:" in response:
                answer = response.split("Final Answer:")[-1].strip()
                return answer
            
            # 
            thought = self._extract_field(response, "Thought:")
            action = self._extract_field(response, "Action:")
            action_input = self._extract_field(response, "Action Input:")
            
            # 
            if action in self.tools:
                observation = self.tools[action].run(action_input)
            else:
                observation = f"Error: Tool '{action}' not found"
            
            # 
            history.append({
                'thought': thought,
                'action': action,
                'action_input': action_input,
                'observation': observation
            })
        
        return "Max steps reached without finding answer"
    
    def _extract_field(self, text, field_name):
        """"""
        if field_name not in text:
            return ""
        
        start = text.index(field_name) + len(field_name)
        end = text.find('\n', start)
        if end == -1:
            end = len(text)
        
        return text[start:end].strip()


# 
class SearchTool:
    name = "search"
    description = "Search the internet for information"
    
    def run(self, query):
        # API
        return f"Search results for: {query}"


class CalculatorTool:
    name = "calculator"
    description = "Perform mathematical calculations"
    
    def run(self, expression):
        try:
            result = eval(expression)
            return str(result)
        except Exception as e:
            return f"Error: {str(e)}"


# ReAct Agent
tools = {
    'search': SearchTool(),
    'calculator': CalculatorTool()
}

agent = ReActAgent(llm, tools)
answer = agent.run("What is the population of Tokyo multiplied by 2?")
print(answer)
```

### 3. Agent

```python
class PlanAndExecuteAgent:
    """-Agent"""
    
    def __init__(self, llm, tools):
        self.llm = llm
        self.tools = tools
    
    def plan(self, task):
        """"""
        prompt = f"""Break down the following task into a step-by-step plan:

Task: {task}

Plan:
1."""
        
        response = self.llm.generate(prompt)
        steps = self._parse_plan(response)
        return steps
    
    def execute_step(self, step, context):
        """"""
        prompt = f"""Execute the following step using available tools:

Step: {step}
Context: {context}

Available tools: {list(self.tools.keys())}

Action:"""
        
        response = self.llm.generate(prompt)
        action, action_input = self._parse_action(response)
        
        if action in self.tools:
            result = self.tools[action].run(action_input)
        else:
            result = f"Tool {action} not found"
        
        return result
    
    def run(self, task):
        """Agent"""
        # 
        plan = self.plan(task)
        print(f"Plan: {plan}")
        
        # 
        context = []
        for i, step in enumerate(plan):
            print(f"\nExecuting step {i+1}: {step}")
            result = self.execute_step(step, context)
            print(f"Result: {result}")
            context.append({
                'step': step,
                'result': result
            })
        
        # 
        return self._summarize(task, context)
    
    def _parse_plan(self, response):
        """"""
        lines = response.strip().split('\n')
        steps = []
        for line in lines:
            line = line.strip()
            if line and line[0].isdigit():
                step = line.split('.', 1)[1].strip()
                steps.append(step)
        return steps
    
    def _summarize(self, task, context):
        """"""
        prompt = f"""Summarize the results of the following task:

Task: {task}

Execution history:
{self._format_context(context)}

Final Answer:"""
        
        return self.llm.generate(prompt)
```

## Tool Use

### 1. Function Calling

```python
import json
from openai import OpenAI

class FunctionCallingAgent:
    """Agent"""
    
    def __init__(self):
        self.client = OpenAI()
        self.functions = self._define_functions()
        self.available_functions = self._register_functions()
    
    def _define_functions(self):
        """"""
        return [
            {
                "name": "get_weather",
                "description": "",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "city": {
                            "type": "string",
                            "description": ""
                        },
                        "unit": {
                            "type": "string",
                            "enum": ["celsius", "fahrenheit"],
                            "description": ""
                        }
                    },
                    "required": ["city"]
                }
            },
            {
                "name": "search_web",
                "description": "",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": ""
                        }
                    },
                    "required": ["query"]
                }
            }
        ]
    
    def _register_functions(self):
        """"""
        return {
            "get_weather": self.get_weather,
            "search_web": self.search_web
        }
    
    def get_weather(self, city, unit="celsius"):
        """"""
        # API
        return json.dumps({
            "city": city,
            "temperature": 22,
            "unit": unit,
            "condition": ""
        })
    
    def search_web(self, query):
        """"""
        # API
        return json.dumps({
            "query": query,
            "results": ["1", "2", "3"]
        })
    
    def run(self, user_message):
        """Agent"""
        messages = [{"role": "user", "content": user_message}]
        
        while True:
            # LLM
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=messages,
                functions=self.functions,
                function_call="auto"
            )
            
            message = response.choices[0].message
            
            # 
            if not message.function_call:
                return message.content
            
            # 
            function_name = message.function_call.name
            function_args = json.loads(message.function_call.arguments)
            
            print(f": {function_name}")
            print(f": {function_args}")
            
            function_response = self.available_functions[function_name](**function_args)
            
            # 
            messages.append({
                "role": "function",
                "name": function_name,
                "content": function_response
            })


# 
agent = FunctionCallingAgent()
result = agent.run("")
print(result)
```

### 2. LangChain

```python
from langchain.agents import Tool, AgentExecutor, create_react_agent
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
from langchain.tools import DuckDuckGoSearchRun
from langchain.utilities import WikipediaAPIWrapper

# 
search = DuckDuckGoSearchRun()
wikipedia = WikipediaAPIWrapper()

tools = [
    Tool(
        name="Search",
        func=search.run,
        description=""
    ),
    Tool(
        name="Wikipedia",
        func=wikipedia.run,
        description=""
    ),
    Tool(
        name="Calculator",
        func=lambda x: str(eval(x)),
        description=""
    )
]

# Agent
llm = OpenAI(temperature=0)

prompt = PromptTemplate.from_template("""
Answer the following questions as best you can. You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: {input}
Thought: {agent_scratchpad}
""")

agent = create_react_agent(llm, tools, prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 
result = agent_executor.invoke({
    "input": "What is the population of Tokyo? Calculate it multiplied by 2."
})
print(result)
```

## 

### 1. 

```python
class ShortTermMemory:
    """"""
    
    def __init__(self, max_length=10):
        self.messages = []
        self.max_length = max_length
    
    def add(self, role, content):
        """"""
        self.messages.append({
            "role": role,
            "content": content
        })
        
        # 
        if len(self.messages) > self.max_length:
            self.messages = self.messages[-self.max_length:]
    
    def get_messages(self):
        """"""
        return self.messages
    
    def clear(self):
        """"""
        self.messages = []
```

### 2. 

```python
from langchain.vectorstores import FAISS
from langchain.embeddings import OpenAIEmbeddings

class LongTermMemory:
    """"""
    
    def __init__(self):
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = None
        self.documents = []
    
    def add(self, text, metadata=None):
        """"""
        self.documents.append({
            "text": text,
            "metadata": metadata or {}
        })
        
        # 
        texts = [doc["text"] for doc in self.documents]
        metadatas = [doc["metadata"] for doc in self.documents]
        
        self.vectorstore = FAISS.from_texts(
            texts,
            self.embeddings,
            metadatas=metadatas
        )
    
    def search(self, query, k=5):
        """"""
        if not self.vectorstore:
            return []
        
        results = self.vectorstore.similarity_search(query, k=k)
        return [doc.page_content for doc in results]
    
    def save(self, path):
        """"""
        if self.vectorstore:
            self.vectorstore.save_local(path)
    
    def load(self, path):
        """"""
        self.vectorstore = FAISS.load_local(path, self.embeddings)


class MemoryAgent:
    """Agent"""
    
    def __init__(self, llm):
        self.llm = llm
        self.short_term = ShortTermMemory()
        self.long_term = LongTermMemory()
    
    def run(self, user_input):
        """Agent"""
        # 
        relevant_memories = self.long_term.search(user_input)
        
        # prompt
        prompt = self._build_prompt(user_input, relevant_memories)
        
        # 
        response = self.llm.generate(prompt)
        
        # 
        self.short_term.add("user", user_input)
        self.short_term.add("assistant", response)
        
        # 
        self.long_term.add(
            f"User: {user_input}\nAssistant: {response}",
            metadata={"timestamp": time.time()}
        )
        
        return response
    
    def _build_prompt(self, user_input, relevant_memories):
        """prompt"""
        prompt = "Relevant past conversations:\n"
        for memory in relevant_memories:
            prompt += f"- {memory}\n"
        
        prompt += "\nCurrent conversation:\n"
        for msg in self.short_term.get_messages():
            prompt += f"{msg['role']}: {msg['content']}\n"
        
        prompt += f"user: {user_input}\nassistant:"
        
        return prompt
```

## Agent

### 1. Agent

```python
class MultiAgentSystem:
    """Agent"""
    
    def __init__(self):
        self.agents = {}
    
    def register_agent(self, name, agent):
        """Agent"""
        self.agents[name] = agent
    
    def route_task(self, task):
        """Agent"""
        # LLMAgent
        prompt = f"""Given the following task, which agent should handle it?

Task: {task}

Available agents:
{self._format_agents()}

Agent:"""
        
        agent_name = self.llm.generate(prompt).strip()
        
        if agent_name in self.agents:
            return self.agents[agent_name]
        else:
            return self.agents[list(self.agents.keys())[0]]
    
    def run(self, task):
        """"""
        agent = self.route_task(task)
        return agent.run(task)


# Agent
class ResearchAgent:
    """Agent"""
    def run(self, task):
        # 
        pass


class CodingAgent:
    """Agent"""
    def run(self, task):
        # 
        pass


class WritingAgent:
    """Agent"""
    def run(self, task):
        # 
        pass


# 
system = MultiAgentSystem()
system.register_agent("research", ResearchAgent())
system.register_agent("coding", CodingAgent())
system.register_agent("writing", WritingAgent())

result = system.run("Write a Python script to analyze data")
```

### 2. Agent

```python
class DebateSystem:
    """Agent"""
    
    def __init__(self, agents, judge):
        self.agents = agents
        self.judge = judge
    
    def debate(self, topic, rounds=3):
        """"""
        history = []
        
        for round_num in range(rounds):
            print(f"\n=== Round {round_num + 1} ===")
            
            for agent_name, agent in self.agents.items():
                # prompt
                prompt = self._build_debate_prompt(
                    topic,
                    agent_name,
                    history
                )
                
                # 
                response = agent.generate(prompt)
                
                print(f"\n{agent_name}: {response}")
                
                history.append({
                    "agent": agent_name,
                    "response": response
                })
        
        # 
        summary = self.judge_debate(topic, history)
        return summary
    
    def judge_debate(self, topic, history):
        """"""
        prompt = f"""As a judge, summarize the debate on: {topic}

Debate history:
{self._format_history(history)}

Summary:"""
        
        return self.judge.generate(prompt)
```

## 

### 1. 

```python
class ResearchAssistant:
    """"""
    
    def __init__(self):
        self.llm = OpenAI()
        self.search_tool = DuckDuckGoSearchRun()
        self.memory = LongTermMemory()
    
    def research_topic(self, topic, depth=3):
        """"""
        results = {
            "topic": topic,
            "findings": [],
            "summary": ""
        }
        
        # 
        questions = self._generate_questions(topic, depth)
        
        # 
        for question in questions:
            print(f": {question}")
            
            # 
            search_results = self.search_tool.run(question)
            
            # 
            summary = self._summarize(question, search_results)
            
            results["findings"].append({
                "question": question,
                "summary": summary
            })
            
            # 
            self.memory.add(f"Q: {question}\nA: {summary}")
        
        # 
        results["summary"] = self._generate_final_summary(results["findings"])
        
        return results
    
    def _generate_questions(self, topic, depth):
        """"""
        prompt = f"""Generate {depth} research questions about: {topic}

Questions:
1."""
        
        response = self.llm.generate(prompt)
        questions = self._parse_questions(response)
        return questions
    
    def _summarize(self, question, search_results):
        """"""
        prompt = f"""Summarize the following search results for the question:

Question: {question}

Search results:
{search_results}

Summary:"""
        
        return self.llm.generate(prompt)
    
    def _generate_final_summary(self, findings):
        """"""
        prompt = "Synthesize the following research findings:\n\n"
        
        for i, finding in enumerate(findings):
            prompt += f"{i+1}. {finding['question']}\n"
            prompt += f"   {finding['summary']}\n\n"
        
        prompt += "Final Summary:"
        
        return self.llm.generate(prompt)


# 
assistant = ResearchAssistant()
results = assistant.research_topic("", depth=5)
print(results["summary"])
```

### 2. Agent

```python
class CodingAgent:
    """Agent"""
    
    def __init__(self):
        self.llm = OpenAI()
    
    def generate_code(self, requirement):
        """"""
        # 
        analysis = self._analyze_requirement(requirement)
        
        # 
        design = self._design_solution(analysis)
        
        # 
        code = self._write_code(design)
        
        # 
        test_results = self._test_code(code)
        
        # 
        if not test_results["passed"]:
            code = self._fix_code(code, test_results["errors"])
        
        return {
            "code": code,
            "design": design,
            "tests": test_results
        }
    
    def _analyze_requirement(self, requirement):
        """"""
        prompt = f"""Analyze the following coding requirement:

Requirement: {requirement}

Analysis (include: inputs, outputs, constraints, edge cases):"""
        
        return self.llm.generate(prompt)
    
    def _design_solution(self, analysis):
        """"""
        prompt = f"""Design a solution based on this analysis:

{analysis}

Design (include: algorithm, data structures, functions):"""
        
        return self.llm.generate(prompt)
    
    def _write_code(self, design):
        """"""
        prompt = f"""Write Python code based on this design:

{design}

Code:
```python"""
        
        response = self.llm.generate(prompt)
        code = response.split("```")[0]
        return code
    
    def _test_code(self, code):
        """"""
        try:
            # 
            exec(code)
            return {"passed": True, "errors": []}
        except Exception as e:
            return {"passed": False, "errors": [str(e)]}
    
    def _fix_code(self, code, error_list):
        """"""
        errors_str = '\n'.join(error_list)
        prompt = f"""Fix the following code errors:

Code:
{code}

Errors:
{errors_str}

Fixed code:"""
        
        response = self.llm.generate(prompt)
        return response


# 
agent = CodingAgent()
result = agent.generate_code("n")
print(result["code"])
```

## 

### 1. Prompt

```python
# Agent Prompt
AGENT_PROMPT = """You are a helpful AI assistant with access to tools.

Your goal: {goal}

Available tools:
{tools}

Guidelines:
1. Think step by step
2. Use tools when necessary
3. Verify your answers
4. Be concise and accurate

Current task: {task}

Let's begin:
"""
```

### 2. 

```python
class RobustAgent:
    """Agent"""
    
    def run(self, task, max_retries=3):
        """Agent with"""
        for attempt in range(max_retries):
            try:
                result = self._execute(task)
                return result
            except Exception as e:
                print(f"Attempt {attempt + 1} failed: {e}")
                if attempt == max_retries - 1:
                    return f"Failed after {max_retries} attempts: {e}"
                time.sleep(2 ** attempt)  # 
```

### 3. 

```python
class CostAwareAgent:
    """Agent"""
    
    def __init__(self, budget=10.0):
        self.budget = budget
        self.spent = 0.0
    
    def run(self, task):
        """Agent with"""
        estimated_cost = self._estimate_cost(task)
        
        if self.spent + estimated_cost > self.budget:
            return "Budget exceeded"
        
        result = self._execute(task)
        self.spent += estimated_cost
        
        return result
```

## 

****
- 
- 

**Agent**
- Agent
- Agent

**Agent**
- 
- 

**Agent**
- 
- 
- 

## 

****:
1. Agent =  +  + 
2. ReAct
3. Agent
4. 
5. Agent

****:
- Agent
- ReAct
- 
- Agent

<DocCardList />

