---
sidebar_position: 21
title: AI实战项目：NLP情感分析系统
tags: [AI, NLP, BERT, Transformer, 情感分析]
---

# AI实战项目：NLP情感分析系统

## 项目概述

构建一个基于BERT的情感分析系统，实现文本情感分类、情感强度预测等功能。

### 技术栈

- **深度学习**: PyTorch, Transformers
- **NLP工具**: NLTK, spaCy
- **数据处理**: Pandas, NumPy
- **API**: FastAPI
- **前端**: Vue 3

### 项目功能

- ✅ 文本情感分类（正面/负面/中性）
- ✅ 情感强度评分
- ✅ 关键词提取
- ✅ 批量文本分析
- ✅ 实时API服务

## 数据准备

### 1. 数据加载与预处理

```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import torch
from torch.utils.data import Dataset, DataLoader
from transformers import BertTokenizer

class SentimentDataset(Dataset):
    """情感分析数据集"""
    
    def __init__(self, texts, labels, tokenizer, max_length=128):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_length = max_length
    
    def __len__(self):
        return len(self.texts)
    
    def __getitem__(self, idx):
        text = str(self.texts[idx])
        label = self.labels[idx]
        
        # 分词和编码
        encoding = self.tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_length,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt'
        )
        
        return {
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
            'label': torch.tensor(label, dtype=torch.long)
        }

def load_data(file_path):
    """加载数据"""
    df = pd.read_csv(file_path)
    
    # 数据清洗
    df = df.dropna()
    df['text'] = df['text'].str.lower()
    df['text'] = df['text'].str.replace(r'http\S+', '', regex=True)
    df['text'] = df['text'].str.replace(r'@\w+', '', regex=True)
    df['text'] = df['text'].str.replace(r'#\w+', '', regex=True)
    
    # 标签映射
    label_map = {'negative': 0, 'neutral': 1, 'positive': 2}
    df['label'] = df['sentiment'].map(label_map)
    
    return df

def prepare_dataloaders(df, tokenizer, batch_size=32, test_size=0.2):
    """准备数据加载器"""
    
    # 划分训练集和测试集
    train_df, test_df = train_test_split(
        df, test_size=test_size, random_state=42, stratify=df['label']
    )
    
    # 创建数据集
    train_dataset = SentimentDataset(
        train_df['text'].values,
        train_df['label'].values,
        tokenizer
    )
    
    test_dataset = SentimentDataset(
        test_df['text'].values,
        test_df['label'].values,
        tokenizer
    )
    
    # 创建数据加载器
    train_loader = DataLoader(
        train_dataset,
        batch_size=batch_size,
        shuffle=True,
        num_workers=4
    )
    
    test_loader = DataLoader(
        test_dataset,
        batch_size=batch_size,
        shuffle=False,
        num_workers=4
    )
    
    return train_loader, test_loader

# 使用示例
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
df = load_data('sentiment_data.csv')
train_loader, test_loader = prepare_dataloaders(df, tokenizer)
```

### 2. 数据增强

```python
import nlpaug.augmenter.word as naw
import nlpaug.augmenter.sentence as nas

class TextAugmenter:
    """文本数据增强"""
    
    def __init__(self):
        # 同义词替换
        self.synonym_aug = naw.SynonymAug(aug_src='wordnet')
        
        # 回译增强
        self.back_translation_aug = naw.BackTranslationAug(
            from_model_name='facebook/wmt19-en-de',
            to_model_name='facebook/wmt19-de-en'
        )
        
        # 上下文词嵌入
        self.contextual_aug = naw.ContextualWordEmbsAug(
            model_path='bert-base-uncased',
            action="substitute"
        )
    
    def augment_synonym(self, text):
        """同义词替换"""
        return self.synonym_aug.augment(text)
    
    def augment_back_translation(self, text):
        """回译增强"""
        return self.back_translation_aug.augment(text)
    
    def augment_contextual(self, text):
        """上下文增强"""
        return self.contextual_aug.augment(text)
    
    def augment_all(self, texts, num_aug=2):
        """综合增强"""
        augmented_texts = []
        
        for text in texts:
            augmented_texts.append(text)  # 原始文本
            
            # 随机选择增强方法
            methods = [
                self.augment_synonym,
                self.augment_contextual
            ]
            
            for _ in range(num_aug):
                method = np.random.choice(methods)
                try:
                    aug_text = method(text)
                    augmented_texts.append(aug_text)
                except:
                    continue
        
        return augmented_texts
```

## 模型设计

### 1. BERT情感分类模型

```python
import torch.nn as nn
from transformers import BertModel, BertConfig

class BERTSentimentClassifier(nn.Module):
    """BERT情感分类器"""
    
    def __init__(self, num_classes=3, dropout=0.3):
        super(BERTSentimentClassifier, self).__init__()
        
        # BERT模型
        self.bert = BertModel.from_pretrained('bert-base-uncased')
        
        # 分类层
        self.dropout = nn.Dropout(dropout)
        self.classifier = nn.Linear(self.bert.config.hidden_size, num_classes)
    
    def forward(self, input_ids, attention_mask):
        # BERT编码
        outputs = self.bert(
            input_ids=input_ids,
            attention_mask=attention_mask
        )
        
        # 使用[CLS]标记的输出
        pooled_output = outputs.pooler_output
        
        # 分类
        output = self.dropout(pooled_output)
        logits = self.classifier(output)
        
        return logits

class BERTWithAttention(nn.Module):
    """带注意力机制的BERT模型"""
    
    def __init__(self, num_classes=3, dropout=0.3):
        super(BERTWithAttention, self).__init__()
        
        self.bert = BertModel.from_pretrained('bert-base-uncased')
        hidden_size = self.bert.config.hidden_size
        
        # 注意力层
        self.attention = nn.Sequential(
            nn.Linear(hidden_size, hidden_size),
            nn.Tanh(),
            nn.Linear(hidden_size, 1),
            nn.Softmax(dim=1)
        )
        
        # 分类层
        self.dropout = nn.Dropout(dropout)
        self.classifier = nn.Linear(hidden_size, num_classes)
    
    def forward(self, input_ids, attention_mask):
        # BERT编码
        outputs = self.bert(
            input_ids=input_ids,
            attention_mask=attention_mask
        )
        
        # 获取所有token的输出
        sequence_output = outputs.last_hidden_state
        
        # 计算注意力权重
        attention_weights = self.attention(sequence_output)
        
        # 加权求和
        weighted_output = torch.sum(attention_weights * sequence_output, dim=1)
        
        # 分类
        output = self.dropout(weighted_output)
        logits = self.classifier(output)
        
        return logits, attention_weights
```

### 2. 多任务学习模型

```python
class MultiTaskBERT(nn.Module):
    """多任务BERT模型（分类+回归）"""
    
    def __init__(self, num_classes=3, dropout=0.3):
        super(MultiTaskBERT, self).__init__()
        
        self.bert = BertModel.from_pretrained('bert-base-uncased')
        hidden_size = self.bert.config.hidden_size
        
        # 共享层
        self.shared = nn.Sequential(
            nn.Linear(hidden_size, hidden_size),
            nn.ReLU(),
            nn.Dropout(dropout)
        )
        
        # 分类任务
        self.classifier = nn.Linear(hidden_size, num_classes)
        
        # 回归任务（情感强度）
        self.regressor = nn.Linear(hidden_size, 1)
    
    def forward(self, input_ids, attention_mask):
        outputs = self.bert(
            input_ids=input_ids,
            attention_mask=attention_mask
        )
        
        pooled_output = outputs.pooler_output
        shared_output = self.shared(pooled_output)
        
        # 分类输出
        class_logits = self.classifier(shared_output)
        
        # 回归输出
        intensity = self.regressor(shared_output)
        
        return class_logits, intensity
```

## 模型训练

### 1. 训练器

```python
from transformers import AdamW, get_linear_schedule_with_warmup
from tqdm import tqdm

class SentimentTrainer:
    """情感分析训练器"""
    
    def __init__(self, model, train_loader, test_loader, device='cuda'):
        self.model = model.to(device)
        self.train_loader = train_loader
        self.test_loader = test_loader
        self.device = device
        
        # 优化器
        self.optimizer = AdamW(
            model.parameters(),
            lr=2e-5,
            eps=1e-8
        )
        
        # 学习率调度器
        total_steps = len(train_loader) * 10  # 10 epochs
        self.scheduler = get_linear_schedule_with_warmup(
            self.optimizer,
            num_warmup_steps=0,
            num_training_steps=total_steps
        )
        
        # 损失函数
        self.criterion = nn.CrossEntropyLoss()
        
        # 最佳准确率
        self.best_acc = 0
    
    def train_epoch(self, epoch):
        """训练一个epoch"""
        self.model.train()
        total_loss = 0
        correct = 0
        total = 0
        
        progress_bar = tqdm(self.train_loader, desc=f'Epoch {epoch}')
        
        for batch in progress_bar:
            input_ids = batch['input_ids'].to(self.device)
            attention_mask = batch['attention_mask'].to(self.device)
            labels = batch['label'].to(self.device)
            
            # 前向传播
            self.optimizer.zero_grad()
            logits = self.model(input_ids, attention_mask)
            loss = self.criterion(logits, labels)
            
            # 反向传播
            loss.backward()
            torch.nn.utils.clip_grad_norm_(self.model.parameters(), 1.0)
            self.optimizer.step()
            self.scheduler.step()
            
            # 统计
            total_loss += loss.item()
            _, predicted = torch.max(logits, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            
            # 更新进度条
            progress_bar.set_postfix({
                'loss': total_loss / (progress_bar.n + 1),
                'acc': 100. * correct / total
            })
        
        return total_loss / len(self.train_loader), 100. * correct / total
    
    def evaluate(self):
        """评估模型"""
        self.model.eval()
        total_loss = 0
        correct = 0
        total = 0
        
        all_preds = []
        all_labels = []
        
        with torch.no_grad():
            for batch in tqdm(self.test_loader, desc='Evaluating'):
                input_ids = batch['input_ids'].to(self.device)
                attention_mask = batch['attention_mask'].to(self.device)
                labels = batch['label'].to(self.device)
                
                logits = self.model(input_ids, attention_mask)
                loss = self.criterion(logits, labels)
                
                total_loss += loss.item()
                _, predicted = torch.max(logits, 1)
                total += labels.size(0)
                correct += (predicted == labels).sum().item()
                
                all_preds.extend(predicted.cpu().numpy())
                all_labels.extend(labels.cpu().numpy())
        
        acc = 100. * correct / total
        
        # 保存最佳模型
        if acc > self.best_acc:
            self.best_acc = acc
            torch.save({
                'model_state_dict': self.model.state_dict(),
                'optimizer_state_dict': self.optimizer.state_dict(),
                'acc': acc,
            }, 'best_sentiment_model.pth')
            print(f'Model saved! Acc: {acc:.2f}%')
        
        return total_loss / len(self.test_loader), acc, all_preds, all_labels
    
    def train(self, num_epochs=10):
        """完整训练流程"""
        for epoch in range(num_epochs):
            print(f'\nEpoch {epoch + 1}/{num_epochs}')
            train_loss, train_acc = self.train_epoch(epoch)
            test_loss, test_acc, preds, labels = self.evaluate()
            
            print(f'Train Loss: {train_loss:.4f} | Train Acc: {train_acc:.2f}%')
            print(f'Test Loss: {test_loss:.4f} | Test Acc: {test_acc:.2f}%')
        
        print(f'\nBest Test Acc: {self.best_acc:.2f}%')
```

### 2. 对抗训练

```python
class AdversarialTrainer(SentimentTrainer):
    """对抗训练器"""
    
    def __init__(self, model, train_loader, test_loader, device='cuda', epsilon=1e-3):
        super().__init__(model, train_loader, test_loader, device)
        self.epsilon = epsilon
    
    def train_epoch(self, epoch):
        """对抗训练"""
        self.model.train()
        total_loss = 0
        correct = 0
        total = 0
        
        for batch in tqdm(self.train_loader, desc=f'Epoch {epoch}'):
            input_ids = batch['input_ids'].to(self.device)
            attention_mask = batch['attention_mask'].to(self.device)
            labels = batch['label'].to(self.device)
            
            # 正常训练
            self.optimizer.zero_grad()
            logits = self.model(input_ids, attention_mask)
            loss = self.criterion(logits, labels)
            loss.backward()
            
            # 对抗扰动
            embeddings = self.model.bert.embeddings.word_embeddings
            embedding_gradients = embeddings.weight.grad
            
            if embedding_gradients is not None:
                # 计算扰动
                delta = self.epsilon * embedding_gradients / (
                    torch.norm(embedding_gradients) + 1e-8
                )
                
                # 添加扰动
                embeddings.weight.data += delta
                
                # 对抗样本前向传播
                adv_logits = self.model(input_ids, attention_mask)
                adv_loss = self.criterion(adv_logits, labels)
                adv_loss.backward()
                
                # 移除扰动
                embeddings.weight.data -= delta
            
            # 更新参数
            torch.nn.utils.clip_grad_norm_(self.model.parameters(), 1.0)
            self.optimizer.step()
            self.scheduler.step()
            
            # 统计
            total_loss += loss.item()
            _, predicted = torch.max(logits, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
        
        return total_loss / len(self.train_loader), 100. * correct / total
```

## 模型部署

### 1. FastAPI服务

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List
import torch

app = FastAPI(title="情感分析API")

# 加载模型
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BERTSentimentClassifier(num_classes=3)
checkpoint = torch.load('best_sentiment_model.pth')
model.load_state_dict(checkpoint['model_state_dict'])
model.to(device)
model.eval()

# 标签映射
label_map = {0: 'negative', 1: 'neutral', 2: 'positive'}

class TextInput(BaseModel):
    text: str

class BatchTextInput(BaseModel):
    texts: List[str]

class SentimentOutput(BaseModel):
    text: str
    sentiment: str
    confidence: float
    probabilities: dict

@app.post("/predict", response_model=SentimentOutput)
async def predict_sentiment(input_data: TextInput):
    """单文本情感预测"""
    try:
        # 预处理
        encoding = tokenizer.encode_plus(
            input_data.text,
            add_special_tokens=True,
            max_length=128,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt'
        )
        
        input_ids = encoding['input_ids'].to(device)
        attention_mask = encoding['attention_mask'].to(device)
        
        # 预测
        with torch.no_grad():
            logits = model(input_ids, attention_mask)
            probabilities = torch.softmax(logits, dim=1)
            confidence, predicted = torch.max(probabilities, 1)
        
        # 返回结果
        return SentimentOutput(
            text=input_data.text,
            sentiment=label_map[predicted.item()],
            confidence=confidence.item(),
            probabilities={
                label_map[i]: prob.item()
                for i, prob in enumerate(probabilities[0])
            }
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/predict_batch", response_model=List[SentimentOutput])
async def predict_batch(input_data: BatchTextInput):
    """批量文本情感预测"""
    results = []
    
    for text in input_data.texts:
        result = await predict_sentiment(TextInput(text=text))
        results.append(result)
    
    return results

@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 2. 前端界面（Vue 3）

```vue
<template>
  <div class="sentiment-analyzer">
    <h1>情感分析系统</h1>
    
    <div class="input-section">
      <textarea
        v-model="text"
        placeholder="输入要分析的文本..."
        rows="5"
      ></textarea>
      
      <button @click="analyze" :disabled="!text || loading">
        {{ loading ? '分析中...' : '开始分析' }}
      </button>
    </div>
    
    <div v-if="result" class="result-section">
      <h2>分析结果</h2>
      
      <div class="sentiment-badge" :class="result.sentiment">
        {{ sentimentLabel[result.sentiment] }}
      </div>
      
      <div class="confidence">
        置信度: {{ (result.confidence * 100).toFixed(2) }}%
      </div>
      
      <div class="probabilities">
        <h3>各类别概率:</h3>
        <div
          v-for="(prob, label) in result.probabilities"
          :key="label"
          class="prob-bar"
        >
          <span class="label">{{ sentimentLabel[label] }}</span>
          <div class="bar">
            <div
              class="fill"
              :style="{ width: (prob * 100) + '%' }"
              :class="label"
            ></div>
          </div>
          <span class="value">{{ (prob * 100).toFixed(2) }}%</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import axios from 'axios';

const text = ref('');
const result = ref(null);
const loading = ref(false);

const sentimentLabel = {
  positive: '正面',
  neutral: '中性',
  negative: '负面'
};

const analyze = async () => {
  loading.value = true;
  
  try {
    const response = await axios.post('http://localhost:8000/predict', {
      text: text.value
    });
    result.value = response.data;
  } catch (error) {
    console.error('Error:', error);
    alert('分析失败，请重试');
  } finally {
    loading.value = false;
  }
};
</script>

<style scoped>
.sentiment-analyzer {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

button {
  margin-top: 10px;
  padding: 10px 20px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.sentiment-badge {
  display: inline-block;
  padding: 10px 20px;
  border-radius: 20px;
  font-weight: bold;
  margin: 10px 0;
}

.sentiment-badge.positive {
  background: #4CAF50;
  color: white;
}

.sentiment-badge.neutral {
  background: #FFC107;
  color: white;
}

.sentiment-badge.negative {
  background: #F44336;
  color: white;
}

.prob-bar {
  display: flex;
  align-items: center;
  margin: 10px 0;
}

.bar {
  flex: 1;
  height: 20px;
  background: #eee;
  border-radius: 10px;
  margin: 0 10px;
  overflow: hidden;
}

.fill {
  height: 100%;
  transition: width 0.3s;
}

.fill.positive {
  background: #4CAF50;
}

.fill.neutral {
  background: #FFC107;
}

.fill.negative {
  background: #F44336;
}
</style>
```

## 总结

通过这个项目，我们学习了：

1. **NLP基础**: 文本预处理、分词、编码
2. **BERT模型**: 预训练模型使用、微调
3. **高级技术**: 注意力机制、多任务学习、对抗训练
4. **模型部署**: FastAPI服务、前端集成
5. **实战技巧**: 数据增强、模型优化

## 延伸阅读

- [Transformers文档](https://huggingface.co/docs/transformers/)
- [BERT论文](https://arxiv.org/abs/1810.04805)
- [FastAPI文档](https://fastapi.tiangolo.com/)

