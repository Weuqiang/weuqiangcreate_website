# 设置参数

```python
import numpy as np
import pandas as pd
g_2d_head = ["MES", "CE"]
g_2d_index = ["sigmod", "tanh","softmax","ReLU"]
g_2d = pd.DataFrame(index=g_2d_index, columns=g_2d_head)
```

# MES损失函数对不同激活函数的梯度

```python
g_2d.at["sigmod","MES"] = lambda w, loss:2 * loss * w *(1-w)
g_2d.at["tanh","MES"] = lambda w, loss:2 * loss * (1-w**2)
g_2d.at["softmax","MES"] = lambda w, loss:2 * loss * (w *(1-w))
g_2d.at["ReLU","MES"] = lambda w, loss:2 * loss * (1 if w> 0 else 0)
```

# CE损失函数对不同激活函数的梯度

```
g_2d.at["sigmod","CE"] = lambda w, loss:loss * w *(1-w)
g_2d.at["tanh","CE"] = lambda w, loss:loss * (1-w**2)
g_2d.at["softmax","CE"] = lambda w, loss:loss * (w - 1)
g_2d.at["ReLU","CE"] = lambda w, loss:loss * (1 if w> 0 else 0)
```

# 构建神经网络伪代码

```python
import numpy as np
import pandas as pd
g_2d_head = ["MES", "CE"]
g_2d_index = ["sigmod", "tanh","softmax","ReLU"]
g_2d = pd.DataFrame(index=g_2d_index, columns=g_2d_head)

g_2d.at["sigmod","MES"] = lambda w, loss:2 * loss * w *(1-w)
g_2d.at["tanh","MES"] = lambda w, loss:2 * loss * (1-w**2)
g_2d.at["softmax","MES"] = lambda w, loss:2 * loss * (w *(1-w))
g_2d.at["ReLU","MES"] = lambda w, loss:2 * loss * (1 if w> 0 else 0)

# 输入的数据：图片、数据（列表、数组、张量）
# 数据转化 

# 归一化：0-1
# 标准化： -1 1

# -1000，1000
# 0- 255/255
# 0 - 1

class Ne:

    # 不填就不能运行的参数
    def __init__(self,input, output, w=None, b=None, loss=None, activation=None):

        pass

    # 数据【可以后天喂给模型】
    def ffn(self):pass

    def get_loss(self):pass

    def get_back(self):self.w = 0

    # 循环计算
    def fit(self,):
        # 运算公式（前向传播）线性 + 激活函数
        self.ffn()
        # 评估损失 ： CE 、 MES
        self.get_loss()
        
        # 反向传播 -> 求导 (
        # 初始w 不要 0、1、-1、根号2、
        self.get_back()


for type in [( _,__)for _ in['MES','CE']for __ in ["sigmod", "tenh","softmax","ReLU"] ]:

    model = Ne(*type)


```

