---
sidebar_position: 4
title: 
tags: [, , , ]
---

# 



## 

### CAP

```javascript
// CAP(Consistency)(Availability)(Partition tolerance)
// 

// CPZookeeperHBase
class CPSystem {
  async write(key, value) {
    // 
    await this.master.write(key, value);
    
    // 
    await Promise.all(
      this.slaves.map(slave => slave.write(key, value))
    );
    
    // 
    return { success: true };
  }
}

// APCassandraDynamoDB
class APSystem {
  async write(key, value) {
    // 
    const availableNode = this.getAvailableNode();
    await availableNode.write(key, value);
    
    // 
    this.asyncSync(key, value);
    
    // 
    return { success: true };
  }
}

// CA
// 
```

### BASE

```javascript
// BASE(Basically Available)(Soft state)(Eventually consistent)

class EventualConsistency {
  async transferMoney(fromAccount, toAccount, amount) {
    // 1. 
    try {
      // 
      await this.debit(fromAccount, amount);
      
      // 
      await this.createEvent({
        type: 'TRANSFER',
        from: fromAccount,
        to: toAccount,
        amount: amount,
        status: 'PENDING'
      });
      
      return { success: true, message: '' };
    } catch (err) {
      return { success: false, message: '' };
    }
  }
  
  // 2. 
  async processEvents() {
    const events = await this.getPendingEvents();
    
    for (const event of events) {
      try {
        // 
        await this.credit(event.to, event.amount);
        
        // 
        await this.updateEventStatus(event.id, 'COMPLETED');
      } catch (err) {
        // 
        await this.retryLater(event);
      }
    }
  }
  
  // 3. 
  async reconcile() {
    setInterval(async () => {
      await this.processEvents();
    }, 5000);
  }
}
```

## 

### Redis

```javascript
const Redis = require('ioredis');

class RedisLock {
  constructor() {
    this.redis = new Redis();
  }
  
  // 
  async acquire(key, ttl = 10000) {
    const lockKey = `lock:${key}`;
    const lockValue = `${Date.now()}-${Math.random()}`;
    
    // SET key value NX PX ttl
    const result = await this.redis.set(
      lockKey,
      lockValue,
      'PX',
      ttl,
      'NX'
    );
    
    if (result === 'OK') {
      return lockValue;
    }
    
    return null;
  }
  
  // Lua
  async release(key, lockValue) {
    const lockKey = `lock:${key}`;
    
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await this.redis.eval(script, 1, lockKey, lockValue);
  }
  
  // 
  async withLock(key, fn, ttl = 10000) {
    const lockValue = await this.acquire(key, ttl);
    
    if (!lockValue) {
      throw new Error('Failed to acquire lock');
    }
    
    try {
      return await fn();
    } finally {
      await this.release(key, lockValue);
    }
  }
}

// 
const lock = new RedisLock();

async function updateInventory(productId, quantity) {
  await lock.withLock(`product:${productId}`, async () => {
    const product = await Product.findById(productId);
    product.inventory -= quantity;
    await product.save();
  });
}
```

### Redlock

```javascript
// Redis
class Redlock {
  constructor(redisClients) {
    this.clients = redisClients;
    this.quorum = Math.floor(redisClients.length / 2) + 1;
  }
  
  async acquire(key, ttl = 10000) {
    const lockValue = `${Date.now()}-${Math.random()}`;
    const startTime = Date.now();
    
    let successCount = 0;
    
    // 
    const results = await Promise.all(
      this.clients.map(async (client) => {
        try {
          const result = await client.set(
            `lock:${key}`,
            lockValue,
            'PX',
            ttl,
            'NX'
          );
          return result === 'OK';
        } catch (err) {
          return false;
        }
      })
    );
    
    successCount = results.filter(r => r).length;
    
    const elapsedTime = Date.now() - startTime;
    const validityTime = ttl - elapsedTime;
    
    // 
    if (successCount >= this.quorum && validityTime > 0) {
      return { lockValue, validityTime };
    }
    
    // 
    await this.release(key, lockValue);
    return null;
  }
  
  async release(key, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    await Promise.all(
      this.clients.map(client =>
        client.eval(script, 1, `lock:${key}`, lockValue)
      )
    );
  }
}
```

## 

### (2PC)

```javascript
class TwoPhaseCommit {
  constructor() {
    this.participants = [];
  }
  
  async execute(transaction) {
    // 1
    const prepareResults = await this.prepare(transaction);
    
    // 
    const allPrepared = prepareResults.every(r => r.prepared);
    
    if (allPrepared) {
      // 2
      await this.commit(transaction);
      return { success: true };
    } else {
      // 
      await this.rollback(transaction);
      return { success: false };
    }
  }
  
  async prepare(transaction) {
    return await Promise.all(
      this.participants.map(async (participant) => {
        try {
          await participant.prepare(transaction);
          return { prepared: true };
        } catch (err) {
          return { prepared: false, error: err };
        }
      })
    );
  }
  
  async commit(transaction) {
    await Promise.all(
      this.participants.map(participant =>
        participant.commit(transaction)
      )
    );
  }
  
  async rollback(transaction) {
    await Promise.all(
      this.participants.map(participant =>
        participant.rollback(transaction)
      )
    );
  }
}
```

### TCC

```javascript
// Try-Confirm-Cancel
class TCCTransaction {
  async transfer(fromAccount, toAccount, amount) {
    const transactionId = generateId();
    
    try {
      // Try
      await this.tryDebit(fromAccount, amount, transactionId);
      await this.tryCredit(toAccount, amount, transactionId);
      
      // Confirm
      await this.confirmDebit(fromAccount, transactionId);
      await this.confirmCredit(toAccount, transactionId);
      
      return { success: true };
    } catch (err) {
      // Cancel
      await this.cancelDebit(fromAccount, transactionId);
      await this.cancelCredit(toAccount, transactionId);
      
      return { success: false, error: err };
    }
  }
  
  async tryDebit(account, amount, transactionId) {
    // 
    await Account.update(
      { id: account },
      {
        $inc: { balance: -amount, frozen: amount }
      }
    );
    
    // 
    await Transaction.create({
      id: transactionId,
      account: account,
      amount: amount,
      type: 'DEBIT',
      status: 'TRY'
    });
  }
  
  async confirmDebit(account, transactionId) {
    // 
    await Account.update(
      { id: account },
      { $inc: { frozen: -amount } }
    );
    
    // 
    await Transaction.update(
      { id: transactionId },
      { status: 'CONFIRMED' }
    );
  }
  
  async cancelDebit(account, transactionId) {
    // 
    const tx = await Transaction.findById(transactionId);
    await Account.update(
      { id: account },
      {
        $inc: { balance: tx.amount, frozen: -tx.amount }
      }
    );
    
    // 
    await Transaction.update(
      { id: transactionId },
      { status: 'CANCELLED' }
    );
  }
}
```

### Saga

```javascript
// 
class SagaOrchestrator {
  async executeOrder(orderData) {
    const saga = new Saga();
    
    try {
      // 1
      const order = await saga.execute(
        () => this.createOrder(orderData),
        (order) => this.cancelOrder(order.id)
      );
      
      // 2
      await saga.execute(
        () => this.reduceInventory(order.productId, order.quantity),
        () => this.restoreInventory(order.productId, order.quantity)
      );
      
      // 3
      await saga.execute(
        () => this.debitAccount(order.userId, order.amount),
        () => this.creditAccount(order.userId, order.amount)
      );
      
      // 4
      await saga.execute(
        () => this.sendNotification(order.userId, order.id),
        () => {} // 
      );
      
      return { success: true, order };
    } catch (err) {
      // 
      await saga.compensate();
      return { success: false, error: err };
    }
  }
}

class Saga {
  constructor() {
    this.steps = [];
  }
  
  async execute(action, compensation) {
    const result = await action();
    this.steps.push({ result, compensation });
    return result;
  }
  
  async compensate() {
    // 
    for (let i = this.steps.length - 1; i >= 0; i--) {
      const { result, compensation } = this.steps[i];
      await compensation(result);
    }
  }
}
```

## 

```javascript
// 
class LoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
  }
  
  // 
  roundRobin() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }
  
  // 
  random() {
    const index = Math.floor(Math.random() * this.servers.length);
    return this.servers[index];
  }
  
  // 
  weightedRoundRobin() {
    let totalWeight = 0;
    let maxWeight = 0;
    let selectedServer = null;
    
    for (const server of this.servers) {
      server.currentWeight += server.weight;
      totalWeight += server.weight;
      
      if (server.currentWeight > maxWeight) {
        maxWeight = server.currentWeight;
        selectedServer = server;
      }
    }
    
    selectedServer.currentWeight -= totalWeight;
    return selectedServer;
  }
  
  // 
  leastConnections() {
    return this.servers.reduce((min, server) =>
      server.connections < min.connections ? server : min
    );
  }
  
  // 
  consistentHash(key) {
    const hash = this.hash(key);
    
    // hash
    for (const server of this.servers) {
      if (server.hash >= hash) {
        return server;
      }
    }
    
    // 
    return this.servers[0];
  }
  
  hash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash) + key.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

## 

```javascript
// 
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.resetTimeout = options.resetTimeout || 30000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      
      // 
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await Promise.race([
        fn(),
        this.timeoutPromise()
      ]);
      
      this.onSuccess();
      return result;
    } catch (err) {
      this.onFailure();
      throw err;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
    }
  }
  
  timeoutPromise() {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Timeout')), this.timeout);
    });
  }
}

// 
const breaker = new CircuitBreaker({
  failureThreshold: 5,
  timeout: 3000,
  resetTimeout: 30000
});

async function callExternalService() {
  try {
    return await breaker.execute(async () => {
      const response = await axios.get('https://api.example.com/data');
      return response.data;
    });
  } catch (err) {
    // 
    return getDefaultData();
  }
}
```

## 


-  ****CAPBASE
-  ****RedisRedlock
-  ****2PCTCCSaga
-  ****
-  ****

****

