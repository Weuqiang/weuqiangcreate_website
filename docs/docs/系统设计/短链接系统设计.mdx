---
sidebar_position: 4
title: çŸ­é“¾æ¥ç³»ç»Ÿè®¾è®¡
tags: [ç³»ç»Ÿè®¾è®¡, çŸ­é“¾æ¥, URLç¼©çŸ­]
---

# çŸ­é“¾æ¥ç³»ç»Ÿè®¾è®¡

çŸ­é“¾æ¥ç³»ç»Ÿæ˜¯ç»å…¸çš„ç³»ç»Ÿè®¾è®¡é¢è¯•é¢˜ï¼Œæœ¬æ–‡å°†è¯¦ç»†è®²è§£å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„çŸ­é“¾æ¥æœåŠ¡ã€‚

## éœ€æ±‚åˆ†æ

### åŠŸèƒ½éœ€æ±‚

```javascript
const functionalRequirements = {
  // æ ¸å¿ƒåŠŸèƒ½
  core: {
    createShortURL: true,      // ç”ŸæˆçŸ­é“¾æ¥
    redirect: true,            // é‡å®šå‘åˆ°åŸå§‹URL
    customAlias: true,         // è‡ªå®šä¹‰çŸ­é“¾æ¥
    expiration: true           // è®¾ç½®è¿‡æœŸæ—¶é—´
  },
  
  // æ‰©å±•åŠŸèƒ½
  extended: {
    analytics: true,           // è®¿é—®ç»Ÿè®¡
    qrCode: true,             // ç”ŸæˆäºŒç»´ç 
    bulkCreate: true,         // æ‰¹é‡ç”Ÿæˆ
    apiAccess: true           // APIè®¿é—®
  }
};
```

### éåŠŸèƒ½éœ€æ±‚

```python
# å®¹é‡ä¼°ç®—
æ¯æ—¥æ–°å¢çŸ­é“¾æ¥ = 100_000_000      # 1äº¿
æ¯æ—¥é‡å®šå‘è¯·æ±‚ = 10_000_000_000   # 100äº¿
è¯»å†™æ¯” = 100                      # è¯»å†™æ¯”100:1

# QPSè®¡ç®—
å†™QPS = æ¯æ—¥æ–°å¢çŸ­é“¾æ¥ / 86400
è¯»QPS = æ¯æ—¥é‡å®šå‘è¯·æ±‚ / 86400

print(f"å†™QPS: {å†™QPS:,.0f}")      # 1,157 QPS
print(f"è¯»QPS: {è¯»QPS:,.0f}")      # 115,740 QPS

# å­˜å‚¨ä¼°ç®—
æ¯æ¡è®°å½•å¤§å° = 500                # 500å­—èŠ‚
ä¿å­˜å¹´é™ = 5
æ€»è®°å½•æ•° = æ¯æ—¥æ–°å¢çŸ­é“¾æ¥ * 365 * ä¿å­˜å¹´é™
æ€»å­˜å‚¨_TB = (æ€»è®°å½•æ•° * æ¯æ¡è®°å½•å¤§å°) / (1024 ** 4)

print(f"æ€»å­˜å‚¨: {æ€»å­˜å‚¨_TB:.2f} TB")  # 8.53 TB

# å¸¦å®½ä¼°ç®—
æ¯æ¬¡é‡å®šå‘å“åº” = 200              # 200å­—èŠ‚
å³°å€¼QPS = è¯»QPS * 2               # å³°å€¼æ˜¯å¹³å‡çš„2å€
å¸¦å®½_Gbps = (å³°å€¼QPS * æ¯æ¬¡é‡å®šå‘å“åº” * 8) / (1024 ** 3)

print(f"å¸¦å®½éœ€æ±‚: {å¸¦å®½_Gbps:.2f} Gbps")  # 0.04 Gbps
```

## æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å®¢æˆ·ç«¯     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚     CDN     â”‚  â† ç¼“å­˜çƒ­ç‚¹çŸ­é“¾æ¥
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  è´Ÿè½½å‡è¡¡å™¨  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â–¼       â–¼
â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
â”‚ API â”‚ â”‚ API â”‚
â”‚æœåŠ¡å™¨â”‚ â”‚æœåŠ¡å™¨â”‚
â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
   â”‚       â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”
   â–¼        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚Redis â”‚ â”‚MySQL â”‚
â”‚ ç¼“å­˜  â”‚ â”‚æ•°æ®åº“ â”‚
â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜
```

### APIè®¾è®¡

```typescript
// 1. åˆ›å»ºçŸ­é“¾æ¥
interface CreateShortURLRequest {
  longURL: string;
  customAlias?: string;
  expireAt?: Date;
  userId?: string;
}

interface CreateShortURLResponse {
  shortURL: string;
  shortCode: string;
  longURL: string;
  createdAt: Date;
  expireAt?: Date;
}

// POST /api/v1/urls
async function createShortURL(req: CreateShortURLRequest): Promise<CreateShortURLResponse> {
  // å®ç°é€»è¾‘
}

// 2. é‡å®šå‘
// GET /:shortCode
async function redirect(shortCode: string): Promise<void> {
  const longURL = await getLongURL(shortCode);
  if (!longURL) {
    throw new Error('URL not found');
  }
  // 302é‡å®šå‘
  response.redirect(302, longURL);
}

// 3. è·å–ç»Ÿè®¡ä¿¡æ¯
interface AnalyticsResponse {
  shortCode: string;
  totalClicks: number;
  uniqueClicks: number;
  clicksByDate: Record<string, number>;
  clicksByCountry: Record<string, number>;
  clicksByDevice: Record<string, number>;
}

// GET /api/v1/urls/:shortCode/analytics
async function getAnalytics(shortCode: string): Promise<AnalyticsResponse> {
  // å®ç°é€»è¾‘
}

// 4. åˆ é™¤çŸ­é“¾æ¥
// DELETE /api/v1/urls/:shortCode
async function deleteShortURL(shortCode: string): Promise<void> {
  // å®ç°é€»è¾‘
}
```

## çŸ­ç ç”Ÿæˆç®—æ³•

### æ–¹æ¡ˆå¯¹æ¯”

```javascript
// æ–¹æ¡ˆ1ï¼šè‡ªå¢ID + Base62ç¼–ç 
class AutoIncrementGenerator {
  constructor() {
    this.chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  }
  
  encode(id) {
    if (id === 0) return this.chars[0];
    
    let result = '';
    while (id > 0) {
      result = this.chars[id % 62] + result;
      id = Math.floor(id / 62);
    }
    return result;
  }
  
  decode(shortCode) {
    let id = 0;
    for (let i = 0; i < shortCode.length; i++) {
      id = id * 62 + this.chars.indexOf(shortCode[i]);
    }
    return id;
  }
  
  async generate() {
    // ä»æ•°æ®åº“è·å–è‡ªå¢ID
    const id = await db.getNextID();
    return this.encode(id);
  }
}

// ä¼˜ç‚¹ï¼šç®€å•ã€å”¯ä¸€ã€å¯é¢„æµ‹é•¿åº¦
// ç¼ºç‚¹ï¼šå¯è¢«éå†ã€æš´éœ²ä¸šåŠ¡é‡

// æ–¹æ¡ˆ2ï¼šå“ˆå¸Œ + å†²çªæ£€æµ‹
class HashGenerator {
  async generate(longURL) {
    // MD5å“ˆå¸Œå–å‰7ä½
    let shortCode = md5(longURL).substring(0, 7);
    let attempts = 0;
    
    // æ£€æµ‹å†²çª
    while (await this.exists(shortCode) && attempts < 10) {
      shortCode = md5(longURL + attempts).substring(0, 7);
      attempts++;
    }
    
    if (attempts >= 10) {
      throw new Error('Failed to generate unique short code');
    }
    
    return shortCode;
  }
  
  async exists(shortCode) {
    return await redis.exists(`url:${shortCode}`);
  }
}

// ä¼˜ç‚¹ï¼šç›¸åŒURLç”Ÿæˆç›¸åŒçŸ­ç ã€ä¸å¯é¢„æµ‹
// ç¼ºç‚¹ï¼šå¯èƒ½å†²çªã€éœ€è¦æ£€æµ‹

// æ–¹æ¡ˆ3ï¼šSnowflakeåˆ†å¸ƒå¼ID
class SnowflakeGenerator {
  constructor(workerId, datacenterId) {
    this.workerId = workerId;
    this.datacenterId = datacenterId;
    this.sequence = 0;
    this.lastTimestamp = -1;
    this.epoch = 1609459200000; // 2021-01-01
  }
  
  generate() {
    let timestamp = Date.now();
    
    if (timestamp < this.lastTimestamp) {
      throw new Error('Clock moved backwards');
    }
    
    if (timestamp === this.lastTimestamp) {
      this.sequence = (this.sequence + 1) & 0xFFF;
      if (this.sequence === 0) {
        timestamp = this.waitNextMillis(this.lastTimestamp);
      }
    } else {
      this.sequence = 0;
    }
    
    this.lastTimestamp = timestamp;
    
    // 41ä½æ—¶é—´æˆ³ + 5ä½æ•°æ®ä¸­å¿ƒ + 5ä½æœºå™¨ + 12ä½åºåˆ—å·
    const id = ((timestamp - this.epoch) << 22) |
                (this.datacenterId << 17) |
                (this.workerId << 12) |
                this.sequence;
    
    return this.base62Encode(id);
  }
  
  waitNextMillis(lastTimestamp) {
    let timestamp = Date.now();
    while (timestamp <= lastTimestamp) {
      timestamp = Date.now();
    }
    return timestamp;
  }
  
  base62Encode(num) {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    while (num > 0) {
      result = chars[num % 62] + result;
      num = Math.floor(num / 62);
    }
    return result || '0';
  }
}

// ä¼˜ç‚¹ï¼šåˆ†å¸ƒå¼ã€é«˜æ€§èƒ½ã€å”¯ä¸€
// ç¼ºç‚¹ï¼šä¾èµ–æ—¶é’Ÿã€å®ç°å¤æ‚

// æ¨èæ–¹æ¡ˆï¼šSnowflake + Base62
const generator = new SnowflakeGenerator(1, 1);
```

## æ•°æ®åº“è®¾è®¡

### Schemaè®¾è®¡

```sql
-- URLæ˜ å°„è¡¨
CREATE TABLE url_mappings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    long_url TEXT NOT NULL,
    user_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_at TIMESTAMP NULL,
    is_active BOOLEAN DEFAULT TRUE,
    
    INDEX idx_short_code (short_code),
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at),
    INDEX idx_expire_at (expire_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- è®¿é—®ç»Ÿè®¡è¡¨ï¼ˆæ—¶åºæ•°æ®ï¼‰
CREATE TABLE url_clicks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) NOT NULL,
    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),
    user_agent TEXT,
    referer TEXT,
    country VARCHAR(2),
    device_type VARCHAR(20),
    
    INDEX idx_short_code_time (short_code, clicked_at),
    INDEX idx_clicked_at (clicked_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
PARTITION BY RANGE (UNIX_TIMESTAMP(clicked_at)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    -- æŒ‰æœˆåˆ†åŒº
);

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    api_key VARCHAR(64) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    quota_limit INT DEFAULT 1000,
    quota_used INT DEFAULT 0,
    
    INDEX idx_api_key (api_key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### åˆ†åº“åˆ†è¡¨ç­–ç•¥

```javascript
class ShardingStrategy {
  constructor(shardCount = 16) {
    this.shardCount = shardCount;
  }
  
  // æ ¹æ®çŸ­ç åˆ†ç‰‡
  getShardByShortCode(shortCode) {
    // ä½¿ç”¨çŸ­ç çš„å“ˆå¸Œå€¼åˆ†ç‰‡
    const hash = this.hashCode(shortCode);
    return hash % this.shardCount;
  }
  
  // æ ¹æ®ç”¨æˆ·IDåˆ†ç‰‡
  getShardByUserID(userID) {
    return userID % this.shardCount;
  }
  
  hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }
  
  // è·å–æ•°æ®åº“è¿æ¥
  getConnection(shortCode) {
    const shard = this.getShardByShortCode(shortCode);
    return this.connections[shard];
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const sharding = new ShardingStrategy(16);
const db = sharding.getConnection('abc123');
```

## ç¼“å­˜ç­–ç•¥

### å¤šçº§ç¼“å­˜

```javascript
class CacheManager {
  constructor() {
    // L1: æœ¬åœ°ç¼“å­˜ï¼ˆLRUï¼‰
    this.localCache = new LRUCache({
      max: 10000,
      ttl: 60 * 1000 // 1åˆ†é’Ÿ
    });
    
    // L2: Redisç¼“å­˜
    this.redis = new Redis({
      host: 'localhost',
      port: 6379
    });
  }
  
  async get(shortCode) {
    // 1. æŸ¥æœ¬åœ°ç¼“å­˜
    let longURL = this.localCache.get(shortCode);
    if (longURL) {
      return longURL;
    }
    
    // 2. æŸ¥Redis
    longURL = await this.redis.get(`url:${shortCode}`);
    if (longURL) {
      this.localCache.set(shortCode, longURL);
      return longURL;
    }
    
    // 3. æŸ¥æ•°æ®åº“
    const record = await db.query(
      'SELECT long_url, expire_at FROM url_mappings WHERE short_code = ?',
      [shortCode]
    );
    
    if (!record) {
      // ç¼“å­˜ç©ºå€¼ï¼Œé˜²æ­¢ç¼“å­˜ç©¿é€
      await this.redis.setex(`url:${shortCode}`, 60, 'NULL');
      return null;
    }
    
    // æ£€æŸ¥è¿‡æœŸ
    if (record.expire_at && new Date() > record.expire_at) {
      return null;
    }
    
    longURL = record.long_url;
    
    // å†™å…¥ç¼“å­˜
    this.localCache.set(shortCode, longURL);
    await this.redis.setex(`url:${shortCode}`, 3600, longURL);
    
    return longURL;
  }
  
  async set(shortCode, longURL, ttl = 3600) {
    this.localCache.set(shortCode, longURL);
    await this.redis.setex(`url:${shortCode}`, ttl, longURL);
  }
  
  async delete(shortCode) {
    this.localCache.delete(shortCode);
    await this.redis.del(`url:${shortCode}`);
  }
}
```

### ç¼“å­˜é¢„çƒ­

```javascript
class CacheWarmer {
  async warmup() {
    // é¢„çƒ­çƒ­é—¨çŸ­é“¾æ¥
    const hotURLs = await db.query(`
      SELECT short_code, long_url 
      FROM url_mappings 
      WHERE created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)
      ORDER BY (
        SELECT COUNT(*) 
        FROM url_clicks 
        WHERE url_clicks.short_code = url_mappings.short_code
      ) DESC
      LIMIT 10000
    `);
    
    // æ‰¹é‡å†™å…¥Redis
    const pipeline = redis.pipeline();
    for (const url of hotURLs) {
      pipeline.setex(`url:${url.short_code}`, 3600, url.long_url);
    }
    await pipeline.exec();
    
    console.log(`Warmed up ${hotURLs.length} URLs`);
  }
}
```

## æ ¸å¿ƒåŠŸèƒ½å®ç°

### åˆ›å»ºçŸ­é“¾æ¥

```javascript
class URLShortener {
  async createShortURL(longURL, options = {}) {
    const { customAlias, expireAt, userId } = options;
    
    // 1. éªŒè¯URL
    if (!this.isValidURL(longURL)) {
      throw new Error('Invalid URL');
    }
    
    // 2. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if (!customAlias) {
      const existing = await this.findByLongURL(longURL, userId);
      if (existing && !existing.expire_at) {
        return existing;
      }
    }
    
    // 3. ç”ŸæˆçŸ­ç 
    let shortCode;
    if (customAlias) {
      // è‡ªå®šä¹‰çŸ­ç 
      if (await this.exists(customAlias)) {
        throw new Error('Custom alias already exists');
      }
      shortCode = customAlias;
    } else {
      // è‡ªåŠ¨ç”Ÿæˆ
      shortCode = await this.generateShortCode();
    }
    
    // 4. å­˜å‚¨åˆ°æ•°æ®åº“
    await db.query(
      `INSERT INTO url_mappings 
       (short_code, long_url, user_id, expire_at) 
       VALUES (?, ?, ?, ?)`,
      [shortCode, longURL, userId, expireAt]
    );
    
    // 5. å†™å…¥ç¼“å­˜
    await cache.set(shortCode, longURL);
    
    // 6. è¿”å›ç»“æœ
    return {
      shortURL: `https://short.url/${shortCode}`,
      shortCode,
      longURL,
      createdAt: new Date(),
      expireAt
    };
  }
  
  isValidURL(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
  
  async findByLongURL(longURL, userId) {
    return await db.query(
      `SELECT * FROM url_mappings 
       WHERE long_url = ? AND user_id = ? AND is_active = TRUE
       ORDER BY created_at DESC LIMIT 1`,
      [longURL, userId]
    );
  }
  
  async exists(shortCode) {
    const count = await db.query(
      'SELECT COUNT(*) as count FROM url_mappings WHERE short_code = ?',
      [shortCode]
    );
    return count[0].count > 0;
  }
  
  async generateShortCode() {
    const generator = new SnowflakeGenerator(1, 1);
    return generator.generate();
  }
}
```

### é‡å®šå‘æœåŠ¡

```javascript
class RedirectService {
  async redirect(req, res, shortCode) {
    try {
      // 1. è·å–é•¿URL
      const longURL = await cache.get(shortCode);
      
      if (!longURL || longURL === 'NULL') {
        return res.status(404).send('URL not found');
      }
      
      // 2. å¼‚æ­¥è®°å½•è®¿é—®ç»Ÿè®¡
      this.trackClick(shortCode, req).catch(err => {
        console.error('Failed to track click:', err);
      });
      
      // 3. 302é‡å®šå‘
      res.redirect(302, longURL);
      
    } catch (error) {
      console.error('Redirect error:', error);
      res.status(500).send('Internal server error');
    }
  }
  
  async trackClick(shortCode, req) {
    // æå–ä¿¡æ¯
    const clickData = {
      shortCode,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      referer: req.headers['referer'],
      country: await this.getCountry(req.ip),
      deviceType: this.getDeviceType(req.headers['user-agent'])
    };
    
    // å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå¼‚æ­¥å¤„ç†ï¼‰
    await messageQueue.publish('url.click', clickData);
  }
  
  async getCountry(ip) {
    // ä½¿ç”¨IPåœ°ç†ä½ç½®åº“
    return geoip.lookup(ip)?.country || 'Unknown';
  }
  
  getDeviceType(userAgent) {
    if (/mobile/i.test(userAgent)) return 'mobile';
    if (/tablet/i.test(userAgent)) return 'tablet';
    return 'desktop';
  }
}
```

### ç»Ÿè®¡åˆ†æ

```javascript
class AnalyticsService {
  async getAnalytics(shortCode, startDate, endDate) {
    // 1. æ€»ç‚¹å‡»æ•°
    const totalClicks = await db.query(
      `SELECT COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?`,
      [shortCode, startDate, endDate]
    );
    
    // 2. å”¯ä¸€ç‚¹å‡»æ•°
    const uniqueClicks = await db.query(
      `SELECT COUNT(DISTINCT ip_address) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?`,
      [shortCode, startDate, endDate]
    );
    
    // 3. æŒ‰æ—¥æœŸç»Ÿè®¡
    const clicksByDate = await db.query(
      `SELECT DATE(clicked_at) as date, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY DATE(clicked_at)
       ORDER BY date`,
      [shortCode, startDate, endDate]
    );
    
    // 4. æŒ‰å›½å®¶ç»Ÿè®¡
    const clicksByCountry = await db.query(
      `SELECT country, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY country
       ORDER BY count DESC
       LIMIT 10`,
      [shortCode, startDate, endDate]
    );
    
    // 5. æŒ‰è®¾å¤‡ç»Ÿè®¡
    const clicksByDevice = await db.query(
      `SELECT device_type, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY device_type`,
      [shortCode, startDate, endDate]
    );
    
    return {
      shortCode,
      totalClicks: totalClicks[0].count,
      uniqueClicks: uniqueClicks[0].count,
      clicksByDate: this.formatTimeSeries(clicksByDate),
      clicksByCountry: this.formatDistribution(clicksByCountry),
      clicksByDevice: this.formatDistribution(clicksByDevice)
    };
  }
  
  formatTimeSeries(data) {
    return data.reduce((acc, row) => {
      acc[row.date] = row.count;
      return acc;
    }, {});
  }
  
  formatDistribution(data) {
    return data.reduce((acc, row) => {
      acc[row.country || row.device_type] = row.count;
      return acc;
    }, {});
  }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å¸ƒéš†è¿‡æ»¤å™¨

```javascript
class BloomFilter {
  constructor(size = 10000000, hashCount = 7) {
    this.size = size;
    this.hashCount = hashCount;
    this.bits = new Uint8Array(Math.ceil(size / 8));
  }
  
  add(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(item, i) % this.size;
      const byteIndex = Math.floor(hash / 8);
      const bitIndex = hash % 8;
      this.bits[byteIndex] |= (1 << bitIndex);
    }
  }
  
  contains(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(item, i) % this.size;
      const byteIndex = Math.floor(hash / 8);
      const bitIndex = hash % 8;
      if ((this.bits[byteIndex] & (1 << bitIndex)) === 0) {
        return false;
      }
    }
    return true;
  }
  
  hash(item, seed) {
    let hash = seed;
    for (let i = 0; i < item.length; i++) {
      hash = ((hash << 5) - hash) + item.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}

// ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿåˆ¤æ–­çŸ­ç æ˜¯å¦å­˜åœ¨
const bloomFilter = new BloomFilter();

async function exists(shortCode) {
  // å…ˆç”¨å¸ƒéš†è¿‡æ»¤å™¨åˆ¤æ–­
  if (!bloomFilter.contains(shortCode)) {
    return false; // ä¸€å®šä¸å­˜åœ¨
  }
  
  // å¯èƒ½å­˜åœ¨ï¼ŒæŸ¥è¯¢æ•°æ®åº“ç¡®è®¤
  return await db.exists(shortCode);
}
```

### 2. æ‰¹é‡å¤„ç†

```javascript
class BatchProcessor {
  constructor() {
    this.clickBuffer = [];
    this.batchSize = 1000;
    this.flushInterval = 5000; // 5ç§’
    
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  addClick(clickData) {
    this.clickBuffer.push(clickData);
    
    if (this.clickBuffer.length >= this.batchSize) {
      this.flush();
    }
  }
  
  async flush() {
    if (this.clickBuffer.length === 0) return;
    
    const batch = this.clickBuffer.splice(0, this.batchSize);
    
    try {
      await db.batchInsert('url_clicks', batch);
    } catch (error) {
      console.error('Failed to flush clicks:', error);
      // é‡è¯•æˆ–è®°å½•åˆ°æ—¥å¿—
    }
  }
}
```

## å®‰å…¨æ€§

### 1. é˜²æ­¢æ»¥ç”¨

```javascript
class RateLimiter {
  async checkLimit(userId, ip) {
    // ç”¨æˆ·é™æµ
    if (userId) {
      const userKey = `rate:user:${userId}`;
      const count = await redis.incr(userKey);
      if (count === 1) {
        await redis.expire(userKey, 3600); // 1å°æ—¶
      }
      if (count > 100) {
        throw new Error('User rate limit exceeded');
      }
    }
    
    // IPé™æµ
    const ipKey = `rate:ip:${ip}`;
    const ipCount = await redis.incr(ipKey);
    if (ipCount === 1) {
      await redis.expire(ipKey, 3600);
    }
    if (ipCount > 10) {
      throw new Error('IP rate limit exceeded');
    }
  }
}
```

### 2. æ¶æ„URLæ£€æµ‹

```javascript
class URLValidator {
  constructor() {
    this.blacklist = new Set([
      'malware.com',
      'phishing.com'
    ]);
  }
  
  async validate(url) {
    const domain = new URL(url).hostname;
    
    // æ£€æŸ¥é»‘åå•
    if (this.blacklist.has(domain)) {
      throw new Error('URL is blacklisted');
    }
    
    // è°ƒç”¨å®‰å…¨APIæ£€æŸ¥
    const isSafe = await this.checkSafeBrowsing(url);
    if (!isSafe) {
      throw new Error('URL is unsafe');
    }
    
    return true;
  }
  
  async checkSafeBrowsing(url) {
    // è°ƒç”¨Google Safe Browsing API
    // æˆ–å…¶ä»–å®‰å…¨æ£€æµ‹æœåŠ¡
    return true;
  }
}
```

## ç›‘æ§å‘Šè­¦

```javascript
class MonitoringSystem {
  async monitor() {
    // 1. QPSç›‘æ§
    const qps = await this.getQPS();
    if (qps > 200000) {
      await this.alert('High QPS', { qps });
    }
    
    // 2. ç¼“å­˜å‘½ä¸­ç‡
    const hitRate = await this.getCacheHitRate();
    if (hitRate < 0.8) {
      await this.alert('Low cache hit rate', { hitRate });
    }
    
    // 3. é”™è¯¯ç‡
    const errorRate = await this.getErrorRate();
    if (errorRate > 0.01) {
      await this.alert('High error rate', { errorRate });
    }
    
    // 4. å“åº”æ—¶é—´
    const latency = await this.getLatency();
    if (latency > 100) {
      await this.alert('High latency', { latency });
    }
  }
}
```

## æ€»ç»“

çŸ­é“¾æ¥ç³»ç»Ÿè®¾è®¡çš„æ ¸å¿ƒï¼š
- ğŸ”‘ **çŸ­ç ç”Ÿæˆ**ï¼šSnowflake + Base62ä¿è¯å”¯ä¸€æ€§
- ğŸ’¾ **å­˜å‚¨è®¾è®¡**ï¼šåˆ†åº“åˆ†è¡¨ + ç´¢å¼•ä¼˜åŒ–
- ğŸš€ **ç¼“å­˜ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜ + å¸ƒéš†è¿‡æ»¤å™¨
- ğŸ“Š **ç»Ÿè®¡åˆ†æ**ï¼šå¼‚æ­¥å¤„ç† + æ—¶åºæ•°æ®åº“
- ğŸ›¡ï¸ **å®‰å…¨é˜²æŠ¤**ï¼šé™æµ + URLéªŒè¯
- ğŸ“ˆ **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡å¤„ç† + CDNåŠ é€Ÿ

è®°ä½ï¼š**çŸ­é“¾æ¥ç³»ç»Ÿçš„æœ¬è´¨æ˜¯é«˜æ€§èƒ½çš„é”®å€¼å­˜å‚¨å’Œé‡å®šå‘æœåŠ¡ï¼**

