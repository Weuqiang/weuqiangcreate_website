---
sidebar_position: 3
title: å¾®æœåŠ¡æ¶æ„è®¾è®¡
tags: [åç«¯, å¾®æœåŠ¡, åˆ†å¸ƒå¼, Docker, Kubernetes]
---

# å¾®æœåŠ¡æ¶æ„è®¾è®¡

å¾®æœåŠ¡æ¶æ„æ˜¯å°†å•ä½“åº”ç”¨æ‹†åˆ†ä¸ºå¤šä¸ªå°å‹æœåŠ¡çš„æ¶æ„æ¨¡å¼ï¼Œæœ¬æ–‡å°†æ·±å…¥è®²è§£å¾®æœåŠ¡çš„è®¾è®¡ä¸å®è·µã€‚

## å¾®æœåŠ¡åŸºç¡€

### æ¶æ„å¯¹æ¯”

```javascript
// å•ä½“æ¶æ„
class MonolithicApp {
  constructor() {
    this.userService = new UserService();
    this.orderService = new OrderService();
    this.productService = new ProductService();
    this.paymentService = new PaymentService();
  }
  
  // æ‰€æœ‰åŠŸèƒ½åœ¨ä¸€ä¸ªåº”ç”¨ä¸­
  async createOrder(userId, productId) {
    const user = await this.userService.getUser(userId);
    const product = await this.productService.getProduct(productId);
    const order = await this.orderService.createOrder(user, product);
    await this.paymentService.processPayment(order);
    return order;
  }
}

// å¾®æœåŠ¡æ¶æ„
class MicroservicesApp {
  constructor() {
    this.userServiceClient = new UserServiceClient('http://user-service');
    this.orderServiceClient = new OrderServiceClient('http://order-service');
    this.productServiceClient = new ProductServiceClient('http://product-service');
    this.paymentServiceClient = new PaymentServiceClient('http://payment-service');
  }
  
  // é€šè¿‡HTTP/gRPCè°ƒç”¨å„ä¸ªæœåŠ¡
  async createOrder(userId, productId) {
    const user = await this.userServiceClient.getUser(userId);
    const product = await this.productServiceClient.getProduct(productId);
    const order = await this.orderServiceClient.createOrder({
      userId: user.id,
      productId: product.id
    });
    await this.paymentServiceClient.processPayment(order.id);
    return order;
  }
}
```

### æœåŠ¡æ‹†åˆ†åŸåˆ™

```javascript
// æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†
const services = {
  userService: {
    responsibilities: [
      'ç”¨æˆ·æ³¨å†Œ',
      'ç”¨æˆ·ç™»å½•',
      'ç”¨æˆ·ä¿¡æ¯ç®¡ç†',
      'æƒé™ç®¡ç†'
    ],
    database: 'user_db',
    port: 3001
  },
  
  orderService: {
    responsibilities: [
      'è®¢å•åˆ›å»º',
      'è®¢å•æŸ¥è¯¢',
      'è®¢å•çŠ¶æ€ç®¡ç†'
    ],
    database: 'order_db',
    port: 3002
  },
  
  productService: {
    responsibilities: [
      'å•†å“ç®¡ç†',
      'åº“å­˜ç®¡ç†',
      'å•†å“æœç´¢'
    ],
    database: 'product_db',
    port: 3003
  },
  
  paymentService: {
    responsibilities: [
      'æ”¯ä»˜å¤„ç†',
      'é€€æ¬¾å¤„ç†',
      'æ”¯ä»˜è®°å½•'
    ],
    database: 'payment_db',
    port: 3004
  }
};

// å•ä¸€èŒè´£åŸåˆ™
class UserService {
  // âœ… æ­£ç¡®ï¼šåªè´Ÿè´£ç”¨æˆ·ç›¸å…³åŠŸèƒ½
  async createUser(userData) {
    // åˆ›å»ºç”¨æˆ·
  }
  
  async getUser(userId) {
    // è·å–ç”¨æˆ·
  }
  
  // âŒ é”™è¯¯ï¼šä¸åº”è¯¥åŒ…å«è®¢å•é€»è¾‘
  async getUserOrders(userId) {
    // åº”è¯¥è°ƒç”¨OrderService
  }
}
```

## æœåŠ¡é—´é€šä¿¡

### REST API

```javascript
// ç”¨æˆ·æœåŠ¡
const express = require('express');
const app = express();

app.use(express.json());

// ç”¨æˆ·API
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    res.json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const user = await User.create(req.body);
    res.status(201).json(user);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.listen(3001);

// è®¢å•æœåŠ¡è°ƒç”¨ç”¨æˆ·æœåŠ¡
const axios = require('axios');

class OrderService {
  async createOrder(orderData) {
    // è°ƒç”¨ç”¨æˆ·æœåŠ¡éªŒè¯ç”¨æˆ·
    const userResponse = await axios.get(
      `http://user-service:3001/api/users/${orderData.userId}`
    );
    
    if (!userResponse.data) {
      throw new Error('User not found');
    }
    
    // åˆ›å»ºè®¢å•
    const order = await Order.create(orderData);
    return order;
  }
}
```

### gRPC

```protobuf
// user.proto
syntax = "proto3";

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message User {
  int64 id = 1;
  string name = 2;
  string email = 3;
}

message GetUserRequest {
  int64 id = 1;
}

message GetUserResponse {
  User user = 1;
}
```

```javascript
// gRPCæœåŠ¡ç«¯
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

const packageDefinition = protoLoader.loadSync('user.proto');
const userProto = grpc.loadPackageDefinition(packageDefinition);

const server = new grpc.Server();

server.addService(userProto.UserService.service, {
  getUser: async (call, callback) => {
    try {
      const user = await User.findById(call.request.id);
      callback(null, { user });
    } catch (err) {
      callback(err);
    }
  },
  
  createUser: async (call, callback) => {
    try {
      const user = await User.create(call.request);
      callback(null, { user });
    } catch (err) {
      callback(err);
    }
  }
});

server.bindAsync(
  '0.0.0.0:50051',
  grpc.ServerCredentials.createInsecure(),
  () => {
    server.start();
  }
);

// gRPCå®¢æˆ·ç«¯
const client = new userProto.UserService(
  'user-service:50051',
  grpc.credentials.createInsecure()
);

client.getUser({ id: 1 }, (err, response) => {
  if (err) {
    console.error(err);
  } else {
    console.log(response.user);
  }
});
```

### æ¶ˆæ¯é˜Ÿåˆ—

```javascript
// RabbitMQå‘å¸ƒè€…
const amqp = require('amqplib');

class OrderPublisher {
  async connect() {
    this.connection = await amqp.connect('amqp://localhost');
    this.channel = await this.connection.createChannel();
    await this.channel.assertExchange('orders', 'topic', { durable: true });
  }
  
  async publishOrderCreated(order) {
    const message = JSON.stringify({
      event: 'order.created',
      data: order,
      timestamp: new Date()
    });
    
    this.channel.publish(
      'orders',
      'order.created',
      Buffer.from(message),
      { persistent: true }
    );
  }
}

// RabbitMQè®¢é˜…è€…
class PaymentSubscriber {
  async connect() {
    this.connection = await amqp.connect('amqp://localhost');
    this.channel = await this.connection.createChannel();
    
    await this.channel.assertExchange('orders', 'topic', { durable: true });
    const queue = await this.channel.assertQueue('payment-queue', { durable: true });
    
    await this.channel.bindQueue(queue.queue, 'orders', 'order.created');
    
    this.channel.consume(queue.queue, async (msg) => {
      const event = JSON.parse(msg.content.toString());
      
      try {
        await this.handleOrderCreated(event.data);
        this.channel.ack(msg);
      } catch (err) {
        console.error(err);
        this.channel.nack(msg, false, true);
      }
    });
  }
  
  async handleOrderCreated(order) {
    // å¤„ç†æ”¯ä»˜
    await Payment.create({
      orderId: order.id,
      amount: order.amount
    });
  }
}
```

## æœåŠ¡å‘ç°

### Consul

```javascript
const Consul = require('consul');

class ServiceRegistry {
  constructor() {
    this.consul = new Consul({
      host: 'consul-server',
      port: 8500
    });
  }
  
  // æ³¨å†ŒæœåŠ¡
  async register(serviceName, serviceId, port) {
    await this.consul.agent.service.register({
      id: serviceId,
      name: serviceName,
      address: 'localhost',
      port: port,
      check: {
        http: `http://localhost:${port}/health`,
        interval: '10s',
        timeout: '5s'
      }
    });
  }
  
  // æ³¨é”€æœåŠ¡
  async deregister(serviceId) {
    await this.consul.agent.service.deregister(serviceId);
  }
  
  // å‘ç°æœåŠ¡
  async discover(serviceName) {
    const result = await this.consul.health.service({
      service: serviceName,
      passing: true
    });
    
    return result.map(entry => ({
      id: entry.Service.ID,
      address: entry.Service.Address,
      port: entry.Service.Port
    }));
  }
  
  // è´Ÿè½½å‡è¡¡
  async getServiceInstance(serviceName) {
    const instances = await this.discover(serviceName);
    
    if (instances.length === 0) {
      throw new Error(`No instances found for ${serviceName}`);
    }
    
    // éšæœºé€‰æ‹©
    const index = Math.floor(Math.random() * instances.length);
    return instances[index];
  }
}

// ä½¿ç”¨æœåŠ¡å‘ç°
class OrderService {
  constructor() {
    this.registry = new ServiceRegistry();
  }
  
  async createOrder(orderData) {
    // å‘ç°ç”¨æˆ·æœåŠ¡
    const userService = await this.registry.getServiceInstance('user-service');
    
    // è°ƒç”¨ç”¨æˆ·æœåŠ¡
    const response = await axios.get(
      `http://${userService.address}:${userService.port}/api/users/${orderData.userId}`
    );
    
    // åˆ›å»ºè®¢å•
    const order = await Order.create(orderData);
    return order;
  }
}
```

## APIç½‘å…³

```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

class APIGateway {
  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }
  
  setupMiddleware() {
    // è®¤è¯
    this.app.use(async (req, res, next) => {
      const token = req.headers.authorization;
      
      if (!token && !this.isPublicRoute(req.path)) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      try {
        req.user = await this.verifyToken(token);
        next();
      } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
      }
    });
    
    // é™æµ
    this.app.use(this.rateLimiter());
    
    // æ—¥å¿—
    this.app.use((req, res, next) => {
      console.log(`${req.method} ${req.url}`);
      next();
    });
  }
  
  setupRoutes() {
    // ç”¨æˆ·æœåŠ¡
    this.app.use('/api/users', createProxyMiddleware({
      target: 'http://user-service:3001',
      changeOrigin: true,
      pathRewrite: {
        '^/api/users': '/api/users'
      }
    }));
    
    // è®¢å•æœåŠ¡
    this.app.use('/api/orders', createProxyMiddleware({
      target: 'http://order-service:3002',
      changeOrigin: true
    }));
    
    // å•†å“æœåŠ¡
    this.app.use('/api/products', createProxyMiddleware({
      target: 'http://product-service:3003',
      changeOrigin: true
    }));
  }
  
  isPublicRoute(path) {
    const publicRoutes = ['/api/auth/login', '/api/auth/register'];
    return publicRoutes.includes(path);
  }
  
  async verifyToken(token) {
    // éªŒè¯JWT token
    return jwt.verify(token, process.env.JWT_SECRET);
  }
  
  rateLimiter() {
    const rateLimit = require('express-rate-limit');
    return rateLimit({
      windowMs: 15 * 60 * 1000,
      max: 100
    });
  }
  
  start(port) {
    this.app.listen(port, () => {
      console.log(`API Gateway running on port ${port}`);
    });
  }
}

const gateway = new APIGateway();
gateway.start(8080);
```

## é…ç½®ä¸­å¿ƒ

```javascript
// ä½¿ç”¨Consulä½œä¸ºé…ç½®ä¸­å¿ƒ
class ConfigCenter {
  constructor() {
    this.consul = new Consul({
      host: 'consul-server',
      port: 8500
    });
    this.cache = new Map();
  }
  
  // è·å–é…ç½®
  async get(key) {
    // å…ˆä»ç¼“å­˜è·å–
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    // ä»Consulè·å–
    const result = await this.consul.kv.get(key);
    if (result) {
      const value = result.Value;
      this.cache.set(key, value);
      return value;
    }
    
    return null;
  }
  
  // è®¾ç½®é…ç½®
  async set(key, value) {
    await this.consul.kv.set(key, value);
    this.cache.set(key, value);
  }
  
  // ç›‘å¬é…ç½®å˜åŒ–
  async watch(key, callback) {
    const watcher = this.consul.watch({
      method: this.consul.kv.get,
      options: { key }
    });
    
    watcher.on('change', (data) => {
      const value = data.Value;
      this.cache.set(key, value);
      callback(value);
    });
    
    watcher.on('error', (err) => {
      console.error('Watch error:', err);
    });
  }
}

// ä½¿ç”¨é…ç½®ä¸­å¿ƒ
const config = new ConfigCenter();

async function initService() {
  // è·å–æ•°æ®åº“é…ç½®
  const dbConfig = await config.get('service/database');
  
  // ç›‘å¬é…ç½®å˜åŒ–
  config.watch('service/database', (newConfig) => {
    console.log('Database config changed:', newConfig);
    // é‡æ–°è¿æ¥æ•°æ®åº“
  });
}
```

## å®¹å™¨åŒ–éƒ¨ç½²

### Docker

```dockerfile
# Dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "3001:3000"
    environment:
      - DB_HOST=postgres
      - DB_NAME=users
    depends_on:
      - postgres
    networks:
      - microservices
  
  order-service:
    build: ./order-service
    ports:
      - "3002:3000"
    environment:
      - DB_HOST=postgres
      - DB_NAME=orders
    depends_on:
      - postgres
      - rabbitmq
    networks:
      - microservices
  
  product-service:
    build: ./product-service
    ports:
      - "3003:3000"
    environment:
      - DB_HOST=postgres
      - DB_NAME=products
    depends_on:
      - postgres
    networks:
      - microservices
  
  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    depends_on:
      - user-service
      - order-service
      - product-service
    networks:
      - microservices
  
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - microservices
  
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    networks:
      - microservices
  
  consul:
    image: consul:latest
    ports:
      - "8500:8500"
    networks:
      - microservices

networks:
  microservices:
    driver: bridge

volumes:
  postgres-data:
```

### Kubernetes

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 3000
        env:
        - name: DB_HOST
          value: postgres
        - name: DB_NAME
          value: users
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

## æœåŠ¡ç›‘æ§

```javascript
// PrometheusæŒ‡æ ‡
const promClient = require('prom-client');

class MetricsCollector {
  constructor() {
    this.register = new promClient.Registry();
    
    // HTTPè¯·æ±‚è®¡æ•°å™¨
    this.httpRequestCounter = new promClient.Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'path', 'status'],
      registers: [this.register]
    });
    
    // HTTPè¯·æ±‚å»¶è¿Ÿ
    this.httpRequestDuration = new promClient.Histogram({
      name: 'http_request_duration_seconds',
      help: 'HTTP request duration in seconds',
      labelNames: ['method', 'path', 'status'],
      registers: [this.register]
    });
    
    // é»˜è®¤æŒ‡æ ‡
    promClient.collectDefaultMetrics({ register: this.register });
  }
  
  middleware() {
    return (req, res, next) => {
      const start = Date.now();
      
      res.on('finish', () => {
        const duration = (Date.now() - start) / 1000;
        
        this.httpRequestCounter.inc({
          method: req.method,
          path: req.route?.path || req.path,
          status: res.statusCode
        });
        
        this.httpRequestDuration.observe({
          method: req.method,
          path: req.route?.path || req.path,
          status: res.statusCode
        }, duration);
      });
      
      next();
    };
  }
  
  getMetrics() {
    return this.register.metrics();
  }
}

// ä½¿ç”¨ç›‘æ§
const metrics = new MetricsCollector();
app.use(metrics.middleware());

app.get('/metrics', async (req, res) => {
  res.set('Content-Type', this.register.contentType);
  res.end(await metrics.getMetrics());
});
```

## é“¾è·¯è¿½è¸ª

```javascript
// Jaegerè¿½è¸ª
const { initTracer } = require('jaeger-client');

class TracingService {
  constructor(serviceName) {
    const config = {
      serviceName: serviceName,
      sampler: {
        type: 'const',
        param: 1
      },
      reporter: {
        logSpans: true,
        agentHost: 'jaeger-agent',
        agentPort: 6832
      }
    };
    
    this.tracer = initTracer(config);
  }
  
  middleware() {
    return (req, res, next) => {
      const span = this.tracer.startSpan(`${req.method} ${req.path}`);
      
      span.setTag('http.method', req.method);
      span.setTag('http.url', req.url);
      
      req.span = span;
      
      res.on('finish', () => {
        span.setTag('http.status_code', res.statusCode);
        span.finish();
      });
      
      next();
    };
  }
  
  async traceAsync(name, fn) {
    const span = this.tracer.startSpan(name);
    
    try {
      const result = await fn(span);
      span.setTag('success', true);
      return result;
    } catch (err) {
      span.setTag('error', true);
      span.log({ event: 'error', message: err.message });
      throw err;
    } finally {
      span.finish();
    }
  }
}

// ä½¿ç”¨è¿½è¸ª
const tracing = new TracingService('order-service');
app.use(tracing.middleware());

async function createOrder(orderData) {
  return await tracing.traceAsync('create-order', async (span) => {
    // è°ƒç”¨ç”¨æˆ·æœåŠ¡
    span.log({ event: 'calling-user-service' });
    const user = await getUserService(orderData.userId);
    
    // åˆ›å»ºè®¢å•
    span.log({ event: 'creating-order' });
    const order = await Order.create(orderData);
    
    return order;
  });
}
```

## æ€»ç»“

å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒï¼š
- ğŸ—ï¸ **æœåŠ¡æ‹†åˆ†**ï¼šæŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†
- ğŸ”Œ **æœåŠ¡é€šä¿¡**ï¼šRESTã€gRPCã€æ¶ˆæ¯é˜Ÿåˆ—
- ğŸ” **æœåŠ¡å‘ç°**ï¼šConsulã€Eureka
- ğŸšª **APIç½‘å…³**ï¼šç»Ÿä¸€å…¥å£ã€è®¤è¯ã€é™æµ
- âš™ï¸ **é…ç½®ä¸­å¿ƒ**ï¼šé›†ä¸­ç®¡ç†é…ç½®
- ğŸ³ **å®¹å™¨åŒ–**ï¼šDockerã€Kubernetes
- ğŸ“Š **ç›‘æ§è¿½è¸ª**ï¼šPrometheusã€Jaeger

è®°ä½ï¼š**å¾®æœåŠ¡ä¸æ˜¯é“¶å¼¹ï¼Œè¦æ ¹æ®å®é™…æƒ…å†µé€‰æ‹©ï¼**

