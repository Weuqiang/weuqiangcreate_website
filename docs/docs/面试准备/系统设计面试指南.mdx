---
sidebar_position: 3
title: 
tags: [, , ]
---

# 



## 

### 1. 

```javascript
/**
 * 
 */

const designProcess = {
  step1: {
    name: '',
    questions: [
      '',
      '',
      '',
      '',
      '',
      ''
    ]
  },
  
  step2: {
    name: '',
    calculations: {
      users: ' * ',
      qps: ' / 86400',
      storage: ' * ',
      bandwidth: 'QPS * '
    }
  },
  
  step3: {
    name: '',
    components: [
      '',
      '',
      '',
      '',
      '',
      '',
      'CDN'
    ]
  },
  
  step4: {
    name: '',
    topics: [
      '',
      'API',
      '',
      '',
      '',
      ''
    ]
  }
};
```

### 2. 

```javascript
/**
 * 
 */

// 
const shortVideoSystem = {
  // 
  assumptions: {
    dailyActiveUsers: 100_000_000,      // 1DAU
    videosPerUser: 10,                  // 10
    avgVideoSize: 5 * 1024 * 1024,      // 5MB
    avgViewDuration: 30,                // 30
    peakFactor: 3                       // 3
  },
  
  // 
  calculations: {
    // QPS
    dailyVideos: 100_000_000 * 10,                    // 10
    avgQPS: 1_000_000_000 / 86400,                    // ~11,574
    peakQPS: 11_574 * 3,                              // ~34,722
    
    // 
    dailyStorage: 1_000_000_000 * 5 * 1024 * 1024,   // 5PB/
    yearlyStorage: 5 * 365,                           // 1825PB/
    
    // 
    avgBandwidth: 11_574 * 5 * 1024 * 1024,          // ~58TB/s
    peakBandwidth: 58 * 3                             // ~174TB/s
  },
  
  // 
  decisions: {
    storage: 'CDN + OSS',
    database: ' + ',
    cache: 'Redis',
    mq: 'Kafka'
  }
};
```

## 

### 1. URL

```javascript
/**
 * URL
 */

// 
const requirements = {
  functional: [
    'URLURL',
    'URLURL',
    'URL',
    ''
  ],
  nonFunctional: [
    '99.9%',
    '<100ms',
    '10000 QPS'
  ]
};

// API
class URLShortenerAPI {
  // URL
  async createShortURL(longURL, customAlias = null) {
    // POST /api/shorten
    // Body: { longURL, customAlias }
    
    // 1. URL
    if (!this.isValidURL(longURL)) {
      throw new Error('Invalid URL');
    }
    
    // 2. 
    const existing = await this.db.findByLongURL(longURL);
    if (existing) {
      return existing.shortURL;
    }
    
    // 3. 
    const shortCode = customAlias || this.generateShortCode();
    
    // 4. 
    if (await this.db.exists(shortCode)) {
      throw new Error('Short code already exists');
    }
    
    // 5. 
    await this.db.save({
      shortCode,
      longURL,
      createdAt: new Date(),
      clicks: 0
    });
    
    return `https://short.url/${shortCode}`;
  }
  
  // 
  async redirect(shortCode) {
    // GET /:shortCode
    
    // 1. 
    let longURL = await this.cache.get(shortCode);
    
    if (!longURL) {
      // 2. 
      const record = await this.db.findByShortCode(shortCode);
      
      if (!record) {
        throw new Error('URL not found');
      }
      
      longURL = record.longURL;
      
      // 3. 
      await this.cache.set(shortCode, longURL, 3600);
    }
    
    // 4. 
    this.updateStats(shortCode);
    
    return longURL;
  }
  
  // 
  generateShortCode() {
    // 1Base62
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const id = this.getNextID(); // ID
    
    let shortCode = '';
    let num = id;
    
    while (num > 0) {
      shortCode = chars[num % 62] + shortCode;
      num = Math.floor(num / 62);
    }
    
    return shortCode.padStart(7, '0'); // 7
  }
  
  // 2 + 
  generateShortCodeHash(longURL) {
    const hash = crypto.createHash('md5').update(longURL).digest('hex');
    return hash.substring(0, 7);
  }
}

// 
const schema = {
  urls: {
    id: 'BIGINT PRIMARY KEY',
    short_code: 'VARCHAR(10) UNIQUE INDEX',
    long_url: 'VARCHAR(2048)',
    created_at: 'TIMESTAMP',
    expires_at: 'TIMESTAMP',
    clicks: 'INT DEFAULT 0',
    INDEX: ['short_code', 'long_url']
  }
};

// 
const architecture = {
  client: 'Web/Mobile App',
  loadBalancer: 'Nginx',
  appServers: 'Node.js',
  cache: 'Redis',
  database: 'MySQL + ',
  storage: '',
  mq: 'Kafka'
};
```

### 2. 

```javascript
/**
 * 
 */

class SeckillSystem {
  // 
  async seckill(userId, productId) {
    // 1. 
    
    // 2. 
    if (!await this.rateLimiter.allow(userId)) {
      throw new Error('');
    }
    
    // 3. Redis
    const stock = await this.redis.get(`stock:${productId}`);
    if (stock <= 0) {
      throw new Error('');
    }
    
    // 4. 
    const newStock = await this.redis.decr(`stock:${productId}`);
    if (newStock < 0) {
      await this.redis.incr(`stock:${productId}`);
      throw new Error('');
    }
    
    // 5. 
    await this.mq.send({
      type: 'CREATE_ORDER',
      userId,
      productId,
      timestamp: Date.now()
    });
    
    return { success: true, message: '' };
  }
  
  // 
  async processOrder(message) {
    const { userId, productId } = message;
    
    try {
      // 1. 
      const order = await this.db.transaction(async (trx) => {
        // 
        const existing = await trx('orders')
          .where({ userId, productId })
          .first();
        
        if (existing) {
          throw new Error('');
        }
        
        // 
        const updated = await trx('products')
          .where('id', productId)
          .where('stock', '>', 0)
          .decrement('stock', 1);
        
        if (updated === 0) {
          throw new Error('');
        }
        
        // 
        const [orderId] = await trx('orders').insert({
          userId,
          productId,
          status: 'PENDING',
          createdAt: new Date()
        });
        
        return orderId;
      });
      
      // 2. 
      await this.notification.send(userId, {
        type: 'ORDER_CREATED',
        orderId: order
      });
      
    } catch (error) {
      // Redis
      await this.redis.incr(`stock:${productId}`);
      
      // 
      await this.notification.send(userId, {
        type: 'ORDER_FAILED',
        reason: error.message
      });
    }
  }
  
  // 
  async warmupStock(productId) {
    const product = await this.db('products')
      .where('id', productId)
      .first();
    
    await this.redis.set(`stock:${productId}`, product.stock);
  }
}

// 
const optimizations = {
  frontend: [
    '',
    '',
    ''
  ],
  
  backend: [
    '',
    'Redis',
    '',
    ''
  ],
  
  database: [
    '',
    '',
    '',
    ''
  ],
  
  infrastructure: [
    'CDN',
    '',
    '',
    ''
  ]
};
```

### 3. ID

```javascript
/**
 * ID
 */

// 1Snowflake
class SnowflakeIDGenerator {
  constructor(workerId, datacenterId) {
    this.workerId = workerId;           // 10
    this.datacenterId = datacenterId;   // 10
    this.sequence = 0;                  // 12
    this.lastTimestamp = -1;
    
    // 412020-01-01
    this.epoch = 1577836800000;
  }
  
  generate() {
    let timestamp = Date.now();
    
    // 
    if (timestamp < this.lastTimestamp) {
      throw new Error('Clock moved backwards');
    }
    
    // 
    if (timestamp === this.lastTimestamp) {
      this.sequence = (this.sequence + 1) & 0xfff; // 12
      
      // 
      if (this.sequence === 0) {
        timestamp = this.waitNextMillis(timestamp);
      }
    } else {
      this.sequence = 0;
    }
    
    this.lastTimestamp = timestamp;
    
    // ID
    const id = 
      ((timestamp - this.epoch) << 22) |  // 41
      (this.datacenterId << 17) |         // 5
      (this.workerId << 12) |             // 5ID
      this.sequence;                      // 12
    
    return id;
  }
  
  waitNextMillis(timestamp) {
    while (timestamp <= this.lastTimestamp) {
      timestamp = Date.now();
    }
    return timestamp;
  }
}

// 2ID
class DatabaseIDGenerator {
  async generate() {
    const result = await this.db.query(`
      REPLACE INTO id_generator (stub) VALUES ('a');
      SELECT LAST_INSERT_ID() as id;
    `);
    
    return result[0].id;
  }
}

// 3Redis
class RedisIDGenerator {
  async generate(key) {
    return await this.redis.incr(key);
  }
  
  // 
  async generateBatch(key, count) {
    const max = await this.redis.incrby(key, count);
    const min = max - count + 1;
    
    return { min, max };
  }
}

// 4UUID
class UUIDGenerator {
  generate() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}

// 
const comparison = {
  snowflake: {
    pros: ['', '', ''],
    cons: ['', 'ID']
  },
  
  database: {
    pros: ['', ''],
    cons: ['', '']
  },
  
  redis: {
    pros: ['', ''],
    cons: ['Redis', '']
  },
  
  uuid: {
    pros: ['', ''],
    cons: ['', '']
  }
};
```

### 4. 

```javascript
/**
 * 
 */

class MessageQueue {
  constructor() {
    this.queues = new Map();
    this.consumers = new Map();
  }
  
  // 
  async send(topic, message) {
    if (!this.queues.has(topic)) {
      this.queues.set(topic, []);
    }
    
    const msg = {
      id: this.generateID(),
      topic,
      body: message,
      timestamp: Date.now(),
      retryCount: 0
    };
    
    // 
    await this.persist(msg);
    
    // 
    this.queues.get(topic).push(msg);
    
    // 
    this.notifyConsumers(topic);
    
    return msg.id;
  }
  
  // 
  subscribe(topic, handler) {
    if (!this.consumers.has(topic)) {
      this.consumers.set(topic, []);
    }
    
    this.consumers.get(topic).push(handler);
  }
  
  // 
  async consume(topic) {
    const queue = this.queues.get(topic);
    if (!queue || queue.length === 0) return;
    
    const message = queue.shift();
    const handlers = this.consumers.get(topic) || [];
    
    for (const handler of handlers) {
      try {
        await handler(message);
        
        // 
        await this.ack(message.id);
      } catch (error) {
        // 
        await this.retry(message);
      }
    }
  }
  
  // 
  async retry(message) {
    message.retryCount++;
    
    if (message.retryCount > 3) {
      // 
      await this.sendToDeadLetter(message);
      return;
    }
    
    // 
    const delay = Math.pow(2, message.retryCount) * 1000;
    setTimeout(() => {
      this.queues.get(message.topic).push(message);
    }, delay);
  }
  
  // 
  async persist(message) {
    await this.db.insert('messages', message);
  }
  
  // 
  async ack(messageId) {
    await this.db.delete('messages', { id: messageId });
  }
}

// 
const features = {
  reliability: [
    '',
    'ACK',
    '',
    ''
  ],
  
  performance: [
    '',
    '',
    '',
    ''
  ],
  
  scalability: [
    '',
    '',
    '',
    ''
  ],
  
  ordering: [
    '',
    '',
    ''
  ]
};
```

## 


-  ****
-  ****QPS
-  ****
-  ****
-  ****
-  ****

****

