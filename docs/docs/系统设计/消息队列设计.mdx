---
sidebar_position: 9
title: æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡ä¸å®ç°
tags: [ç³»ç»Ÿè®¾è®¡, æ¶ˆæ¯é˜Ÿåˆ—, Kafka, RabbitMQ]
---

# æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡ä¸å®ç°

æ¶ˆæ¯é˜Ÿåˆ—æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ï¼Œæœ¬æ–‡å°†è¯¦ç»†è®²è§£æ¶ˆæ¯é˜Ÿåˆ—çš„è®¾è®¡åŸç†å’Œå®ç°æ–¹æ¡ˆã€‚

## æ¶ˆæ¯é˜Ÿåˆ—åŸºç¡€

### æ ¸å¿ƒæ¦‚å¿µ

```javascript
const mqConcepts = {
  // ç”Ÿäº§è€…
  producer: {
    role: 'å‘é€æ¶ˆæ¯',
    responsibilities: [
      'æ¶ˆæ¯åºåˆ—åŒ–',
      'é€‰æ‹©åˆ†åŒº',
      'å‘é€ç¡®è®¤'
    ]
  },
  
  // æ¶ˆè´¹è€…
  consumer: {
    role: 'æ¥æ”¶æ¶ˆæ¯',
    responsibilities: [
      'æ¶ˆæ¯ååºåˆ—åŒ–',
      'ä¸šåŠ¡å¤„ç†',
      'æäº¤åç§»é‡'
    ]
  },
  
  // ä¸»é¢˜/é˜Ÿåˆ—
  topic: {
    role: 'æ¶ˆæ¯åˆ†ç±»',
    features: [
      'å¤šåˆ†åŒº',
      'æŒä¹…åŒ–',
      'é¡ºåºä¿è¯'
    ]
  },
  
  // æ¶ˆè´¹ç»„
  consumerGroup: {
    role: 'è´Ÿè½½å‡è¡¡',
    features: [
      'åˆ†åŒºåˆ†é…',
      'æ•…éšœè½¬ç§»',
      'æ°´å¹³æ‰©å±•'
    ]
  }
};
```

### æ¶ˆæ¯æ¨¡å‹

```javascript
// ç‚¹å¯¹ç‚¹æ¨¡å‹
class QueueModel {
  constructor() {
    this.queue = [];
    this.consumers = [];
  }
  
  send(message) {
    this.queue.push(message);
    this.notifyConsumer();
  }
  
  receive() {
    return this.queue.shift();
  }
  
  notifyConsumer() {
    // è½®è¯¢åˆ†é…ç»™æ¶ˆè´¹è€…
    if (this.consumers.length > 0) {
      const consumer = this.consumers[this.currentIndex % this.consumers.length];
      consumer.onMessage(this.receive());
      this.currentIndex++;
    }
  }
}

// å‘å¸ƒè®¢é˜…æ¨¡å‹
class PubSubModel {
  constructor() {
    this.topics = new Map();
  }
  
  subscribe(topic, subscriber) {
    if (!this.topics.has(topic)) {
      this.topics.set(topic, []);
    }
    this.topics.get(topic).push(subscriber);
  }
  
  publish(topic, message) {
    const subscribers = this.topics.get(topic) || [];
    
    // å¹¿æ’­ç»™æ‰€æœ‰è®¢é˜…è€…
    for (const subscriber of subscribers) {
      subscriber.onMessage(message);
    }
  }
}
```

## Kafkaå®ç°

### Producerå®ç°

```javascript
const { Kafka } = require('kafkajs');

class KafkaProducer {
  constructor(brokers) {
    this.kafka = new Kafka({
      clientId: 'my-app',
      brokers
    });
    
    this.producer = this.kafka.producer({
      // é…ç½®
      allowAutoTopicCreation: true,
      transactionTimeout: 30000
    });
  }
  
  async connect() {
    await this.producer.connect();
  }
  
  async send(topic, messages) {
    try {
      const result = await this.producer.send({
        topic,
        messages: messages.map(msg => ({
          key: msg.key,
          value: JSON.stringify(msg.value),
          partition: msg.partition,
          headers: msg.headers
        }))
      });
      
      return result;
    } catch (error) {
      console.error('Failed to send message:', error);
      throw error;
    }
  }
  
  // æ‰¹é‡å‘é€
  async sendBatch(topic, messages) {
    const batch = this.producer.sendBatch({
      topicMessages: [{
        topic,
        messages: messages.map(msg => ({
          value: JSON.stringify(msg)
        }))
      }]
    });
    
    return await batch;
  }
  
  // äº‹åŠ¡å‘é€
  async sendTransaction(topic, messages) {
    const transaction = await this.producer.transaction();
    
    try {
      await transaction.send({
        topic,
        messages: messages.map(msg => ({
          value: JSON.stringify(msg)
        }))
      });
      
      await transaction.commit();
    } catch (error) {
      await transaction.abort();
      throw error;
    }
  }
  
  async disconnect() {
    await this.producer.disconnect();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const producer = new KafkaProducer(['localhost:9092']);

await producer.connect();

await producer.send('user-events', [
  {
    key: 'user-123',
    value: {
      type: 'user_created',
      userId: '123',
      timestamp: Date.now()
    }
  }
]);
```

### Consumerå®ç°

```javascript
class KafkaConsumer {
  constructor(brokers, groupId) {
    this.kafka = new Kafka({
      clientId: 'my-app',
      brokers
    });
    
    this.consumer = this.kafka.consumer({
      groupId,
      sessionTimeout: 30000,
      heartbeatInterval: 3000
    });
    
    this.handlers = new Map();
  }
  
  async connect() {
    await this.consumer.connect();
  }
  
  async subscribe(topics) {
    await this.consumer.subscribe({
      topics,
      fromBeginning: false
    });
  }
  
  registerHandler(topic, handler) {
    this.handlers.set(topic, handler);
  }
  
  async run() {
    await this.consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        const handler = this.handlers.get(topic);
        
        if (!handler) {
          console.warn(`No handler for topic: ${topic}`);
          return;
        }
        
        try {
          const value = JSON.parse(message.value.toString());
          
          await handler({
            topic,
            partition,
            offset: message.offset,
            key: message.key?.toString(),
            value,
            headers: message.headers,
            timestamp: message.timestamp
          });
          
        } catch (error) {
          console.error('Error processing message:', error);
          // é”™è¯¯å¤„ç†ï¼šé‡è¯•ã€æ­»ä¿¡é˜Ÿåˆ—ç­‰
          await this.handleError(topic, message, error);
        }
      }
    });
  }
  
  async handleError(topic, message, error) {
    // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
    await producer.send(`${topic}.dlq`, [{
      value: {
        originalMessage: message,
        error: error.message,
        timestamp: Date.now()
      }
    }]);
  }
  
  async disconnect() {
    await this.consumer.disconnect();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const consumer = new KafkaConsumer(['localhost:9092'], 'my-group');

await consumer.connect();
await consumer.subscribe(['user-events']);

consumer.registerHandler('user-events', async (message) => {
  console.log('Received message:', message.value);
  
  // ä¸šåŠ¡å¤„ç†
  await processUserEvent(message.value);
});

await consumer.run();
```

## RabbitMQå®ç°

### ç”Ÿäº§è€…

```javascript
const amqp = require('amqplib');

class RabbitMQProducer {
  constructor(url) {
    this.url = url;
    this.connection = null;
    this.channel = null;
  }
  
  async connect() {
    this.connection = await amqp.connect(this.url);
    this.channel = await this.connection.createChannel();
  }
  
  async sendToQueue(queue, message, options = {}) {
    // ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨
    await this.channel.assertQueue(queue, {
      durable: true,
      ...options
    });
    
    // å‘é€æ¶ˆæ¯
    const sent = this.channel.sendToQueue(
      queue,
      Buffer.from(JSON.stringify(message)),
      {
        persistent: true,
        contentType: 'application/json'
      }
    );
    
    if (!sent) {
      // ç­‰å¾…drainäº‹ä»¶
      await new Promise(resolve => {
        this.channel.once('drain', resolve);
      });
    }
  }
  
  async publishToExchange(exchange, routingKey, message, options = {}) {
    // å£°æ˜äº¤æ¢æœº
    await this.channel.assertExchange(exchange, 'topic', {
      durable: true,
      ...options
    });
    
    // å‘å¸ƒæ¶ˆæ¯
    this.channel.publish(
      exchange,
      routingKey,
      Buffer.from(JSON.stringify(message)),
      {
        persistent: true,
        contentType: 'application/json'
      }
    );
  }
  
  async close() {
    await this.channel.close();
    await this.connection.close();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const producer = new RabbitMQProducer('amqp://localhost');
await producer.connect();

// å‘é€åˆ°é˜Ÿåˆ—
await producer.sendToQueue('tasks', {
  type: 'email',
  to: 'user@example.com',
  subject: 'Hello'
});

// å‘å¸ƒåˆ°äº¤æ¢æœº
await producer.publishToExchange(
  'events',
  'user.created',
  { userId: '123' }
);
```

### æ¶ˆè´¹è€…

```javascript
class RabbitMQConsumer {
  constructor(url) {
    this.url = url;
    this.connection = null;
    this.channel = null;
  }
  
  async connect() {
    this.connection = await amqp.connect(this.url);
    this.channel = await this.connection.createChannel();
    
    // è®¾ç½®é¢„å–æ•°é‡
    await this.channel.prefetch(10);
  }
  
  async consumeQueue(queue, handler, options = {}) {
    // ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨
    await this.channel.assertQueue(queue, {
      durable: true,
      ...options
    });
    
    // æ¶ˆè´¹æ¶ˆæ¯
    await this.channel.consume(queue, async (msg) => {
      if (!msg) return;
      
      try {
        const content = JSON.parse(msg.content.toString());
        
        await handler(content, msg);
        
        // ç¡®è®¤æ¶ˆæ¯
        this.channel.ack(msg);
        
      } catch (error) {
        console.error('Error processing message:', error);
        
        // æ‹’ç»æ¶ˆæ¯å¹¶é‡æ–°å…¥é˜Ÿ
        this.channel.nack(msg, false, true);
      }
    });
  }
  
  async subscribeToExchange(exchange, pattern, handler) {
    // å£°æ˜äº¤æ¢æœº
    await this.channel.assertExchange(exchange, 'topic', {
      durable: true
    });
    
    // åˆ›å»ºä¸´æ—¶é˜Ÿåˆ—
    const { queue } = await this.channel.assertQueue('', {
      exclusive: true
    });
    
    // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
    await this.channel.bindQueue(queue, exchange, pattern);
    
    // æ¶ˆè´¹æ¶ˆæ¯
    await this.consumeQueue(queue, handler);
  }
  
  async close() {
    await this.channel.close();
    await this.connection.close();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const consumer = new RabbitMQConsumer('amqp://localhost');
await consumer.connect();

// æ¶ˆè´¹é˜Ÿåˆ—
await consumer.consumeQueue('tasks', async (message) => {
  console.log('Processing task:', message);
  await processTask(message);
});

// è®¢é˜…äº¤æ¢æœº
await consumer.subscribeToExchange(
  'events',
  'user.*',
  async (message) => {
    console.log('User event:', message);
  }
);
```

## æ¶ˆæ¯å¯é æ€§

### ç”Ÿäº§è€…ç¡®è®¤

```javascript
class ReliableProducer {
  constructor(producer) {
    this.producer = producer;
    this.pendingMessages = new Map();
  }
  
  async sendWithConfirm(topic, message) {
    const messageId = this.generateMessageId();
    
    // ä¿å­˜å¾…ç¡®è®¤æ¶ˆæ¯
    this.pendingMessages.set(messageId, {
      topic,
      message,
      timestamp: Date.now(),
      retries: 0
    });
    
    try {
      await this.producer.send(topic, [{
        key: messageId,
        value: message
      }]);
      
      // ç¡®è®¤æˆåŠŸ
      this.pendingMessages.delete(messageId);
      
    } catch (error) {
      // é‡è¯•
      await this.retry(messageId);
    }
  }
  
  async retry(messageId) {
    const pending = this.pendingMessages.get(messageId);
    
    if (!pending) return;
    
    if (pending.retries >= 3) {
      // è¶…è¿‡é‡è¯•æ¬¡æ•°ï¼Œè®°å½•å¤±è´¥
      console.error('Message failed after retries:', pending);
      this.pendingMessages.delete(messageId);
      return;
    }
    
    pending.retries++;
    
    // æŒ‡æ•°é€€é¿
    const delay = Math.pow(2, pending.retries) * 1000;
    
    setTimeout(async () => {
      try {
        await this.producer.send(pending.topic, [{
          key: messageId,
          value: pending.message
        }]);
        
        this.pendingMessages.delete(messageId);
      } catch (error) {
        await this.retry(messageId);
      }
    }, delay);
  }
  
  generateMessageId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### æ¶ˆè´¹è€…å¹‚ç­‰æ€§

```javascript
class IdempotentConsumer {
  constructor(consumer, redis) {
    this.consumer = consumer;
    this.redis = redis;
  }
  
  async processMessage(message, handler) {
    const messageId = message.key || this.getMessageId(message);
    
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    const processed = await this.redis.get(`processed:${messageId}`);
    
    if (processed) {
      console.log('Message already processed:', messageId);
      return;
    }
    
    // å¤„ç†æ¶ˆæ¯
    await handler(message);
    
    // æ ‡è®°ä¸ºå·²å¤„ç†ï¼ˆ24å°æ—¶è¿‡æœŸï¼‰
    await this.redis.setex(`processed:${messageId}`, 86400, '1');
  }
  
  getMessageId(message) {
    // æ ¹æ®æ¶ˆæ¯å†…å®¹ç”Ÿæˆå”¯ä¸€ID
    const crypto = require('crypto');
    return crypto
      .createHash('md5')
      .update(JSON.stringify(message))
      .digest('hex');
  }
}
```

## å»¶è¿Ÿé˜Ÿåˆ—

```javascript
class DelayQueue {
  constructor(redis) {
    this.redis = redis;
    this.queueKey = 'delay_queue';
  }
  
  async add(message, delaySeconds) {
    const executeAt = Date.now() + delaySeconds * 1000;
    
    await this.redis.zadd(
      this.queueKey,
      executeAt,
      JSON.stringify(message)
    );
  }
  
  async poll() {
    const now = Date.now();
    
    // è·å–åˆ°æœŸçš„æ¶ˆæ¯
    const messages = await this.redis.zrangebyscore(
      this.queueKey,
      0,
      now,
      'LIMIT',
      0,
      100
    );
    
    if (messages.length === 0) {
      return [];
    }
    
    // åˆ é™¤å·²è·å–çš„æ¶ˆæ¯
    await this.redis.zremrangebyscore(this.queueKey, 0, now);
    
    return messages.map(msg => JSON.parse(msg));
  }
  
  async start(handler) {
    setInterval(async () => {
      const messages = await this.poll();
      
      for (const message of messages) {
        try {
          await handler(message);
        } catch (error) {
          console.error('Error processing delayed message:', error);
        }
      }
    }, 1000);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const delayQueue = new DelayQueue(redis);

// æ·»åŠ å»¶è¿Ÿæ¶ˆæ¯
await delayQueue.add({
  type: 'reminder',
  userId: '123',
  message: 'Your order is ready'
}, 3600); // 1å°æ—¶åæ‰§è¡Œ

// å¯åŠ¨è½®è¯¢
delayQueue.start(async (message) => {
  console.log('Processing delayed message:', message);
  await sendNotification(message);
});
```

## æ­»ä¿¡é˜Ÿåˆ—

```javascript
class DeadLetterQueue {
  constructor(producer, consumer) {
    this.producer = producer;
    this.consumer = consumer;
    this.maxRetries = 3;
  }
  
  async handleFailedMessage(topic, message, error) {
    const retries = message.retries || 0;
    
    if (retries < this.maxRetries) {
      // é‡è¯•
      await this.retry(topic, message, retries + 1);
    } else {
      // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
      await this.sendToDLQ(topic, message, error);
    }
  }
  
  async retry(topic, message, retries) {
    // æŒ‡æ•°é€€é¿
    const delay = Math.pow(2, retries) * 1000;
    
    setTimeout(async () => {
      await this.producer.send(topic, [{
        value: {
          ...message,
          retries
        }
      }]);
    }, delay);
  }
  
  async sendToDLQ(topic, message, error) {
    const dlqTopic = `${topic}.dlq`;
    
    await this.producer.send(dlqTopic, [{
      value: {
        originalTopic: topic,
        originalMessage: message,
        error: error.message,
        stack: error.stack,
        timestamp: Date.now()
      }
    }]);
    
    console.error('Message sent to DLQ:', {
      topic: dlqTopic,
      message
    });
  }
  
  async processDLQ(dlqTopic, handler) {
    await this.consumer.subscribe([dlqTopic]);
    
    this.consumer.registerHandler(dlqTopic, async (message) => {
      // äººå·¥å¤„ç†æˆ–è®°å½•
      await handler(message.value);
    });
  }
}
```

## æ¶ˆæ¯é¡ºåºæ€§

```javascript
class OrderedMessageProcessor {
  constructor() {
    this.processing = new Map();
  }
  
  async process(message, handler) {
    const key = message.key;
    
    // ç­‰å¾…åŒä¸€keyçš„å‰åºæ¶ˆæ¯å¤„ç†å®Œæˆ
    while (this.processing.has(key)) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    
    this.processing.set(key, true);
    
    try {
      await handler(message);
    } finally {
      this.processing.delete(key);
    }
  }
}

// Kafkaåˆ†åŒºä¿è¯é¡ºåº
class PartitionedProducer {
  async send(topic, messages) {
    // ç›¸åŒkeyçš„æ¶ˆæ¯å‘é€åˆ°åŒä¸€åˆ†åŒº
    await this.producer.send({
      topic,
      messages: messages.map(msg => ({
        key: msg.userId, // ä½¿ç”¨userIdä½œä¸ºåˆ†åŒºé”®
        value: JSON.stringify(msg),
        partition: this.getPartition(msg.userId)
      }))
    });
  }
  
  getPartition(key) {
    // ä¸€è‡´æ€§å“ˆå¸Œ
    const hash = this.hashCode(key);
    return hash % this.partitionCount;
  }
  
  hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

## ç›‘æ§å‘Šè­¦

```javascript
class MessageQueueMonitor {
  async monitor() {
    // 1. æ¶ˆæ¯ç§¯å‹
    const lag = await this.getConsumerLag();
    if (lag > 10000) {
      await this.alert('High consumer lag', { lag });
    }
    
    // 2. æ¶ˆè´¹é€Ÿç‡
    const consumeRate = await this.getConsumeRate();
    if (consumeRate < 100) {
      await this.alert('Low consume rate', { consumeRate });
    }
    
    // 3. é”™è¯¯ç‡
    const errorRate = await this.getErrorRate();
    if (errorRate > 0.01) {
      await this.alert('High error rate', { errorRate });
    }
    
    // 4. æ­»ä¿¡é˜Ÿåˆ—å¤§å°
    const dlqSize = await this.getDLQSize();
    if (dlqSize > 1000) {
      await this.alert('DLQ size too large', { dlqSize });
    }
  }
  
  async getConsumerLag() {
    // è·å–æ¶ˆè´¹è€…å»¶è¿Ÿ
    const admin = this.kafka.admin();
    await admin.connect();
    
    const groups = await admin.fetchOffsets({
      groupId: 'my-group'
    });
    
    let totalLag = 0;
    for (const topic of groups) {
      for (const partition of topic.partitions) {
        totalLag += partition.lag;
      }
    }
    
    await admin.disconnect();
    return totalLag;
  }
}
```

## æ€»ç»“

æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡çš„æ ¸å¿ƒï¼š
- ğŸ“¨ **æ¶ˆæ¯æ¨¡å‹**ï¼šç‚¹å¯¹ç‚¹ + å‘å¸ƒè®¢é˜…
- ğŸ”’ **å¯é æ€§**ï¼šç”Ÿäº§è€…ç¡®è®¤ + æ¶ˆè´¹è€…å¹‚ç­‰
- â° **å»¶è¿Ÿé˜Ÿåˆ—**ï¼šå®šæ—¶ä»»åŠ¡ + å»¶è¿Ÿå¤„ç†
- ğŸ’€ **æ­»ä¿¡é˜Ÿåˆ—**ï¼šå¤±è´¥é‡è¯• + å¼‚å¸¸å¤„ç†
- ğŸ“Š **é¡ºåºä¿è¯**ï¼šåˆ†åŒºé”® + é¡ºåºå¤„ç†
- ğŸ“ˆ **ç›‘æ§å‘Šè­¦**ï¼šæ¶ˆæ¯ç§¯å‹ + é”™è¯¯ç‡

è®°ä½ï¼š**æ¶ˆæ¯é˜Ÿåˆ—çš„æœ¬è´¨æ˜¯å¼‚æ­¥è§£è€¦å’Œå‰Šå³°å¡«è°·ï¼**

