---
sidebar_position: 3
title: 
tags: [, , ]
---

# 



## 

### 

```mermaid
graph TB
    A[] --> B[]
    A --> C[]
    A --> D[]
    A --> E[]
    
    style A fill:#42b883
    style B fill:#ffe1e1
```

****:
-  ****: QPS 1000QPS 100+
-  ****: 1000:1
- ⏰ ****: 
-  ****: 
-  ****: 

## 

### 

```javascript
// 
const requirements = {
  // 1. 
  preStart: {
    showCountdown: true,      // 
    showProductInfo: true,    // 
    allowReminder: true       // 
  },
  
  // 2. 
  during: {
    placeOrder: true,         // 
    checkInventory: true,     // 
    preventOversell: true,    // 
    limitPerUser: true        // 
  },
  
  // 3. 
  postEnd: {
    showResult: true,         // 
    processPayment: true,     // 
    handleTimeout: true       // 
  }
};
```

### 

```javascript
const nonFunctionalRequirements = {
  // 
  performance: {
    qps: 1_000_000,           // 100QPS
    latency: 100,             // 100ms
    concurrency: 10_000_000   // 1000
  },
  
  // 
  availability: {
    uptime: 99.99,            // 99.99%
    failover: true,           // 
    degradation: true         // 
  },
  
  // 
  consistency: {
    inventory: 'strong',      // 
    order: 'eventual'         // 
  }
};
```

## 

### 

```python
# 
 = 10_000_000      # 1000
 = 10                # 10
 = 10_000            # 1

# QPS
 =  * 3    # 3++
QPS_ =  / 

print(f"QPS: {QPS_:,}")  # 3,000,000 QPS

# 
 = 
 =  /  * 100

print(f": {:.2f}%")  # 0.1%

# 
 = 1024          # 1KB
 = 2048          # 2KB

_Gbps = (QPS_ *  * 8) / (1024 ** 3)
_Gbps = (QPS_ *  * 8) / (1024 ** 3)

print(f": {_Gbps:.2f} Gbps")
print(f": {_Gbps:.2f} Gbps")
```

## 

### 

```
                    
                            
                    
                           
                    
                         CDN     
                    
                           
                    
                        
                    
                           
        
                                            
                 
                             
                 
                                            
        
                           
                    
                            
                    
                           
        
                                            
                 
     Redis           MQ              MySQL  
                           
                 
```

### 

```javascript
// 1.  - 
class AccessLayer {
  async handleRequest(request) {
    // 1.1 
    if (!await this.rateLimiter.allow(request.userId)) {
      return { code: 429, message: '' };
    }
    
    // 1.2 
    if (!await this.validator.check(request)) {
      return { code: 400, message: '' };
    }
    
    // 1.3 
    if (await this.antiBot.isBot(request)) {
      return { code: 403, message: '' };
    }
    
    // 
    return await this.businessLayer.process(request);
  }
}

// 2.  - 
class BusinessLayer {
  async process(request) {
    const { userId, productId, quantity } = request;
    
    // 2.1 
    if (!await this.checkSeckillTime(productId)) {
      return { code: 400, message: '' };
    }
    
    // 2.2 
    if (!await this.checkUserEligibility(userId, productId)) {
      return { code: 403, message: '' };
    }
    
    // 2.3 
    const success = await this.deductInventory(productId, quantity);
    if (!success) {
      return { code: 400, message: '' };
    }
    
    // 2.4 
    await this.createOrderAsync(userId, productId, quantity);
    
    return { code: 200, message: '' };
  }
}

// 3.  - 
class DataLayer {
  // Redis
  async getInventory(productId) {
    return await this.redis.get(`inventory:${productId}`);
  }
  
  // 
  async deductInventory(productId, quantity) {
    const script = `
      local key = KEYS[1]
      local quantity = tonumber(ARGV[1])
      local inventory = tonumber(redis.call('get', key))
      
      if inventory >= quantity then
        redis.call('decrby', key, quantity)
        return 1
      else
        return 0
      end
    `;
    
    return await this.redis.eval(script, 1, `inventory:${productId}`, quantity);
  }
}
```

## 

### 1. 

```javascript
// 1.1 CDN
const config = {
  cdn: {
    images: 'https://cdn.example.com/images',
    scripts: 'https://cdn.example.com/js',
    styles: 'https://cdn.example.com/css'
  }
};

// 1.2 
// HTMLCDN
function generateStaticPage(product) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>${product.name} - </title>
      <link rel="stylesheet" href="${config.cdn.styles}/seckill.css">
    </head>
    <body>
      <div id="product" data-id="${product.id}">
        <img src="${config.cdn.images}/${product.image}">
        <h1>${product.name}</h1>
        <p class="price">¥${product.price}</p>
        <button id="seckill-btn"></button>
      </div>
      <script src="${config.cdn.scripts}/seckill.js"></script>
    </body>
    </html>
  `;
}

// 1.3 
class SeckillButton {
  constructor(startTime) {
    this.startTime = startTime;
    this.button = document.getElementById('seckill-btn');
    this.init();
  }
  
  init() {
    // 
    this.countdown();
    
    // 
    this.button.addEventListener('click', this.debounce(this.handleClick, 1000));
  }
  
  countdown() {
    const now = Date.now();
    const diff = this.startTime - now;
    
    if (diff > 0) {
      this.button.disabled = true;
      this.button.textContent = `${Math.ceil(diff / 1000)}`;
      setTimeout(() => this.countdown(), 1000);
    } else {
      this.button.disabled = false;
      this.button.textContent = '';
    }
  }
  
  debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      if (timer) return;
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    };
  }
  
  async handleClick() {
    this.button.disabled = true;
    this.button.textContent = '...';
    
    try {
      const result = await this.seckill();
      if (result.success) {
        alert('');
        window.location.href = '/order/' + result.orderId;
      } else {
        alert(result.message);
        this.button.disabled = false;
        this.button.textContent = '';
      }
    } catch (error) {
      alert('');
      this.button.disabled = false;
      this.button.textContent = '';
    }
  }
}
```

### 2. 

```javascript
// 2.1 
class RateLimiter {
  // IP
  async checkIPLimit(ip) {
    const key = `rate:ip:${ip}`;
    const count = await redis.incr(key);
    
    if (count === 1) {
      await redis.expire(key, 1); // 1
    }
    
    return count <= 10; // 10
  }
  
  // 
  async checkUserLimit(userId) {
    const key = `rate:user:${userId}`;
    const count = await redis.incr(key);
    
    if (count === 1) {
      await redis.expire(key, 1);
    }
    
    return count <= 5; // 5
  }
  
  // 
  async checkGlobalLimit() {
    const script = `
      local key = KEYS[1]
      local capacity = tonumber(ARGV[1])
      local rate = tonumber(ARGV[2])
      local now = tonumber(ARGV[3])
      
      local tokens = tonumber(redis.call('get', key) or capacity)
      local last_time = tonumber(redis.call('get', key .. ':time') or now)
      
      local delta = math.max(0, now - last_time)
      local new_tokens = math.min(capacity, tokens + delta * rate)
      
      if new_tokens >= 1 then
        redis.call('set', key, new_tokens - 1)
        redis.call('set', key .. ':time', now)
        return 1
      else
        return 0
      end
    `;
    
    return await redis.eval(
      script,
      1,
      'rate:global',
      1000000,  // 100
      10000,    // 1
      Date.now()
    );
  }
}

// 2.2 
class CaptchaValidator {
  // 
  async validateSlide(token, distance) {
    const expected = await redis.get(`captcha:${token}`);
    return Math.abs(distance - expected) < 5;
  }
  
  // 
  async validateClick(token, positions) {
    const expected = await redis.get(`captcha:${token}`);
    return this.comparePositions(positions, expected);
  }
}

// 2.3 
class AntiBotSystem {
  async isBot(request) {
    const score = await this.calculateRiskScore(request);
    return score > 80; // 80
  }
  
  async calculateRiskScore(request) {
    let score = 0;
    
    // User-Agent
    if (!request.headers['user-agent']) {
      score += 30;
    }
    
    // 
    const frequency = await this.getRequestFrequency(request.ip);
    if (frequency > 100) {
      score += 40;
    }
    
    // 
    const pattern = await this.analyzePattern(request.userId);
    if (pattern.suspicious) {
      score += 30;
    }
    
    return score;
  }
}
```

### 3. 

```javascript
// 3.1 
class InventoryWarmer {
  async warmup(productId, quantity) {
    // Redis
    await redis.set(`inventory:${productId}`, quantity);
    
    // 
    await redis.expire(`inventory:${productId}`, 3600);
    
    // 
    localCache.set(`inventory:${productId}`, quantity);
  }
}

// 3.2 
class InventoryManager {
  // Lua
  async deduct(productId, quantity) {
    const script = `
      local key = KEYS[1]
      local quantity = tonumber(ARGV[1])
      local inventory = tonumber(redis.call('get', key) or 0)
      
      if inventory >= quantity then
        redis.call('decrby', key, quantity)
        return 1
      else
        return 0
      end
    `;
    
    const result = await redis.eval(
      script,
      1,
      `inventory:${productId}`,
      quantity
    );
    
    return result === 1;
  }
  
  // 
  async deductWithSharding(productId, quantity) {
    const shardCount = 10;
    const shard = Math.floor(Math.random() * shardCount);
    const key = `inventory:${productId}:${shard}`;
    
    return await this.deduct(key, quantity);
  }
}

// 3.3 
class OrderCreator {
  async createAsync(userId, productId, quantity) {
    // 
    await messageQueue.publish('order.create', {
      userId,
      productId,
      quantity,
      timestamp: Date.now()
    });
  }
  
  // 
  async processOrder(message) {
    const { userId, productId, quantity } = message;
    
    try {
      // 
      const order = await db.orders.create({
        userId,
        productId,
        quantity,
        status: 'PENDING',
        createdAt: new Date()
      });
      
      // 
      await this.scheduleTimeout(order.id, 15 * 60 * 1000); // 15
      
      // 
      await this.notifyUser(userId, order.id);
      
    } catch (error) {
      // 
      await this.rollbackInventory(productId, quantity);
      throw error;
    }
  }
}
```

### 4. 

```javascript
// 4.1 Redis
class RedisCluster {
  constructor(nodes) {
    this.nodes = nodes;
    this.hashSlots = 16384;
  }
  
  getNode(key) {
    const slot = this.crc16(key) % this.hashSlots;
    return this.nodes.find(node => 
      slot >= node.slotStart && slot <= node.slotEnd
    );
  }
  
  async get(key) {
    const node = this.getNode(key);
    return await node.get(key);
  }
  
  async set(key, value) {
    const node = this.getNode(key);
    return await node.set(key, value);
  }
}

// 4.2 
class DatabaseSharding {
  // ID
  getDatabase(userId) {
    const dbIndex = userId % this.dbCount;
    return this.databases[dbIndex];
  }
  
  // ID
  getTable(orderId) {
    const tableIndex = orderId % this.tableCount;
    return `orders_${tableIndex}`;
  }
  
  async createOrder(order) {
    const db = this.getDatabase(order.userId);
    const table = this.getTable(order.id);
    
    return await db.query(
      `INSERT INTO ${table} (id, user_id, product_id, quantity, status) 
       VALUES (?, ?, ?, ?, ?)`,
      [order.id, order.userId, order.productId, order.quantity, order.status]
    );
  }
}

// 4.3 
class MasterSlaveDB {
  async write(query, params) {
    return await this.master.query(query, params);
  }
  
  async read(query, params) {
    // 
    const slave = this.slaves[Math.floor(Math.random() * this.slaves.length)];
    return await slave.query(query, params);
  }
}
```

## 

### 

```javascript
// 1
async function seckillWithPessimisticLock(productId, quantity) {
  const conn = await db.getConnection();
  
  try {
    await conn.beginTransaction();
    
    // SELECT FOR UPDATE 
    const [product] = await conn.query(
      'SELECT inventory FROM products WHERE id = ? FOR UPDATE',
      [productId]
    );
    
    if (product.inventory >= quantity) {
      await conn.query(
        'UPDATE products SET inventory = inventory - ? WHERE id = ?',
        [quantity, productId]
      );
      await conn.commit();
      return true;
    } else {
      await conn.rollback();
      return false;
    }
  } catch (error) {
    await conn.rollback();
    throw error;
  } finally {
    conn.release();
  }
}

// 2
async function seckillWithOptimisticLock(productId, quantity) {
  const maxRetries = 3;
  
  for (let i = 0; i < maxRetries; i++) {
    const [product] = await db.query(
      'SELECT inventory, version FROM products WHERE id = ?',
      [productId]
    );
    
    if (product.inventory >= quantity) {
      const result = await db.query(
        `UPDATE products 
         SET inventory = inventory - ?, version = version + 1 
         WHERE id = ? AND version = ?`,
        [quantity, productId, product.version]
      );
      
      if (result.affectedRows > 0) {
        return true;
      }
      // 
    } else {
      return false;
    }
  }
  
  return false;
}

// 3Redis
async function seckillWithRedis(productId, quantity) {
  const script = `
    local key = KEYS[1]
    local quantity = tonumber(ARGV[1])
    local inventory = tonumber(redis.call('get', key) or 0)
    
    if inventory >= quantity then
      redis.call('decrby', key, quantity)
      return 1
    else
      return 0
    end
  `;
  
  const result = await redis.eval(
    script,
    1,
    `inventory:${productId}`,
    quantity
  );
  
  return result === 1;
}
```

## 

```javascript
class DegradationManager {
  // 
  async handleOverload() {
    // 1. 
    await this.disableFeature('recommendation');
    await this.disableFeature('analytics');
    
    // 2. 
    return this.staticPage;
  }
  
  // 
  async callWithCircuitBreaker(fn) {
    if (this.circuitBreaker.isOpen()) {
      return this.fallback();
    }
    
    try {
      const result = await fn();
      this.circuitBreaker.recordSuccess();
      return result;
    } catch (error) {
      this.circuitBreaker.recordFailure();
      return this.fallback();
    }
  }
  
  // 
  async handleRateLimit(request) {
    if (await this.rateLimiter.isExceeded(request)) {
      // 
      return {
        code: 429,
        message: '',
        queuePosition: await this.getQueuePosition(request.userId)
      };
    }
  }
}
```

## 

```javascript
class MonitoringSystem {
  // 
  async monitor() {
    // 1. QPS
    const qps = await this.getQPS();
    if (qps > this.threshold.qps) {
      await this.alert('QPS', { qps });
    }
    
    // 2. 
    const inventory = await this.getInventory();
    if (inventory < 100) {
      await this.alert('', { inventory });
    }
    
    // 3. 
    const errorRate = await this.getErrorRate();
    if (errorRate > 0.01) {
      await this.alert('', { errorRate });
    }
    
    // 4. 
    const latency = await this.getLatency();
    if (latency > 100) {
      await this.alert('', { latency });
    }
  }
  
  // 
  async alert(message, data) {
    // 
    await alertSystem.send({
      level: 'critical',
      message,
      data,
      timestamp: Date.now()
    });
  }
}
```

## 


-  ****CDN
-  ****
-  ****
-  ****Redis
-  ****RedisLua
-  ****
-  ****

****

