---
sidebar_position: 8
title: APIè®¾è®¡æœ€ä½³å®è·µ
tags: [ç³»ç»Ÿè®¾è®¡, APIè®¾è®¡, RESTful, GraphQL]
---

# APIè®¾è®¡æœ€ä½³å®è·µ

è‰¯å¥½çš„APIè®¾è®¡æ˜¯ç³»ç»ŸæˆåŠŸçš„å…³é”®ï¼Œæœ¬æ–‡å°†è¯¦ç»†è®²è§£APIè®¾è®¡çš„æœ€ä½³å®è·µå’Œå¸¸è§æ¨¡å¼ã€‚

## RESTful APIè®¾è®¡

### èµ„æºå‘½å

```javascript
// âœ… å¥½çš„å‘½å
GET    /api/v1/users              // è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/v1/users/:id          // è·å–å•ä¸ªç”¨æˆ·
POST   /api/v1/users              // åˆ›å»ºç”¨æˆ·
PUT    /api/v1/users/:id          // æ›´æ–°ç”¨æˆ·
DELETE /api/v1/users/:id          // åˆ é™¤ç”¨æˆ·

GET    /api/v1/users/:id/posts    // è·å–ç”¨æˆ·çš„æ–‡ç« 
POST   /api/v1/users/:id/posts    // ä¸ºç”¨æˆ·åˆ›å»ºæ–‡ç« 

// âŒ ä¸å¥½çš„å‘½å
GET    /api/v1/getUsers            // åŠ¨è¯ä¸åº”å‡ºç°åœ¨URLä¸­
POST   /api/v1/user/create         // å†—ä½™çš„create
GET    /api/v1/users/list          // å†—ä½™çš„list
DELETE /api/v1/deleteUser/:id     // åŠ¨è¯ä¸åº”å‡ºç°åœ¨URLä¸­
```

### HTTPæ–¹æ³•

```javascript
const httpMethods = {
  // GET - è·å–èµ„æº
  GET: {
    idempotent: true,
    safe: true,
    cacheable: true,
    examples: [
      'GET /users',
      'GET /users/:id',
      'GET /users/:id/posts'
    ]
  },
  
  // POST - åˆ›å»ºèµ„æº
  POST: {
    idempotent: false,
    safe: false,
    cacheable: false,
    examples: [
      'POST /users',
      'POST /users/:id/posts'
    ]
  },
  
  // PUT - å®Œæ•´æ›´æ–°èµ„æº
  PUT: {
    idempotent: true,
    safe: false,
    cacheable: false,
    examples: [
      'PUT /users/:id'
    ]
  },
  
  // PATCH - éƒ¨åˆ†æ›´æ–°èµ„æº
  PATCH: {
    idempotent: true,
    safe: false,
    cacheable: false,
    examples: [
      'PATCH /users/:id'
    ]
  },
  
  // DELETE - åˆ é™¤èµ„æº
  DELETE: {
    idempotent: true,
    safe: false,
    cacheable: false,
    examples: [
      'DELETE /users/:id'
    ]
  }
};
```

### çŠ¶æ€ç 

```javascript
const statusCodes = {
  // 2xx æˆåŠŸ
  200: 'OK - è¯·æ±‚æˆåŠŸ',
  201: 'Created - èµ„æºåˆ›å»ºæˆåŠŸ',
  204: 'No Content - è¯·æ±‚æˆåŠŸä½†æ— è¿”å›å†…å®¹',
  
  // 3xx é‡å®šå‘
  301: 'Moved Permanently - æ°¸ä¹…é‡å®šå‘',
  302: 'Found - ä¸´æ—¶é‡å®šå‘',
  304: 'Not Modified - èµ„æºæœªä¿®æ”¹',
  
  // 4xx å®¢æˆ·ç«¯é”™è¯¯
  400: 'Bad Request - è¯·æ±‚å‚æ•°é”™è¯¯',
  401: 'Unauthorized - æœªè®¤è¯',
  403: 'Forbidden - æ— æƒé™',
  404: 'Not Found - èµ„æºä¸å­˜åœ¨',
  409: 'Conflict - èµ„æºå†²çª',
  422: 'Unprocessable Entity - éªŒè¯å¤±è´¥',
  429: 'Too Many Requests - è¯·æ±‚è¿‡å¤š',
  
  // 5xx æœåŠ¡å™¨é”™è¯¯
  500: 'Internal Server Error - æœåŠ¡å™¨é”™è¯¯',
  502: 'Bad Gateway - ç½‘å…³é”™è¯¯',
  503: 'Service Unavailable - æœåŠ¡ä¸å¯ç”¨',
  504: 'Gateway Timeout - ç½‘å…³è¶…æ—¶'
};

// ä½¿ç”¨ç¤ºä¾‹
class UserController {
  async getUser(req, res) {
    try {
      const user = await User.findById(req.params.id);
      
      if (!user) {
        return res.status(404).json({
          error: 'User not found'
        });
      }
      
      res.status(200).json(user);
    } catch (error) {
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }
  
  async createUser(req, res) {
    try {
      const user = await User.create(req.body);
      
      res.status(201).json(user);
    } catch (error) {
      if (error.name === 'ValidationError') {
        return res.status(422).json({
          error: 'Validation failed',
          details: error.errors
        });
      }
      
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }
}
```

### è¯·æ±‚å“åº”æ ¼å¼

```typescript
// ç»Ÿä¸€å“åº”æ ¼å¼
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    timestamp: number;
    requestId: string;
  };
}

// æˆåŠŸå“åº”
const successResponse = <T>(data: T): ApiResponse<T> => ({
  success: true,
  data,
  meta: {
    timestamp: Date.now(),
    requestId: generateRequestId()
  }
});

// é”™è¯¯å“åº”
const errorResponse = (code: string, message: string, details?: any): ApiResponse<never> => ({
  success: false,
  error: {
    code,
    message,
    details
  },
  meta: {
    timestamp: Date.now(),
    requestId: generateRequestId()
  }
});

// åˆ†é¡µå“åº”
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
}

// ä½¿ç”¨ç¤ºä¾‹
app.get('/api/v1/users', async (req, res) => {
  const { page = 1, pageSize = 20 } = req.query;
  
  const users = await User.find()
    .skip((page - 1) * pageSize)
    .limit(pageSize);
  
  const total = await User.countDocuments();
  
  res.json({
    success: true,
    data: users,
    pagination: {
      page: Number(page),
      pageSize: Number(pageSize),
      total,
      totalPages: Math.ceil(total / pageSize)
    },
    meta: {
      timestamp: Date.now(),
      requestId: req.id
    }
  });
});
```

## ç‰ˆæœ¬æ§åˆ¶

### URLç‰ˆæœ¬æ§åˆ¶

```javascript
// æ–¹å¼1ï¼šURLè·¯å¾„ç‰ˆæœ¬
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);

// v1ç‰ˆæœ¬
const v1Router = express.Router();
v1Router.get('/users', (req, res) => {
  // v1é€»è¾‘
});

// v2ç‰ˆæœ¬
const v2Router = express.Router();
v2Router.get('/users', (req, res) => {
  // v2é€»è¾‘
});
```

### Headerç‰ˆæœ¬æ§åˆ¶

```javascript
// æ–¹å¼2ï¼šè¯·æ±‚å¤´ç‰ˆæœ¬
app.use('/api', (req, res, next) => {
  const version = req.headers['api-version'] || '1';
  
  if (version === '1') {
    v1Handler(req, res);
  } else if (version === '2') {
    v2Handler(req, res);
  } else {
    res.status(400).json({
      error: 'Unsupported API version'
    });
  }
});
```

### ç‰ˆæœ¬åºŸå¼ƒç­–ç•¥

```javascript
class ApiVersionManager {
  constructor() {
    this.versions = {
      'v1': {
        status: 'deprecated',
        deprecatedAt: '2024-01-01',
        sunsetAt: '2024-06-01',
        message: 'API v1 is deprecated. Please migrate to v2.'
      },
      'v2': {
        status: 'active'
      },
      'v3': {
        status: 'beta'
      }
    };
  }
  
  checkVersion(version) {
    const versionInfo = this.versions[version];
    
    if (!versionInfo) {
      throw new Error('Version not found');
    }
    
    if (versionInfo.status === 'deprecated') {
      return {
        warning: versionInfo.message,
        sunsetAt: versionInfo.sunsetAt
      };
    }
    
    return null;
  }
  
  middleware() {
    return (req, res, next) => {
      const version = this.extractVersion(req);
      const warning = this.checkVersion(version);
      
      if (warning) {
        res.set('Warning', `299 - "${warning.warning}"`);
        res.set('Sunset', warning.sunsetAt);
      }
      
      next();
    };
  }
}
```

## è®¤è¯æˆæƒ

### JWTè®¤è¯

```javascript
const jwt = require('jsonwebtoken');

class AuthService {
  generateToken(user) {
    const payload = {
      userId: user.id,
      email: user.email,
      role: user.role
    };
    
    return jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: '7d'
    });
  }
  
  verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
  
  middleware() {
    return async (req, res, next) => {
      const authHeader = req.headers.authorization;
      
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
          error: 'No token provided'
        });
      }
      
      const token = authHeader.substring(7);
      
      try {
        const decoded = this.verifyToken(token);
        req.user = decoded;
        next();
      } catch (error) {
        res.status(401).json({
          error: 'Invalid token'
        });
      }
    };
  }
}

// ä½¿ç”¨
const authService = new AuthService();

app.post('/api/v1/login', async (req, res) => {
  const { email, password } = req.body;
  
  const user = await User.findOne({ email });
  
  if (!user || !await user.comparePassword(password)) {
    return res.status(401).json({
      error: 'Invalid credentials'
    });
  }
  
  const token = authService.generateToken(user);
  
  res.json({
    success: true,
    data: {
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name
      }
    }
  });
});

// å—ä¿æŠ¤çš„è·¯ç”±
app.get('/api/v1/profile', 
  authService.middleware(),
  async (req, res) => {
    const user = await User.findById(req.user.userId);
    res.json({ success: true, data: user });
  }
);
```

### æƒé™æ§åˆ¶

```javascript
class PermissionMiddleware {
  requireRole(...roles) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({
          error: 'Not authenticated'
        });
      }
      
      if (!roles.includes(req.user.role)) {
        return res.status(403).json({
          error: 'Insufficient permissions'
        });
      }
      
      next();
    };
  }
  
  requirePermission(...permissions) {
    return async (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({
          error: 'Not authenticated'
        });
      }
      
      const userPermissions = await this.getUserPermissions(req.user.userId);
      
      const hasPermission = permissions.every(p => 
        userPermissions.includes(p)
      );
      
      if (!hasPermission) {
        return res.status(403).json({
          error: 'Insufficient permissions'
        });
      }
      
      next();
    };
  }
}

// ä½¿ç”¨
const permission = new PermissionMiddleware();

app.delete('/api/v1/users/:id',
  authService.middleware(),
  permission.requireRole('admin'),
  async (req, res) => {
    await User.deleteById(req.params.id);
    res.status(204).send();
  }
);
```

## é™æµ

### ä»¤ç‰Œæ¡¶ç®—æ³•

```javascript
class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;      // æ¡¶å®¹é‡
    this.tokens = capacity;        // å½“å‰ä»¤ç‰Œæ•°
    this.refillRate = refillRate;  // æ¯ç§’è¡¥å……ä»¤ç‰Œæ•°
    this.lastRefill = Date.now();
  }
  
  refill() {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
  
  consume(tokens = 1) {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }
    
    return false;
  }
}

class RateLimiter {
  constructor() {
    this.buckets = new Map();
  }
  
  middleware(options = {}) {
    const {
      capacity = 100,
      refillRate = 10,
      keyGenerator = (req) => req.ip
    } = options;
    
    return (req, res, next) => {
      const key = keyGenerator(req);
      
      if (!this.buckets.has(key)) {
        this.buckets.set(key, new TokenBucket(capacity, refillRate));
      }
      
      const bucket = this.buckets.get(key);
      
      if (bucket.consume()) {
        res.set('X-RateLimit-Limit', capacity);
        res.set('X-RateLimit-Remaining', Math.floor(bucket.tokens));
        next();
      } else {
        res.status(429).json({
          error: 'Too many requests',
          retryAfter: Math.ceil((1 - bucket.tokens) / refillRate)
        });
      }
    };
  }
}

// ä½¿ç”¨
const rateLimiter = new RateLimiter();

app.use('/api', rateLimiter.middleware({
  capacity: 100,
  refillRate: 10
}));
```

### Redisé™æµ

```javascript
class RedisRateLimiter {
  constructor(redis) {
    this.redis = redis;
  }
  
  async checkLimit(key, limit, window) {
    const now = Date.now();
    const windowStart = now - window * 1000;
    
    // ä½¿ç”¨Redisçš„Sorted Set
    const multi = this.redis.multi();
    
    // ç§»é™¤è¿‡æœŸçš„è¯·æ±‚
    multi.zremrangebyscore(key, 0, windowStart);
    
    // æ·»åŠ å½“å‰è¯·æ±‚
    multi.zadd(key, now, `${now}-${Math.random()}`);
    
    // è·å–çª—å£å†…çš„è¯·æ±‚æ•°
    multi.zcard(key);
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    multi.expire(key, window);
    
    const results = await multi.exec();
    const count = results[2][1];
    
    return {
      allowed: count <= limit,
      remaining: Math.max(0, limit - count),
      resetAt: now + window * 1000
    };
  }
  
  middleware(options = {}) {
    const {
      limit = 100,
      window = 60,
      keyGenerator = (req) => `ratelimit:${req.ip}`
    } = options;
    
    return async (req, res, next) => {
      const key = keyGenerator(req);
      const result = await this.checkLimit(key, limit, window);
      
      res.set('X-RateLimit-Limit', limit);
      res.set('X-RateLimit-Remaining', result.remaining);
      res.set('X-RateLimit-Reset', result.resetAt);
      
      if (result.allowed) {
        next();
      } else {
        res.status(429).json({
          error: 'Too many requests',
          retryAfter: Math.ceil((result.resetAt - Date.now()) / 1000)
        });
      }
    };
  }
}
```

## æ–‡æ¡£ç”Ÿæˆ

### OpenAPI/Swagger

```javascript
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'My API',
      version: '1.0.0',
      description: 'API documentation'
    },
    servers: [
      {
        url: 'http://localhost:3000',
        description: 'Development server'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        }
      }
    }
  },
  apis: ['./routes/*.js']
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

/**
 * @swagger
 * /api/v1/users:
 *   get:
 *     summary: Get all users
 *     tags: [Users]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *         description: Items per page
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 */
app.get('/api/v1/users', getUsers);

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       required:
 *         - email
 *         - name
 *       properties:
 *         id:
 *           type: string
 *         email:
 *           type: string
 *         name:
 *           type: string
 *         createdAt:
 *           type: string
 *           format: date-time
 */
```

## GraphQL API

### Schemaå®šä¹‰

```graphql
type User {
  id: ID!
  email: String!
  name: String!
  posts: [Post!]!
  createdAt: DateTime!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  comments: [Comment!]!
  createdAt: DateTime!
}

type Comment {
  id: ID!
  content: String!
  author: User!
  post: Post!
  createdAt: DateTime!
}

type Query {
  user(id: ID!): User
  users(page: Int, pageSize: Int): UserConnection!
  post(id: ID!): Post
  posts(authorId: ID, page: Int, pageSize: Int): PostConnection!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  
  createPost(input: CreatePostInput!): Post!
  updatePost(id: ID!, input: UpdatePostInput!): Post!
  deletePost(id: ID!): Boolean!
}

input CreateUserInput {
  email: String!
  name: String!
  password: String!
}

input UpdateUserInput {
  email: String
  name: String
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```

### Resolverå®ç°

```javascript
const resolvers = {
  Query: {
    user: async (_, { id }, context) => {
      return await context.dataSources.userAPI.getUser(id);
    },
    
    users: async (_, { page = 1, pageSize = 20 }, context) => {
      const users = await context.dataSources.userAPI.getUsers({
        page,
        pageSize
      });
      
      return {
        edges: users.map(user => ({
          node: user,
          cursor: Buffer.from(user.id).toString('base64')
        })),
        pageInfo: {
          hasNextPage: users.length === pageSize,
          hasPreviousPage: page > 1
        },
        totalCount: await context.dataSources.userAPI.getUserCount()
      };
    }
  },
  
  Mutation: {
    createUser: async (_, { input }, context) => {
      return await context.dataSources.userAPI.createUser(input);
    },
    
    updateUser: async (_, { id, input }, context) => {
      return await context.dataSources.userAPI.updateUser(id, input);
    }
  },
  
  User: {
    posts: async (user, _, context) => {
      return await context.dataSources.postAPI.getPostsByAuthor(user.id);
    }
  },
  
  Post: {
    author: async (post, _, context) => {
      return await context.dataSources.userAPI.getUser(post.authorId);
    },
    
    comments: async (post, _, context) => {
      return await context.dataSources.commentAPI.getCommentsByPost(post.id);
    }
  }
};
```

## é”™è¯¯å¤„ç†

```javascript
class ApiError extends Error {
  constructor(code, message, statusCode = 500, details = null) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

// é”™è¯¯ç±»å‹
class ValidationError extends ApiError {
  constructor(message, details) {
    super('VALIDATION_ERROR', message, 422, details);
  }
}

class NotFoundError extends ApiError {
  constructor(resource) {
    super('NOT_FOUND', `${resource} not found`, 404);
  }
}

class UnauthorizedError extends ApiError {
  constructor(message = 'Unauthorized') {
    super('UNAUTHORIZED', message, 401);
  }
}

// å…¨å±€é”™è¯¯å¤„ç†
app.use((error, req, res, next) => {
  console.error(error);
  
  if (error instanceof ApiError) {
    return res.status(error.statusCode).json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
        details: error.details
      }
    });
  }
  
  // æœªçŸ¥é”™è¯¯
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: 'Internal server error'
    }
  });
});
```

## æ€»ç»“

APIè®¾è®¡æœ€ä½³å®è·µï¼š
- ğŸ¯ **RESTfulè®¾è®¡**ï¼šèµ„æºå‘½å + HTTPæ–¹æ³• + çŠ¶æ€ç 
- ğŸ” **è®¤è¯æˆæƒ**ï¼šJWT + æƒé™æ§åˆ¶
- ğŸš¦ **é™æµä¿æŠ¤**ï¼šä»¤ç‰Œæ¡¶ + Redisé™æµ
- ğŸ“ **æ–‡æ¡£ç”Ÿæˆ**ï¼šOpenAPI/Swagger
- ğŸ”„ **ç‰ˆæœ¬æ§åˆ¶**ï¼šURLç‰ˆæœ¬ + åºŸå¼ƒç­–ç•¥
- âš ï¸ **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€é”™è¯¯æ ¼å¼

è®°ä½ï¼š**å¥½çš„APIè®¾è®¡æ˜¯æ˜“ç”¨ã€ä¸€è‡´ã€å¯æ‰©å±•çš„ï¼**

