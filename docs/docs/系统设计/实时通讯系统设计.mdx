---
sidebar_position: 5
title: 实时通讯系统设计
tags: [系统设计, 实时通讯, WebSocket, 即时消息]
---

# 实时通讯系统设计

实时通讯系统是现代应用的核心功能，本文将详细讲解如何设计一个支持百万级在线用户的即时通讯系统。

## 需求分析

### 功能需求

```javascript
const requirements = {
  // 核心功能
  messaging: {
    oneToOne: true,        // 单聊
    group: true,           // 群聊
    typing: true,          // 输入状态
    readReceipt: true,     // 已读回执
    offline: true          // 离线消息
  },
  
  // 消息类型
  messageTypes: {
    text: true,            // 文本
    image: true,           // 图片
    video: true,           // 视频
    file: true,            // 文件
    voice: true,           // 语音
    location: true         // 位置
  },
  
  // 扩展功能
  extended: {
    presence: true,        // 在线状态
    notification: true,    // 推送通知
    search: true,          // 消息搜索
    sync: true            // 多端同步
  }
};
```

### 非功能需求

```python
# 容量估算
日活用户 = 100_000_000        # 1亿DAU
在线用户 = 日活用户 * 0.3      # 30%在线率
每用户日均消息 = 50

# 消息量计算
每日消息总量 = 日活用户 * 每用户日均消息
消息QPS = 每日消息总量 / 86400

print(f"在线用户: {在线用户:,}")
print(f"每日消息: {每日消息总量:,}")
print(f"消息QPS: {消息QPS:,.0f}")

# 存储估算
每条消息大小 = 1024           # 1KB
保存年限 = 3
总存储_TB = (每日消息总量 * 365 * 保存年限 * 每条消息大小) / (1024 ** 4)

print(f"存储需求: {总存储_TB:.2f} TB")

# 连接数
每台服务器连接数 = 10000
所需服务器 = 在线用户 / 每台服务器连接数

print(f"所需服务器: {所需服务器:,.0f}台")
```

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────┐
│              客户端层                    │
│  iOS App  │  Android  │  Web  │  PC     │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│           接入层（Gateway）              │
│  WebSocket Server Cluster               │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│           业务逻辑层                     │
│  消息服务 │ 用户服务 │ 群组服务          │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│           存储层                         │
│  Redis  │  MySQL  │  MongoDB  │  OSS    │
└─────────────────────────────────────────┘
```

### 技术选型

```javascript
const techStack = {
  // 实时通信协议
  protocol: {
    websocket: 'Socket.IO / ws',
    fallback: 'Long Polling',
    mobile: 'TCP长连接'
  },
  
  // 消息队列
  messageQueue: {
    kafka: '消息分发',
    redis: '在线消息',
    rabbitmq: '离线消息'
  },
  
  // 存储
  storage: {
    redis: '在线状态、会话',
    mongodb: '消息历史',
    mysql: '用户、群组',
    oss: '文件存储'
  }
};
```

## WebSocket服务器

### 连接管理

```javascript
class WebSocketServer {
  constructor() {
    this.connections = new Map(); // userId -> WebSocket
    this.userSessions = new Map(); // userId -> sessionInfo
  }
  
  async handleConnection(ws, userId) {
    // 1. 验证token
    const token = ws.handshake.auth.token;
    const user = await this.verifyToken(token);
    
    if (!user) {
      ws.close(4001, 'Unauthorized');
      return;
    }
    
    // 2. 保存连接
    this.connections.set(userId, ws);
    
    // 3. 更新在线状态
    await this.updatePresence(userId, 'online');
    
    // 4. 加载离线消息
    await this.loadOfflineMessages(userId, ws);
    
    // 5. 同步会话列表
    await this.syncConversations(userId, ws);
    
    // 6. 监听事件
    this.setupEventHandlers(ws, userId);
    
    console.log(`User ${userId} connected`);
  }
  
  setupEventHandlers(ws, userId) {
    // 发送消息
    ws.on('message', async (data) => {
      await this.handleMessage(userId, data);
    });
    
    // 输入状态
    ws.on('typing', async (data) => {
      await this.handleTyping(userId, data);
    });
    
    // 已读回执
    ws.on('read', async (data) => {
      await this.handleRead(userId, data);
    });
    
    // 断开连接
    ws.on('disconnect', async () => {
      await this.handleDisconnect(userId);
    });
    
    // 心跳
    ws.on('ping', () => {
      ws.pong();
    });
  }
  
  async handleDisconnect(userId) {
    // 1. 移除连接
    this.connections.delete(userId);
    
    // 2. 更新在线状态
    await this.updatePresence(userId, 'offline');
    
    console.log(`User ${userId} disconnected`);
  }
  
  // 发送消息给用户
  async sendToUser(userId, message) {
    const ws = this.connections.get(userId);
    
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
      return true;
    }
    
    // 用户离线，存储离线消息
    await this.storeOfflineMessage(userId, message);
    return false;
  }
}
```

### 消息处理

```javascript
class MessageHandler {
  async handleMessage(senderId, data) {
    const { receiverId, content, type, conversationId } = data;
    
    // 1. 验证消息
    if (!this.validateMessage(content, type)) {
      throw new Error('Invalid message');
    }
    
    // 2. 生成消息ID
    const messageId = this.generateMessageId();
    
    // 3. 构建消息对象
    const message = {
      id: messageId,
      conversationId,
      senderId,
      receiverId,
      content,
      type,
      timestamp: Date.now(),
      status: 'sent'
    };
    
    // 4. 存储消息
    await this.saveMessage(message);
    
    // 5. 发送给接收者
    const delivered = await wsServer.sendToUser(receiverId, {
      type: 'message',
      data: message
    });
    
    // 6. 更新消息状态
    if (delivered) {
      message.status = 'delivered';
      await this.updateMessageStatus(messageId, 'delivered');
    }
    
    // 7. 发送确认给发送者
    await wsServer.sendToUser(senderId, {
      type: 'ack',
      data: {
        messageId,
        status: message.status
      }
    });
    
    // 8. 更新会话
    await this.updateConversation(conversationId, message);
    
    // 9. 推送通知（如果离线）
    if (!delivered) {
      await this.sendPushNotification(receiverId, message);
    }
    
    return message;
  }
  
  generateMessageId() {
    // Snowflake ID
    return snowflake.generate();
  }
  
  async saveMessage(message) {
    // 存储到MongoDB
    await mongodb.collection('messages').insertOne(message);
    
    // 缓存最近消息到Redis
    await redis.zadd(
      `conversation:${message.conversationId}:messages`,
      message.timestamp,
      JSON.stringify(message)
    );
  }
  
  async updateConversation(conversationId, message) {
    await redis.hset(`conversation:${conversationId}`, {
      lastMessage: JSON.stringify(message),
      lastMessageTime: message.timestamp,
      unreadCount: await this.incrementUnreadCount(conversationId, message.receiverId)
    });
  }
}
```

## 群聊实现

### 群组管理

```javascript
class GroupManager {
  async createGroup(creatorId, members, groupName) {
    // 1. 创建群组
    const groupId = this.generateGroupId();
    
    const group = {
      id: groupId,
      name: groupName,
      creatorId,
      members: [creatorId, ...members],
      createdAt: Date.now()
    };
    
    await db.groups.insertOne(group);
    
    // 2. 创建会话
    for (const memberId of group.members) {
      await this.createConversation(memberId, groupId, 'group');
    }
    
    // 3. 发送系统消息
    await this.sendSystemMessage(groupId, `${creatorId} 创建了群聊`);
    
    return group;
  }
  
  async sendGroupMessage(senderId, groupId, content) {
    // 1. 验证成员资格
    const isMember = await this.isMember(senderId, groupId);
    if (!isMember) {
      throw new Error('Not a group member');
    }
    
    // 2. 获取群成员
    const members = await this.getGroupMembers(groupId);
    
    // 3. 生成消息
    const message = {
      id: this.generateMessageId(),
      groupId,
      senderId,
      content,
      timestamp: Date.now()
    };
    
    // 4. 存储消息
    await this.saveMessage(message);
    
    // 5. 分发给所有成员
    const deliveryPromises = members
      .filter(m => m !== senderId)
      .map(memberId => 
        wsServer.sendToUser(memberId, {
          type: 'group_message',
          data: message
        })
      );
    
    await Promise.all(deliveryPromises);
    
    return message;
  }
  
  async isMember(userId, groupId) {
    const group = await db.groups.findOne({ id: groupId });
    return group && group.members.includes(userId);
  }
}
```

## 在线状态

### Presence服务

```javascript
class PresenceService {
  async updatePresence(userId, status) {
    // 1. 更新Redis
    await redis.hset('user:presence', userId, JSON.stringify({
      status,
      lastSeen: Date.now()
    }));
    
    // 2. 设置过期时间
    await redis.expire(`user:presence:${userId}`, 300); // 5分钟
    
    // 3. 通知好友
    const friends = await this.getFriends(userId);
    
    for (const friendId of friends) {
      await wsServer.sendToUser(friendId, {
        type: 'presence',
        data: {
          userId,
          status,
          timestamp: Date.now()
        }
      });
    }
  }
  
  async getPresence(userId) {
    const data = await redis.hget('user:presence', userId);
    return data ? JSON.parse(data) : { status: 'offline' };
  }
  
  async batchGetPresence(userIds) {
    const pipeline = redis.pipeline();
    
    for (const userId of userIds) {
      pipeline.hget('user:presence', userId);
    }
    
    const results = await pipeline.exec();
    
    return userIds.reduce((acc, userId, index) => {
      const data = results[index][1];
      acc[userId] = data ? JSON.parse(data) : { status: 'offline' };
      return acc;
    }, {});
  }
}
```

### 心跳机制

```javascript
class HeartbeatManager {
  constructor() {
    this.heartbeatInterval = 30000; // 30秒
    this.heartbeatTimeout = 60000;  // 60秒超时
  }
  
  startHeartbeat(ws, userId) {
    // 客户端定时发送心跳
    const timer = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        clearInterval(timer);
      }
    }, this.heartbeatInterval);
    
    // 服务端检测心跳超时
    let lastHeartbeat = Date.now();
    
    ws.on('pong', () => {
      lastHeartbeat = Date.now();
    });
    
    const checkTimer = setInterval(() => {
      if (Date.now() - lastHeartbeat > this.heartbeatTimeout) {
        console.log(`User ${userId} heartbeat timeout`);
        ws.close();
        clearInterval(timer);
        clearInterval(checkTimer);
      }
    }, this.heartbeatInterval);
  }
}
```

## 消息同步

### 多端同步

```javascript
class SyncService {
  async syncMessages(userId, lastSyncTime) {
    // 1. 获取用户的所有会话
    const conversations = await this.getConversations(userId);
    
    // 2. 获取每个会话的新消息
    const syncData = await Promise.all(
      conversations.map(async (conv) => {
        const messages = await this.getNewMessages(
          conv.id,
          lastSyncTime
        );
        
        return {
          conversationId: conv.id,
          messages,
          unreadCount: await this.getUnreadCount(userId, conv.id)
        };
      })
    );
    
    return {
      conversations: syncData,
      syncTime: Date.now()
    };
  }
  
  async getNewMessages(conversationId, since) {
    // 从MongoDB查询
    return await mongodb.collection('messages').find({
      conversationId,
      timestamp: { $gt: since }
    }).sort({ timestamp: 1 }).toArray();
  }
}
```

### 离线消息

```javascript
class OfflineMessageManager {
  async storeOfflineMessage(userId, message) {
    // 1. 存储到Redis列表
    await redis.lpush(
      `offline:${userId}`,
      JSON.stringify(message)
    );
    
    // 2. 设置过期时间（7天）
    await redis.expire(`offline:${userId}`, 7 * 24 * 3600);
    
    // 3. 增加未读计数
    await redis.hincrby('unread_count', userId, 1);
  }
  
  async loadOfflineMessages(userId) {
    // 1. 获取所有离线消息
    const messages = await redis.lrange(`offline:${userId}`, 0, -1);
    
    // 2. 解析消息
    const parsedMessages = messages.map(msg => JSON.parse(msg));
    
    // 3. 清空离线消息
    await redis.del(`offline:${userId}`);
    
    // 4. 重置未读计数
    await redis.hdel('unread_count', userId);
    
    return parsedMessages;
  }
}
```

## 消息推送

### 推送服务

```javascript
class PushNotificationService {
  async sendPushNotification(userId, message) {
    // 1. 获取用户设备token
    const devices = await this.getUserDevices(userId);
    
    if (devices.length === 0) {
      return;
    }
    
    // 2. 构建推送内容
    const notification = {
      title: this.getSenderName(message.senderId),
      body: this.getMessagePreview(message),
      data: {
        messageId: message.id,
        conversationId: message.conversationId
      }
    };
    
    // 3. 发送推送
    const promises = devices.map(device => {
      switch (device.platform) {
        case 'ios':
          return this.sendAPNS(device.token, notification);
        case 'android':
          return this.sendFCM(device.token, notification);
        default:
          return Promise.resolve();
      }
    });
    
    await Promise.all(promises);
  }
  
  async sendAPNS(token, notification) {
    // Apple Push Notification Service
    const apn = require('apn');
    const provider = new apn.Provider({
      token: {
        key: process.env.APN_KEY,
        keyId: process.env.APN_KEY_ID,
        teamId: process.env.APN_TEAM_ID
      }
    });
    
    const note = new apn.Notification();
    note.alert = notification.body;
    note.payload = notification.data;
    note.badge = 1;
    note.sound = 'default';
    
    await provider.send(note, token);
  }
  
  async sendFCM(token, notification) {
    // Firebase Cloud Messaging
    const admin = require('firebase-admin');
    
    await admin.messaging().send({
      token,
      notification: {
        title: notification.title,
        body: notification.body
      },
      data: notification.data
    });
  }
}
```

## 性能优化

### 1. 连接负载均衡

```javascript
class ConnectionLoadBalancer {
  constructor() {
    this.servers = [
      { host: 'ws1.example.com', connections: 0 },
      { host: 'ws2.example.com', connections: 0 },
      { host: 'ws3.example.com', connections: 0 }
    ];
  }
  
  getServer() {
    // 选择连接数最少的服务器
    return this.servers.reduce((min, server) => 
      server.connections < min.connections ? server : min
    );
  }
  
  async assignServer(userId) {
    const server = this.getServer();
    
    // 记录用户所在服务器
    await redis.hset('user:server', userId, server.host);
    
    server.connections++;
    
    return server.host;
  }
}
```

### 2. 消息分片

```javascript
class MessageSharding {
  constructor(shardCount = 16) {
    this.shardCount = shardCount;
  }
  
  getShardKey(conversationId) {
    const hash = this.hashCode(conversationId);
    return hash % this.shardCount;
  }
  
  async saveMessage(message) {
    const shard = this.getShardKey(message.conversationId);
    const collection = `messages_${shard}`;
    
    await mongodb.collection(collection).insertOne(message);
  }
  
  async getMessages(conversationId, limit = 50) {
    const shard = this.getShardKey(conversationId);
    const collection = `messages_${shard}`;
    
    return await mongodb.collection(collection)
      .find({ conversationId })
      .sort({ timestamp: -1 })
      .limit(limit)
      .toArray();
  }
}
```

### 3. 消息压缩

```javascript
class MessageCompressor {
  compress(message) {
    const zlib = require('zlib');
    const json = JSON.stringify(message);
    return zlib.gzipSync(json).toString('base64');
  }
  
  decompress(compressed) {
    const zlib = require('zlib');
    const buffer = Buffer.from(compressed, 'base64');
    const json = zlib.gunzipSync(buffer).toString();
    return JSON.parse(json);
  }
}
```

## 安全性

### 1. 消息加密

```javascript
class MessageEncryption {
  encrypt(message, key) {
    const crypto = require('crypto');
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    
    let encrypted = cipher.update(JSON.stringify(message), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
      iv: iv.toString('hex'),
      data: encrypted
    };
  }
  
  decrypt(encrypted, key) {
    const crypto = require('crypto');
    const iv = Buffer.from(encrypted.iv, 'hex');
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    
    let decrypted = decipher.update(encrypted.data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}
```

### 2. 敏感词过滤

```javascript
class ContentFilter {
  constructor() {
    this.sensitiveWords = new Set([
      '敏感词1',
      '敏感词2'
    ]);
  }
  
  filter(content) {
    let filtered = content;
    
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      filtered = filtered.replace(regex, '*'.repeat(word.length));
    }
    
    return filtered;
  }
  
  containsSensitiveWord(content) {
    for (const word of this.sensitiveWords) {
      if (content.includes(word)) {
        return true;
      }
    }
    return false;
  }
}
```

## 监控告警

```javascript
class MonitoringSystem {
  async monitor() {
    // 1. 在线用户数
    const onlineUsers = await redis.hlen('user:presence');
    
    // 2. 消息QPS
    const messageQPS = await this.getMessageQPS();
    
    // 3. WebSocket连接数
    const connections = wsServer.connections.size;
    
    // 4. 消息延迟
    const latency = await this.getMessageLatency();
    
    // 5. 推送成功率
    const pushSuccessRate = await this.getPushSuccessRate();
    
    // 记录指标
    await this.recordMetrics({
      onlineUsers,
      messageQPS,
      connections,
      latency,
      pushSuccessRate
    });
    
    // 告警
    if (latency > 1000) {
      await this.alert('High message latency', { latency });
    }
  }
}
```

## 总结

实时通讯系统设计的核心：
- 🔌 **长连接管理**：WebSocket + 心跳机制
- 📨 **消息分发**：点对点 + 群聊 + 离线消息
- 🔄 **多端同步**：消息同步 + 状态同步
- 📱 **推送通知**：APNS + FCM
- 🚀 **性能优化**：负载均衡 + 消息分片 + 压缩
- 🔒 **安全防护**：消息加密 + 内容过滤
- 📊 **监控告警**：实时监控 + 及时告警

记住：**实时通讯的本质是高效的消息路由和可靠的消息传递！**

