---
sidebar_position: 1
title: Vue3
tags: [, Vue3, , Proxy, ]
---

# Vue3

Vue3ProxyVue3

## 

### Proxy vs Object.defineProperty

```javascript
// Vue2: Object.defineProperty
const vue2Reactive = (obj) => {
  Object.keys(obj).forEach(key => {
    let value = obj[key];
    Object.defineProperty(obj, key, {
      get() {
        console.log(` ${key}`);
        return value;
      },
      set(newValue) {
        console.log(` ${key} = ${newValue}`);
        value = newValue;
      }
    });
  });
  return obj;
};

// 
const vue2Limitations = {
  issues: [
    '',
    'length',
    '',
    ''
  ],
  
  examples: {
    addProperty: () => {
      const obj = vue2Reactive({ name: 'Vue' });
      obj.age = 3; // 
    },
    
    arrayIndex: () => {
      const arr = vue2Reactive([1, 2, 3]);
      arr[0] = 10; // 
    }
  }
};

// Vue3: Proxy
const vue3Reactive = (obj) => {
  return new Proxy(obj, {
    get(target, key, receiver) {
      console.log(` ${key}`);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      console.log(` ${key} = ${value}`);
      return Reflect.set(target, key, value, receiver);
    },
    deleteProperty(target, key) {
      console.log(` ${key}`);
      return Reflect.deleteProperty(target, key);
    }
  });
};

// 
const vue3Advantages = {
  benefits: [
    '',
    'length',
    '',
    ''
  ],
  
  examples: {
    addProperty: () => {
      const obj = vue3Reactive({ name: 'Vue' });
      obj.age = 3; //  
    },
    
    arrayIndex: () => {
      const arr = vue3Reactive([1, 2, 3]);
      arr[0] = 10; //  
    }
  }
};
```

## 

### reactive

```javascript
// 
const reactiveMap = new WeakMap();

// 
const isObject = (val) => val !== null && typeof val === 'object';

// reactive
function reactive(target) {
  // 
  if (!isObject(target)) {
    return target;
  }
  
  // 
  if (reactiveMap.has(target)) {
    return reactiveMap.get(target);
  }
  
  // 
  const proxy = new Proxy(target, {
    get(target, key, receiver) {
      // key
      if (key === '__v_isReactive') {
        return true;
      }
      
      // 
      track(target, key);
      
      const result = Reflect.get(target, key, receiver);
      
      // 
      if (isObject(result)) {
        return reactive(result);
      }
      
      return result;
    },
    
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      
      // 
      if (oldValue !== value) {
        trigger(target, key);
      }
      
      return result;
    },
    
    deleteProperty(target, key) {
      const hadKey = Object.prototype.hasOwnProperty.call(target, key);
      const result = Reflect.deleteProperty(target, key);
      
      if (hadKey && result) {
        trigger(target, key);
      }
      
      return result;
    }
  });
  
  // 
  reactiveMap.set(target, proxy);
  
  return proxy;
}

// 
const state = reactive({
  count: 0,
  user: {
    name: 'Vue',
    age: 3
  }
});

console.log(state.count); // get
state.count++; // set
```

### ref

```javascript
class RefImpl {
  constructor(value) {
    this._value = convert(value);
    this.__v_isRef = true;
  }
  
  get value() {
    // 
    track(this, 'value');
    return this._value;
  }
  
  set value(newValue) {
    if (newValue !== this._value) {
      this._value = convert(newValue);
      // 
      trigger(this, 'value');
    }
  }
}

// 
function convert(value) {
  return isObject(value) ? reactive(value) : value;
}

// ref
function ref(value) {
  return new RefImpl(value);
}

// 
const count = ref(0);
console.log(count.value); // 0
count.value++; // 

const user = ref({ name: 'Vue' });
console.log(user.value.name); // 'Vue'
user.value.name = 'React'; // 
```

## 

### effect

```javascript
// effect
let activeEffect = null;

// effect
const effectStack = [];

// target -> key -> effects
const targetMap = new WeakMap();

// effect
function effect(fn, options = {}) {
  const effectFn = () => {
    try {
      // 
      effectStack.push(effectFn);
      activeEffect = effectFn;
      
      // 
      return fn();
    } finally {
      // 
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
    }
  };
  
  // 
  effectFn.options = options;
  
  // 
  if (!options.lazy) {
    effectFn();
  }
  
  return effectFn;
}

// 
function track(target, key) {
  if (!activeEffect) {
    return;
  }
  
  // target
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  // key
  let deps = depsMap.get(key);
  if (!deps) {
    depsMap.set(key, (deps = new Set()));
  }
  
  // effect
  deps.add(activeEffect);
}

// 
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  
  const deps = depsMap.get(key);
  if (!deps) {
    return;
  }
  
  // effect
  deps.forEach(effect => {
    if (effect.options.scheduler) {
      effect.options.scheduler(effect);
    } else {
      effect();
    }
  });
}

// 
const state = reactive({ count: 0 });

effect(() => {
  console.log('count:', state.count);
});
// : count: 0

state.count++; // effect: count: 1
```

### computed

```javascript
function computed(getter) {
  let value;
  let dirty = true; // 
  
  const effectFn = effect(getter, {
    lazy: true,
    scheduler: () => {
      // 
      dirty = true;
      // computed
      trigger(computed, 'value');
    }
  });
  
  const computed = {
    get value() {
      if (dirty) {
        value = effectFn();
        dirty = false;
      }
      // computed
      track(computed, 'value');
      return value;
    }
  };
  
  return computed;
}

// 
const state = reactive({ count: 0 });

const double = computed(() => {
  console.log('double');
  return state.count * 2;
});

console.log(double.value); // double, : 0
console.log(double.value); // : 0

state.count++; // dirty
console.log(double.value); // double, : 2
```

### watch

```javascript
function watch(source, cb, options = {}) {
  let getter;
  
  // source
  if (typeof source === 'function') {
    getter = source;
  } else {
    getter = () => traverse(source);
  }
  
  let oldValue;
  let cleanup;
  
  // 
  const onCleanup = (fn) => {
    cleanup = fn;
  };
  
  const job = () => {
    // 
    if (cleanup) {
      cleanup();
    }
    
    const newValue = effectFn();
    cb(newValue, oldValue, onCleanup);
    oldValue = newValue;
  };
  
  const effectFn = effect(getter, {
    lazy: true,
    scheduler: () => {
      if (options.flush === 'post') {
        // DOM
        Promise.resolve().then(job);
      } else {
        job();
      }
    }
  });
  
  if (options.immediate) {
    job();
  } else {
    oldValue = effectFn();
  }
}

// 
function traverse(value, seen = new Set()) {
  if (!isObject(value) || seen.has(value)) {
    return value;
  }
  
  seen.add(value);
  
  for (const key in value) {
    traverse(value[key], seen);
  }
  
  return value;
}

// 
const state = reactive({ count: 0 });

watch(
  () => state.count,
  (newValue, oldValue) => {
    console.log(`count changed: ${oldValue} -> ${newValue}`);
  }
);

state.count++; // : count changed: 0 -> 1
```

## 

### 

```javascript
class Component {
  constructor(options) {
    this.$options = options;
    this.$data = reactive(options.data());
    this.$el = null;
    
    // effect
    this.update = effect(() => {
      this.render();
    }, {
      scheduler: () => {
        // 
        queueJob(this.update);
      }
    });
  }
  
  render() {
    const vnode = this.$options.render.call(this.$data);
    
    if (!this.$el) {
      // 
      this.$el = this.mount(vnode);
    } else {
      // 
      this.patch(this.$el, vnode);
    }
  }
  
  mount(vnode) {
    // DOM
    const el = document.createElement(vnode.tag);
    
    // 
    if (vnode.props) {
      for (const key in vnode.props) {
        el.setAttribute(key, vnode.props[key]);
      }
    }
    
    // 
    if (typeof vnode.children === 'string') {
      el.textContent = vnode.children;
    } else if (Array.isArray(vnode.children)) {
      vnode.children.forEach(child => {
        el.appendChild(this.mount(child));
      });
    }
    
    return el;
  }
  
  patch(el, vnode) {
    // diff
    // Vue3diff
    el.textContent = vnode.children;
  }
}

// 
const app = new Component({
  data() {
    return {
      count: 0
    };
  },
  render() {
    return {
      tag: 'div',
      children: `Count: ${this.count}`
    };
  }
});

document.body.appendChild(app.$el);

// 
app.$data.count++;
```

### 

```javascript
const queue = [];
let isFlushing = false;
let isFlushPending = false;

function queueJob(job) {
  if (!queue.includes(job)) {
    queue.push(job);
    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    Promise.resolve().then(flushJobs);
  }
}

function flushJobs() {
  isFlushPending = false;
  isFlushing = true;
  
  // 
  queue.sort((a, b) => a.id - b.id);
  
  try {
    for (let i = 0; i < queue.length; i++) {
      const job = queue[i];
      job();
    }
  } finally {
    queue.length = 0;
    isFlushing = false;
  }
}

// nextTick
function nextTick(fn) {
  return fn ? Promise.resolve().then(fn) : Promise.resolve();
}

// 
const state = reactive({ count: 0 });

effect(() => {
  console.log('effect:', state.count);
});

state.count++;
state.count++;
state.count++;

// effect
// : effect: 3

nextTick(() => {
  console.log('nextTick:', state.count);
});
```

## 

### shallowReactive

```javascript
function shallowReactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      track(target, key);
      return Reflect.get(target, key, receiver);
    },
    
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      trigger(target, key);
      return result;
    }
  });
}

// 
const state = shallowReactive({
  user: {
    name: 'Vue',
    profile: {
      age: 3
    }
  }
});

//  
state.user = { name: 'React' };

//  
state.user.name = 'Angular';
```

### readonly

```javascript
function readonly(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      track(target, key);
      const result = Reflect.get(target, key, receiver);
      return isObject(result) ? readonly(result) : result;
    },
    
    set() {
      console.warn('readonly');
      return true;
    },
    
    deleteProperty() {
      console.warn('readonly');
      return true;
    }
  });
}

// propsstore state
const props = readonly({ msg: 'Hello' });
props.msg = 'World'; // readonly
```

### markRaw

```javascript
const rawMap = new WeakMap();

function markRaw(value) {
  rawMap.set(value, true);
  return value;
}

function isRaw(value) {
  return rawMap.has(value);
}

// reactive
function reactive(target) {
  if (isRaw(target)) {
    return target;
  }
  // ... 
}

// 
const map = markRaw(new Map());
const state = reactive({ map });

// map
console.log(state.map === map); // true
```

## 

### Hook

```javascript
// useCounter
function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  
  const increment = () => count.value++;
  const decrement = () => count.value--;
  const reset = () => count.value = initialValue;
  
  return {
    count,
    increment,
    decrement,
    reset
  };
}

// useMouse
function useMouse() {
  const x = ref(0);
  const y = ref(0);
  
  const update = (e) => {
    x.value = e.pageX;
    y.value = e.pageY;
  };
  
  onMounted(() => {
    window.addEventListener('mousemove', update);
  });
  
  onUnmounted(() => {
    window.removeEventListener('mousemove', update);
  });
  
  return { x, y };
}

// useLocalStorage
function useLocalStorage(key, initialValue) {
  const data = ref(initialValue);
  
  // localStorage
  const stored = localStorage.getItem(key);
  if (stored) {
    data.value = JSON.parse(stored);
  }
  
  // localStorage
  watch(data, (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });
  
  return data;
}
```

## 

Vue3
-  **Proxy**
-  ****tracktrigger
-  **effect**
-  **computed**
-  **watch**
-  ****

**Vue3**

