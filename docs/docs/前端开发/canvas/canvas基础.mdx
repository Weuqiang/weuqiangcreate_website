# Canvas 
``` js
const canvas = document.querySelector('canvas');
const context = canvas.getContext('2d');
```

## Canvas API

### toBlob

``` js
canvas.toBlob(blob => {
  const url = URL.createObjectURL(blob);
}, "image/jpeg", 1) // quality
```

### toDataURL

``` js
const dataUrl = canvas.toDataURL("image/jpeg", 1); // quality
```

### captureStream
CanvasVideo
``` js
const stream = canvas.captureStream();

//  
video.srcObject = stream;

// 
const recorder = new MediaRecorder(stream);
```



## 2D Context API

### 

- `fillRect(x, y, width, height)`
- `strokeRect(x, y, width, height)`
- `clearRect(x, y, width, height)`

``` js
ctx.fillRect(0, 0, 100, 100)
ctx.strokeRect(20, 20, 40, 40)

ctx.clearRect(0, 0, canvas.width, canvas.height) // 
```





### 



``` js
// case1 
ctx.beginPath()

ctx.moveTo(0, 0)
ctx.lineTo(100, 0)
ctx.lineTo(0, 100)

ctx.stroke()
ctx.closePath()

// case2 
ctx.beginPath()

ctx.arc(100, 100, 10, 0, Math.PI) // 

ctx.fill()
ctx.closePath()
```



### 

``` js
ctx.font = '24px'
ctx.fillText("hello akara", 100, 100) // 
ctx.strokeText("hello akara", 100, 100) // 
```



### 

Canvas`context`

- `fillStyle`
- `strokeStyle`
- `globalAlpha`
- `lineWidth`
- `lineCap`
- `lineJoin`
- `font`
- `shadowOffsetX``shadowOffsetY``shadowBlur``shadowColor`

`setLineDash([4, 2])`pattern



### 

Canvas

- `ctx.translate(x, y)`xy
- `ctx.rotate(angle)``ctx.rotate(Math.PI)`
- `ctx.scale(x, y)`
- `ctx.transform(a, b, c, d, e, f)`



`(x1, y1)``(x2, y2)`` *  *  * vec3(x1, y1, 0) ``transform * vec3(x1, y1, 0)`





### `save``restore`

Canvas2D

``` js
ctx.save()

ctx.tranlate(100, 100)
ctx.rotate(Math.PI / 2) // 
ctx.tranlate(-100, -100) // 

ctx.fillStyle = 'pink'
ctx.fillRect(0, 0, 100, 100)

ctx.restore()
```



### drawImage

Canvas`drawImage`CanvasImageVideoCanvasImageBitMapWebCodecsvideoFrame

``` js
ctx.drawImage(image, 0, 0)
ctx.drawImage(video, 0, 0)
ctx.drawImage(canvas2, 0, 0)
ctx.drawImage(videoFrame, 0, 0)
```

`drawImage``d`Canvas Destination`s`Source

1. `drawImage(source, dx, dy)``(dx, dy)`

2. `drawImage(source, dx, dy, dWidth, dHeight)``width``height`

3. `drawImage(source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)`

   ![](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage/canvas_drawimage.jpg)



:::info
`drawImage`M2 Macbook ProCPU615000*15000
> [Demo](https://github.com/Messiahhh/canvas-perf-demo)

1. `drawImage(Image)`JSAPI3
2. `drawImage(Canvas)`JSAPI****
3. `drawImage(OffscreenCanvas)`JSAPI3`drawImage(image)`OffscreenCanvasOffscreenCanvasCanvasCanvasOffscreenCanvas
4. `drawImage(ImageBitmap)`JSAPI2****

23drawImageCanvas/OffscreenCanvasCanvasCanvasCanvasready
`1. JS drawImage(image) -> 2.  Canvas -> 3. JS drawImage(canvas) -> 4.  CanvasCanvas`
34————Canvas/drawImage(canvas)

JS`drawImage(image)``drawImage(canvas)`
`1. JS drawImage(image) -> 2. JS drawImage(canvas) -> 3. `3 OffscreenCanvas2`drawImage(canvas)`
3
:::

### getImageData/putImageData

`getImageData`CanvasKonvaCPU

``` js
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

for (let i = 0; i < imageData.data.length; i += 4) {
  	imageData.data[i] = 255; // red channel
    imageData.data[i + 1] = 0; // green channel
    imageData.data[i + 2] = 255; // blue channel
    imageData.data[i + 3] = 200; // alpha channel
}
ctx.putImageData(imageData, 0, 0)
```

:::caution
`getImageData``putImageData`CPU`drawImage`
:::

:::info GPU/CPU Canvas
CanvasGPU`getImageData``putImageData`GPUCPUCanvas`willReadFrequently`CanvasCPUGPU

``` js
const ctx = canvas.getContext('2d', {
  willReadFrequently: true
})
```

> **willReadFrequently**
> 
> A boolean value that indicates whether or not a lot of read-back operations are planned. This will force the use of a software (instead of hardware accelerated) 2D canvas and can save memory when calling getImageData() frequently.
:::



### 

Canvas`globalCompositeOperation`



### ClipMask

`fill()``stroke()``clip()`****Mask

``` js
ctx.save()
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2)
ctx.clip();
ctx.fillStyle = 'pink'
ctx.fillRect(0, 0, 100, 100)
ctx.restore() // clip

ctx.fillStyle = 'skyblue'
ctx.fillRect(100, 100, 100, 100)
```





#### 

Canvas****

Canvas`fill`API****`clip`********`fill``clip`API**nonzero****evenodd**/



**nonzero**

Canvas****`fill``clip`



**evenodd**





`clip`""

``` js
const ctx = canvas.getContext('2d');
ctx.save()
ctx.beginPath();

ctx.rect(0, 0, 200, 200) // 
ctx.arc(100, 100, 50, 0, Math.PI * 2, true) // true
ctx.clip();
ctx.fillStyle = 'pink'
ctx.fillRect(0, 0, 100, 100)
ctx.restore() // clip

ctx.fillStyle = 'skyblue'
ctx.fillRect(100, 100, 100, 100)
```



### requestAnimationFrame

Canvas

1. 
2. 
3. 
4. 



`setInterval``setTimeout``requestAnimationFrame``setInterval``setTimeout``rAF`

1. `rAF``setTimeout`
2. `rAF``setTimeout`



## OffscreenCanvas

JSJSJSJSJS
6016.6JS

**JS**`setTimeout``Promise.then`JS

**JS**Web Worker
Web WorkerJSWeb WorkerCanvasWeb WorkerDOMWeb WorkerDOMCanvas————OffscreenCanvas

OffscreenCanvasCanvasWeb WorkerWeb Worker`transferControlToOffscreen`Web Worker

:::info 
Web WorkerWeb WorkerWeb WorkerGPU
:::

### transferControlToOffscreen
JSCanvas`transferControlToOffscreen`OffscreenCanvas

CanvasOffscreenCanvasCanvasOffscreenCanvasWeb WorkerWeb WokerOffscreenCanvasJSCanvas

``` js title="main.js"
const canvas = document.createElement('canvas')
canvas.width = 5000
canvas.height = 5000
document.body.appendChild(canvas)

const offscreenCanvas = canvas.transferControlToOffscreen()
const worker = new Worker('./worker.js')
worker.postMessage({ canvas: offscreenCanvas }, [offscreenCanvas])
```


``` js title="worker.js"
let canvas = null;
self.onmessage = function(evt) {
    if (evt.data.canvas) {
        canvas = evt.data.canvas;
        draw()
    }
}

function draw() {
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'pink'
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        requestAnimationFrame(draw)
    }
}
```

### transferToImageBitmap
Web WorkerOffscreenCanvasJSCanvas`getImageData`OffscreenCanvasJSWorkerOffscreenCanvas`transferToImageBitmap`

`getImageData`GPUCPU`transferToImageBitmap`GPUGPUOffscreenCanvasGPU`getImageData`OffscreenCanvas


## ImageBitmap

### createImageBitMap
``` js
const image = new Image();
image.src = '';
image.onload = function() {
  createImageBitmap(image).then(bitMap => {
    ctx.drawImage(bitMap, 0, 0);
  })
}
```

