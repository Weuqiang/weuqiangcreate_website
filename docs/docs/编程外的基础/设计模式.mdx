---
sidebarDepth: 4
---
# 设计模式

设计模式是软件开发中常见问题的可复用解决方案，能提高代码的可维护性和可扩展性。

## 创建型模式

### 单例模式

确保一个类只有一个实例，并提供全局访问点。

**应用场景**：数据库连接池、全局配置对象、日志记录器

```javascript
// 方式一：闭包实现
const Singleton = (function() {
  let instance;
  
  function createInstance() {
    return {
      name: 'Singleton',
      getData() {
        return 'data';
      }
    };
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2);  // true

// 方式二：ES6 类实现
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    this.name = 'Singleton';
    Singleton.instance = this;
  }
  
  getData() {
    return 'data';
  }
}

// 实际应用：全局状态管理
class Store {
  constructor() {
    if (Store.instance) {
      return Store.instance;
    }
    this.state = {};
    Store.instance = this;
  }
  
  getState(key) {
    return this.state[key];
  }
  
  setState(key, value) {
    this.state[key] = value;
  }
}

const store1 = new Store();
const store2 = new Store();
store1.setState('user', 'zhangsan');
console.log(store2.getState('user'));  // 'zhangsan'
```



### 发布-订阅模式

```javascript
// Node中的EventEmitter 就是用的发布订阅模式
class EventEmitter {
      constructor() {
          this.list = {}
      }

      on(name, fn, type = 1) {
          if (!this.list[name]) {
              this.list[name] = []
          }
          this.list[name].push([fn, type])

      }

      once(name, fn, type = 0) {
          this.on(name, fn, type)
      }

      emit(name, ...args) {
          let fns = this.list[name]
          if (!fns || fns.length === 0) return
          fns.forEach((fn, index) => {
              fn[0].apply(this, args)
              if (fn[1] === 0) {
                  fns.splice(index, 1)
              }
          })
      }

      remove(name, func) {
          let fns = this.list[name]
          if (!fns) {
              this.list[name] = []
          }
          fns.forEach((fn, index) => {
              if (fn[0] === func) {
                  fns.splice(index, 1)
              }
          })
      }
  }

let bus = new EventEmitter()

bus.on("click", (value) => {
	console.log(value)
})

bus.emit("click", 111)
```

### 观察者模式

```javascript
class Publisher {
      constructor() {
          this.list = []
      }

      addListener(listener) {
          this.list.push(listener)
      }

      removeListener(listener) {
          this.list.forEach((item, index) => {
              if (listener === item) {
                  this.list.splice(index, 1)
              }
          })
      }

      notify(obj) {
          this.list.forEach((item) => {
              item.process(obj)
          })
      }
  }

class Subscriber {
    process(obj) {
        console.log(obj.name)
    }
}
```

### MVC

MVC (Model-View-Controller) 分为三部分

- Model（数据模型）：数据
- View（视图）：用户界面
- Controller（控制器）：业务逻辑

通信过程如下，所有通信都是单向的。

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

![过程](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png)

### MVVM

MVVM（Model-View-ViewModel）也分为三部分，数据模型，视图，视图模型。

与MVC的区别之一在于View和Model之间要借助ViewModel进行通信。

![通信过程](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png)

### 工厂模式

提供创建对象的接口，隐藏创建逻辑。

**应用场景**：创建复杂对象、根据条件创建不同类型的对象

```javascript
// 简单工厂
class CarFactory {
  static createCar(type) {
    switch (type) {
      case 'BMW':
        return new BMW();
      case 'Audi':
        return new Audi();
      case 'Mercedes':
        return new Mercedes();
      default:
        throw new Error('Unknown car type');
    }
  }
}

class BMW {
  constructor() {
    this.brand = 'BMW';
    this.type = 'Luxury';
  }
  
  drive() {
    console.log('Driving a BMW');
  }
}

class Audi {
  constructor() {
    this.brand = 'Audi';
    this.type = 'Luxury';
  }
  
  drive() {
    console.log('Driving an Audi');
  }
}

// 使用
const bmw = CarFactory.createCar('BMW');
bmw.drive();

// 实际应用：创建不同类型的用户
class UserFactory {
  static createUser(role) {
    switch (role) {
      case 'admin':
        return new Admin();
      case 'user':
        return new User();
      case 'guest':
        return new Guest();
      default:
        throw new Error('Invalid role');
    }
  }
}

class Admin {
  constructor() {
    this.role = 'admin';
    this.permissions = ['read', 'write', 'delete'];
  }
}

class User {
  constructor() {
    this.role = 'user';
    this.permissions = ['read', 'write'];
  }
}

class Guest {
  constructor() {
    this.role = 'guest';
    this.permissions = ['read'];
  }
}
```

## 结构型模式

### 装饰器模式

动态地给对象添加新功能，不改变其结构。

**应用场景**：给函数添加日志、性能监控、权限验证

```javascript
// 基础咖啡
class Coffee {
  cost() {
    return 5;
  }
  
  description() {
    return 'Simple coffee';
  }
}

// 牛奶装饰器
class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 2;
  }
  
  description() {
    return this.coffee.description() + ', milk';
  }
}

// 糖装饰器
class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 1;
  }
  
  description() {
    return this.coffee.description() + ', sugar';
  }
}

// 使用
let coffee = new Coffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
console.log(coffee.description());  // Simple coffee, milk, sugar
console.log(coffee.cost());         // 8

// 实际应用：函数装饰器
function log(target, name, descriptor) {
  const original = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`Calling ${name} with`, args);
    const result = original.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
  return descriptor;
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
}

// 不使用装饰器语法的实现
function withLogging(fn) {
  return function(...args) {
    console.log(`Calling function with`, args);
    const result = fn.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
}

const add = (a, b) => a + b;
const addWithLogging = withLogging(add);
addWithLogging(2, 3);  // 输出日志和结果
```

### 策略模式

策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。

```javascript
// 策略类
class DiscountStrategy {
    calculate(amount) {
        throw new Error('calculate method must be implemented');
    }
}

class RegularCustomer extends DiscountStrategy {
    calculate(amount) {
        return amount;
    }
}

class PremiumCustomer extends DiscountStrategy {
    calculate(amount) {
        return amount * 0.9; // 10% 折扣
    }
}

class VIPCustomer extends DiscountStrategy {
    calculate(amount) {
        return amount * 0.8; // 20% 折扣
    }
}

// 上下文类
class ShoppingCart {
    constructor(discountStrategy) {
        this.discountStrategy = discountStrategy;
        this.amount = 0;
    }
    
    setDiscountStrategy(discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
    
    addItem(price) {
        this.amount += price;
    }
    
    calculateTotal() {
        return this.discountStrategy.calculate(this.amount);
    }
}

// 使用
const cart = new ShoppingCart(new RegularCustomer());
cart.addItem(100);
cart.addItem(50);
console.log(cart.calculateTotal()); // 150

cart.setDiscountStrategy(new VIPCustomer());
console.log(cart.calculateTotal()); // 120
```

### 代理模式

为对象提供代理，控制对该对象的访问。

**应用场景**：懒加载、缓存、权限控制、日志记录

```javascript
// 图片懒加载代理
class RealImage {
  constructor(filename) {
    this.filename = filename;
    this.loadFromDisk();
  }
  
  loadFromDisk() {
    console.log(`Loading ${this.filename} from disk...`);
  }
  
  display() {
    console.log(`Displaying ${this.filename}`);
  }
}

class ProxyImage {
  constructor(filename) {
    this.filename = filename;
    this.realImage = null;
  }
  
  display() {
    if (!this.realImage) {
      this.realImage = new RealImage(this.filename);
    }
    this.realImage.display();
  }
}

// 使用
const image = new ProxyImage('photo.jpg');
image.display();  // 第一次调用时加载
image.display();  // 第二次直接显示，不重新加载

// 实际应用：缓存代理
function createCacheProxy(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('从缓存获取');
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

function expensiveCalculation(n) {
  console.log('执行复杂计算...');
  return n * n;
}

const cachedCalculation = createCacheProxy(expensiveCalculation);
console.log(cachedCalculation(5));  // 执行计算
console.log(cachedCalculation(5));  // 从缓存获取

// ES6 Proxy 实现
const handler = {
  get(target, property) {
    console.log(`Getting ${property}`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`Setting ${property} to ${value}`);
    target[property] = value;
    return true;
  }
};

const obj = { name: 'zhangsan' };
const proxy = new Proxy(obj, handler);
console.log(proxy.name);  // Getting name
proxy.age = 25;           // Setting age to 25
```

### 适配器模式

将一个接口转换成客户期望的另一个接口。

**应用场景**：整合第三方库、兼容旧代码

```javascript
// 旧接口
class OldPrinter {
  oldPrint(text) {
    console.log(`Old printer: ${text}`);
  }
}

// 新接口
class NewPrinter {
  print(text) {
    console.log(`New printer: ${text}`);
  }
}

// 适配器
class PrinterAdapter {
  constructor(oldPrinter) {
    this.oldPrinter = oldPrinter;
  }
  
  print(text) {
    this.oldPrinter.oldPrint(text);
  }
}

// 使用
const oldPrinter = new OldPrinter();
const adapter = new PrinterAdapter(oldPrinter);
adapter.print('Hello World');  // Old printer: Hello World

// 实际应用：适配不同的数据格式
class XMLDataAdapter {
  constructor(xmlData) {
    this.xmlData = xmlData;
  }
  
  toJSON() {
    // 将 XML 转换为 JSON
    return JSON.parse(this.xmlData);
  }
}

class JSONDataAdapter {
  constructor(jsonData) {
    this.jsonData = jsonData;
  }
  
  toJSON() {
    return this.jsonData;
  }
}
```

## 行为型模式

### 观察者模式

定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知。

**应用场景**：事件系统、数据绑定、消息队列

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }
  
  addObserver(observer) {
    this.observers.push(observer);
  }
  
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// 使用
const subject = new Subject();
const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');

subject.addObserver(observer1);
subject.addObserver(observer2);
subject.notify('Hello');  // 两个观察者都收到通知

// 实际应用：股票价格监控
class Stock {
  constructor(symbol, price) {
    this.symbol = symbol;
    this.price = price;
    this.investors = [];
  }
  
  attach(investor) {
    this.investors.push(investor);
  }
  
  setPrice(price) {
    this.price = price;
    this.notifyInvestors();
  }
  
  notifyInvestors() {
    this.investors.forEach(investor => {
      investor.update(this);
    });
  }
}

class Investor {
  constructor(name) {
    this.name = name;
  }
  
  update(stock) {
    console.log(`${this.name}: ${stock.symbol} price changed to ${stock.price}`);
  }
}

const stock = new Stock('AAPL', 150);
const investor1 = new Investor('张三');
const investor2 = new Investor('李四');

stock.attach(investor1);
stock.attach(investor2);
stock.setPrice(155);  // 通知所有投资者
```

### 发布-订阅模式

发布者和订阅者通过事件中心解耦，发布者发布事件，订阅者订阅感兴趣的事件。

**应用场景**：事件总线、消息队列、组件通信

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  }

  once(eventName, callback) {
    const wrapper = (...args) => {
      callback.apply(this, args);
      this.off(eventName, wrapper);
    };
    this.on(eventName, wrapper);
  }

  emit(eventName, ...args) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      callbacks.forEach(callback => callback.apply(this, args));
    }
  }

  off(eventName, callback) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      this.events[eventName] = callbacks.filter(cb => cb !== callback);
    }
  }
}

// 使用
const bus = new EventEmitter();

bus.on('click', (value) => {
  console.log('Clicked:', value);
});

bus.emit('click', 111);  // Clicked: 111

// 实际应用：组件通信
class ComponentA {
  constructor(eventBus) {
    this.eventBus = eventBus;
  }
  
  sendMessage(msg) {
    this.eventBus.emit('message', msg);
  }
}

class ComponentB {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.eventBus.on('message', this.handleMessage.bind(this));
  }
  
  handleMessage(msg) {
    console.log('ComponentB received:', msg);
  }
}

const eventBus = new EventEmitter();
const compA = new ComponentA(eventBus);
const compB = new ComponentB(eventBus);
compA.sendMessage('Hello from A');
```

### 策略模式

定义一系列算法，将每个算法封装起来，使它们可以互相替换。

**应用场景**：表单验证、支付方式选择、排序算法选择

```javascript
// 策略类
class DiscountStrategy {
  calculate(amount) {
    throw new Error('calculate method must be implemented');
  }
}

class RegularCustomer extends DiscountStrategy {
  calculate(amount) {
    return amount;
  }
}

class PremiumCustomer extends DiscountStrategy {
  calculate(amount) {
    return amount * 0.9;  // 10% 折扣
  }
}

class VIPCustomer extends DiscountStrategy {
  calculate(amount) {
    return amount * 0.8;  // 20% 折扣
  }
}

// 上下文类
class ShoppingCart {
  constructor(discountStrategy) {
    this.discountStrategy = discountStrategy;
    this.amount = 0;
  }
  
  setDiscountStrategy(discountStrategy) {
    this.discountStrategy = discountStrategy;
  }
  
  addItem(price) {
    this.amount += price;
  }
  
  calculateTotal() {
    return this.discountStrategy.calculate(this.amount);
  }
}

// 使用
const cart = new ShoppingCart(new RegularCustomer());
cart.addItem(100);
cart.addItem(50);
console.log(cart.calculateTotal());  // 150

cart.setDiscountStrategy(new VIPCustomer());
console.log(cart.calculateTotal());  // 120

// 实际应用：表单验证
const validators = {
  required: (value) => value !== '' && value !== null && value !== undefined,
  email: (value) => /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(value),
  minLength: (min) => (value) => value.length >= min,
  maxLength: (max) => (value) => value.length <= max
};

class FormValidator {
  constructor() {
    this.rules = {};
  }
  
  addRule(field, validator, message) {
    if (!this.rules[field]) {
      this.rules[field] = [];
    }
    this.rules[field].push({ validator, message });
  }
  
  validate(data) {
    const errors = {};
    
    for (const field in this.rules) {
      for (const rule of this.rules[field]) {
        if (!rule.validator(data[field])) {
          if (!errors[field]) {
            errors[field] = [];
          }
          errors[field].push(rule.message);
        }
      }
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }
}

const validator = new FormValidator();
validator.addRule('username', validators.required, '用户名不能为空');
validator.addRule('username', validators.minLength(3), '用户名至少3个字符');
validator.addRule('email', validators.required, '邮箱不能为空');
validator.addRule('email', validators.email, '邮箱格式不正确');

const result = validator.validate({
  username: 'ab',
  email: 'invalid-email'
});
console.log(result);
```

### 命令模式

将请求封装成对象，从而使您可以用不同的请求对客户进行参数化。

**应用场景**：撤销/重做功能、宏命令、任务队列

```javascript
// 接收者
class Light {
  turnOn() {
    console.log('Light is ON');
  }
  
  turnOff() {
    console.log('Light is OFF');
  }
}

// 命令接口
class Command {
  execute() {
    throw new Error('execute method must be implemented');
  }
  
  undo() {
    throw new Error('undo method must be implemented');
  }
}

// 具体命令
class TurnOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class TurnOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

// 调用者
class RemoteControl {
  constructor() {
    this.command = null;
    this.history = [];
  }
  
  setCommand(command) {
    this.command = command;
  }
  
  pressButton() {
    if (this.command) {
      this.command.execute();
      this.history.push(this.command);
    }
  }
  
  pressUndo() {
    if (this.history.length > 0) {
      const lastCommand = this.history.pop();
      lastCommand.undo();
    }
  }
}

// 使用
const light = new Light();
const turnOnCommand = new TurnOnCommand(light);
const turnOffCommand = new TurnOffCommand(light);
const remote = new RemoteControl();

remote.setCommand(turnOnCommand);
remote.pressButton();  // Light is ON
remote.pressUndo();    // Light is OFF

remote.setCommand(turnOffCommand);
remote.pressButton();  // Light is OFF
remote.pressUndo();    // Light is ON
```

## 架构模式

### MVC

MVC (Model-View-Controller) 将应用分为三部分：

- **Model（数据模型）**：管理数据和业务逻辑
- **View（视图）**：展示数据给用户
- **Controller（控制器）**：处理用户输入，更新 Model 和 View

```javascript
// Model
class TodoModel {
  constructor() {
    this.todos = [];
  }
  
  addTodo(text) {
    this.todos.push({ id: Date.now(), text, completed: false });
  }
  
  removeTodo(id) {
    this.todos = this.todos.filter(todo => todo.id !== id);
  }
  
  toggleTodo(id) {
    const todo = this.todos.find(todo => todo.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }
  }
  
  getTodos() {
    return this.todos;
  }
}

// View
class TodoView {
  constructor() {
    this.app = document.getElementById('app');
  }
  
  render(todos) {
    this.app.innerHTML = todos.map(todo => `
      <div>
        <input type="checkbox" ${todo.completed ? 'checked' : ''} data-id="${todo.id}">
        <span>${todo.text}</span>
        <button data-id="${todo.id}">删除</button>
      </div>
    `).join('');
  }
  
  bindAddTodo(handler) {
    document.getElementById('add-btn').addEventListener('click', () => {
      const input = document.getElementById('todo-input');
      handler(input.value);
      input.value = '';
    });
  }
  
  bindToggleTodo(handler) {
    this.app.addEventListener('change', (e) => {
      if (e.target.type === 'checkbox') {
        handler(Number(e.target.dataset.id));
      }
    });
  }
  
  bindRemoveTodo(handler) {
    this.app.addEventListener('click', (e) => {
      if (e.target.tagName === 'BUTTON') {
        handler(Number(e.target.dataset.id));
      }
    });
  }
}

// Controller
class TodoController {
  constructor(model, view) {
    this.model = model;
    this.view = view;
    
    this.view.bindAddTodo(this.handleAddTodo.bind(this));
    this.view.bindToggleTodo(this.handleToggleTodo.bind(this));
    this.view.bindRemoveTodo(this.handleRemoveTodo.bind(this));
    
    this.updateView();
  }
  
  handleAddTodo(text) {
    this.model.addTodo(text);
    this.updateView();
  }
  
  handleToggleTodo(id) {
    this.model.toggleTodo(id);
    this.updateView();
  }
  
  handleRemoveTodo(id) {
    this.model.removeTodo(id);
    this.updateView();
  }
  
  updateView() {
    this.view.render(this.model.getTodos());
  }
}

// 使用
const app = new TodoController(new TodoModel(), new TodoView());
```

### MVVM

MVVM (Model-View-ViewModel) 通过数据绑定实现 View 和 Model 的自动同步。

**特点**：
- View 和 Model 通过 ViewModel 通信
- 双向数据绑定
- Vue、React 等框架采用此模式

```javascript
// 简化的 MVVM 实现
class ViewModel {
  constructor(data) {
    this._data = data;
    this._observers = {};
    this.makeReactive(data);
  }
  
  makeReactive(obj) {
    Object.keys(obj).forEach(key => {
      let value = obj[key];
      const self = this;
      
      Object.defineProperty(obj, key, {
        get() {
          return value;
        },
        set(newValue) {
          if (value !== newValue) {
            value = newValue;
            self.notify(key, newValue);
          }
        }
      });
    });
  }
  
  watch(key, callback) {
    if (!this._observers[key]) {
      this._observers[key] = [];
    }
    this._observers[key].push(callback);
  }
  
  notify(key, value) {
    if (this._observers[key]) {
      this._observers[key].forEach(callback => callback(value));
    }
  }
}

// 使用
const vm = new ViewModel({ name: 'zhangsan', age: 25 });

vm.watch('name', (newValue) => {
  console.log('Name changed to:', newValue);
});

vm._data.name = 'lisi';  // Name changed to: lisi
```

## 设计原则

1. **单一职责原则（SRP）**：一个类只负责一个功能
2. **开放封闭原则（OCP）**：对扩展开放，对修改封闭
3. **里氏替换原则（LSP）**：子类可以替换父类
4. **接口隔离原则（ISP）**：使用多个专门的接口，而不是单一的总接口
5. **依赖倒置原则（DIP）**：依赖抽象而不是具体实现

## 何时使用设计模式

- **单例模式**：需要全局唯一实例时
- **工厂模式**：创建对象逻辑复杂时
- **观察者模式**：一对多依赖关系时
- **策略模式**：需要动态切换算法时
- **装饰器模式**：需要动态添加功能时
- **代理模式**：需要控制对象访问时
