---
sidebar_position: 10
title: 
tags: [, , MySQL, ]
---

# 



## 

### 

```sql
-- 1NF
--  1NF
CREATE TABLE users_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    phones VARCHAR(200)  -- 
);

--  1NF
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE user_phones (
    id INT PRIMARY KEY,
    user_id INT,
    phone VARCHAR(20),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 2NF
--  2NF
CREATE TABLE order_items_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100),  -- product_id
    product_price DECIMAL(10,2), -- product_id
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);

--  2NF
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2)
);

CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 3NF
--  3NF
CREATE TABLE employees_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    department_name VARCHAR(100),  -- department_id
    department_location VARCHAR(100) -- department_id
);

--  3NF
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location VARCHAR(100)
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);
```

### 

```sql
-- 

-- 
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    user_name VARCHAR(100),        -- 
    total_amount DECIMAL(10,2),    -- 
    item_count INT,                -- 
    created_at TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- 
DELIMITER $$
CREATE TRIGGER update_order_summary
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT SUM(price * quantity)
        FROM order_items
        WHERE order_id = NEW.order_id
    ),
    item_count = (
        SELECT COUNT(*)
        FROM order_items
        WHERE order_id = NEW.order_id
    )
    WHERE id = NEW.order_id;
END$$
DELIMITER ;
```

## 

### 

```sql
-- 1. 
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    name VARCHAR(100)
);

-- 2. 
CREATE UNIQUE INDEX idx_email ON users(email);

-- 3. 
CREATE INDEX idx_name ON users(name);

-- 4. 
CREATE INDEX idx_name_email ON users(name, email);

-- 5. 
CREATE TABLE articles (
    id BIGINT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT INDEX idx_content (title, content)
);

-- 
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('' IN NATURAL LANGUAGE MODE);

-- 6. 
CREATE INDEX idx_email_prefix ON users(email(10));

-- 7. 
CREATE INDEX idx_covering ON users(name, email, created_at);

-- 
SELECT name, email, created_at
FROM users
WHERE name = 'John';
```

### 

```sql
-- 
CREATE INDEX idx_abc ON table_name(a, b, c);

--  
SELECT * FROM table_name WHERE a = 1;
SELECT * FROM table_name WHERE a = 1 AND b = 2;
SELECT * FROM table_name WHERE a = 1 AND b = 2 AND c = 3;

--  
SELECT * FROM table_name WHERE b = 2;
SELECT * FROM table_name WHERE c = 3;
SELECT * FROM table_name WHERE b = 2 AND c = 3;

-- 
--  =  / 
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS selectivity
FROM table_name;

-- 
-- 2
-- 

-- 
--  
SELECT * FROM users WHERE YEAR(created_at) = 2024;

--  
SELECT * FROM users 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';

--  
SELECT * FROM users WHERE phone = 12345678;  -- phoneVARCHAR

--  
SELECT * FROM users WHERE phone = '12345678';

--  OR
SELECT * FROM users WHERE name = 'John' OR email = 'john@example.com';

--  UNION
SELECT * FROM users WHERE name = 'John'
UNION
SELECT * FROM users WHERE email = 'john@example.com';
```

## 

```sql
-- 
CREATE TABLE orders (
    id BIGINT,
    user_id BIGINT,
    amount DECIMAL(10,2),
    created_at TIMESTAMP
)
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 
CREATE TABLE users (
    id BIGINT,
    name VARCHAR(100),
    country VARCHAR(50)
)
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_asia VALUES IN ('CN', 'JP', 'KR'),
    PARTITION p_europe VALUES IN ('UK', 'FR', 'DE'),
    PARTITION p_america VALUES IN ('US', 'CA', 'MX')
);

-- 
CREATE TABLE logs (
    id BIGINT,
    user_id BIGINT,
    action VARCHAR(50),
    created_at TIMESTAMP
)
PARTITION BY HASH(user_id)
PARTITIONS 10;

-- 
-- 
ALTER TABLE orders ADD PARTITION (
    PARTITION p2025 VALUES LESS THAN (2026)
);

-- 
ALTER TABLE orders DROP PARTITION p2022;

-- 
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'orders';
```

## 

### EXPLAIN

```sql
-- 
EXPLAIN SELECT * FROM users WHERE name = 'John';

-- 
/*
id: 
select_type: SIMPLE, PRIMARY, SUBQUERY
table: 
type: ALL, index, range, ref, eq_ref, const
  - ALL: 
  - index: 
  - range: 
  - ref: 
  - eq_ref: 
  - const: 
possible_keys: 
key: 
rows: 
Extra: 
  - Using index: 
  - Using where: WHERE
  - Using filesort: 
  - Using temporary: 
*/

-- 
--  
EXPLAIN SELECT * FROM orders WHERE amount > 100;
-- type: ALL, rows: 1000000

--  
CREATE INDEX idx_amount ON orders(amount);
EXPLAIN SELECT * FROM orders WHERE amount > 100;
-- type: range, rows: 50000
```

### 

```sql
-- 
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 1

-- 
SELECT * FROM mysql.slow_log
ORDER BY start_time DESC
LIMIT 10;

-- 

-- 1. SELECT *
-- 
SELECT * FROM users WHERE id = 1;

-- 
SELECT id, name, email FROM users WHERE id = 1;

-- 2. LIMIT
-- 
SELECT * FROM orders ORDER BY created_at DESC;

-- 
SELECT * FROM orders ORDER BY created_at DESC LIMIT 100;

-- 3. 
-- 
SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE amount > 1000);

-- 
SELECT DISTINCT u.* FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.amount > 1000;

-- 4. JOIN
-- 
SELECT * FROM users WHERE id = 1;
SELECT * FROM orders WHERE user_id = 1;

-- 
SELECT u.*, o.*
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.id = 1;

-- 5. 
-- 
INSERT INTO users (name) VALUES ('User1');
INSERT INTO users (name) VALUES ('User2');
INSERT INTO users (name) VALUES ('User3');

-- 
INSERT INTO users (name) VALUES 
('User1'), ('User2'), ('User3');
```

## 

```sql
-- 
-- READ UNCOMMITTED: 
-- READ COMMITTED: 
-- REPEATABLE READ: MySQL
-- SERIALIZABLE: 

-- 
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 
START TRANSACTION;

-- FOR UPDATE
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;

-- 
UPDATE accounts 
SET balance = balance - 100, version = version + 1
WHERE id = 1 AND version = 10;

-- 
IF ROW_COUNT() = 0 THEN
    -- 
END IF;

-- 
SHOW ENGINE INNODB STATUS;

-- 
-- 1. 
-- 2. 
-- 3. 
-- 4. 
```

## 

```javascript
// 
class ShardingStrategy {
  constructor(dbCount = 4, tableCount = 16) {
    this.dbCount = dbCount;
    this.tableCount = tableCount;
  }
  
  // ID
  getShardInfo(userId) {
    const dbIndex = userId % this.dbCount;
    const tableIndex = userId % this.tableCount;
    
    return {
      database: `db_${dbIndex}`,
      table: `users_${tableIndex}`
    };
  }
  
  // 
  async rangeQuery(startId, endId) {
    const results = [];
    
    for (let db = 0; db < this.dbCount; db++) {
      for (let table = 0; table < this.tableCount; table++) {
        const sql = `
          SELECT * FROM db_${db}.users_${table}
          WHERE id BETWEEN ${startId} AND ${endId}
        `;
        
        const rows = await this.query(sql);
        results.push(...rows);
      }
    }
    
    return results;
  }
}

// 
const sharding = new ShardingStrategy(4, 16);

// 
const userId = 12345;
const { database, table } = sharding.getShardInfo(userId);
const sql = `INSERT INTO ${database}.${table} (id, name) VALUES (?, ?)`;
await db.query(sql, [userId, 'John']);

// 
const { database: db, table: tbl } = sharding.getShardInfo(userId);
const sql2 = `SELECT * FROM ${db}.${tbl} WHERE id = ?`;
const user = await db.query(sql2, [userId]);
```

## 

```javascript
class MasterSlaveRouter {
  constructor(masterConfig, slaveConfigs) {
    this.master = createConnection(masterConfig);
    this.slaves = slaveConfigs.map(config => createConnection(config));
    this.currentSlaveIndex = 0;
  }
  
  // 
  async write(sql, params) {
    return await this.master.query(sql, params);
  }
  
  // 
  async read(sql, params) {
    const slave = this.getNextSlave();
    return await slave.query(sql, params);
  }
  
  getNextSlave() {
    const slave = this.slaves[this.currentSlaveIndex];
    this.currentSlaveIndex = (this.currentSlaveIndex + 1) % this.slaves.length;
    return slave;
  }
  
  // 
  async transaction(callback) {
    const connection = await this.master.getConnection();
    
    try {
      await connection.beginTransaction();
      await callback(connection);
      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}

// 
const router = new MasterSlaveRouter(
  { host: 'master.db', port: 3306 },
  [
    { host: 'slave1.db', port: 3306 },
    { host: 'slave2.db', port: 3306 }
  ]
);

// 
await router.write('INSERT INTO users (name) VALUES (?)', ['John']);

// 
const users = await router.read('SELECT * FROM users WHERE id = ?', [1]);

// 
await router.transaction(async (conn) => {
  await conn.query('UPDATE accounts SET balance = balance - 100 WHERE id = 1');
  await conn.query('UPDATE accounts SET balance = balance + 100 WHERE id = 2');
});
```

## 

```sql
-- 
SELECT 
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY size_mb DESC;

-- 
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'your_database';

-- 
SELECT 
    s.TABLE_NAME,
    s.INDEX_NAME
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN INFORMATION_SCHEMA.INDEX_STATISTICS i
    ON s.TABLE_SCHEMA = i.TABLE_SCHEMA
    AND s.TABLE_NAME = i.TABLE_NAME
    AND s.INDEX_NAME = i.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND i.INDEX_NAME IS NULL;

-- 
OPTIMIZE TABLE users;

-- 
ANALYZE TABLE users;

-- 
CHECK TABLE users;

-- 
REPAIR TABLE users;
```

## 


-  **** + 
-  **** + 
-  ****EXPLAIN + 
-  **** + 
-  **** + 
-  **** + 

****

