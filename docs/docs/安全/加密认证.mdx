---
sidebar_position: 2
title: 
---

# 



## 

### AES

```javascript
const crypto = require('crypto');

// 
function encrypt(text, key) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key), iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  return {
    iv: iv.toString('hex'),
    data: encrypted
  };
}

// 
function decrypt(encrypted, key) {
  const iv = Buffer.from(encrypted.iv, 'hex');
  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(key), iv);
  
  let decrypted = decipher.update(encrypted.data, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

// 
const key = crypto.randomBytes(32);  // 256
const encrypted = encrypt('Hello World', key);
const decrypted = decrypt(encrypted, key);
```

### RSA

```javascript
const crypto = require('crypto');

// 
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem'
  }
});

// 
function encryptWithPublicKey(text, publicKey) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(text)
  ).toString('base64');
}

// 
function decryptWithPrivateKey(encrypted, privateKey) {
  return crypto.privateDecrypt(
    {
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(encrypted, 'base64')
  ).toString('utf8');
}

// 
const encrypted = encryptWithPublicKey('Secret Message', publicKey);
const decrypted = decryptWithPrivateKey(encrypted, privateKey);
```

### 

```javascript
const crypto = require('crypto');
const bcrypt = require('bcrypt');

// SHA-256
function sha256(text) {
  return crypto.createHash('sha256').update(text).digest('hex');
}

// HMAC
function hmac(text, secret) {
  return crypto.createHmac('sha256', secret).update(text).digest('hex');
}

// bcrypt
async function hashPassword(password) {
  const saltRounds = 10;
  return await bcrypt.hash(password, saltRounds);
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}

// Argon2
const argon2 = require('argon2');

async function hashPasswordArgon2(password) {
  return await argon2.hash(password, {
    type: argon2.argon2id,
    memoryCost: 2 ** 16,
    timeCost: 3,
    parallelism: 1
  });
}

async function verifyPasswordArgon2(password, hash) {
  return await argon2.verify(hash, password);
}
```

## 

```javascript
// 
function sign(data, privateKey) {
  const sign = crypto.createSign('SHA256');
  sign.update(data);
  return sign.sign(privateKey, 'base64');
}

// 
function verify(data, signature, publicKey) {
  const verify = crypto.createVerify('SHA256');
  verify.update(data);
  return verify.verify(publicKey, signature, 'base64');
}

// 
const data = 'Important message';
const signature = sign(data, privateKey);
const isValid = verify(data, signature, publicKey);
```

## JWT

### 

```javascript
const jwt = require('jsonwebtoken');
const redis = require('redis');

const redisClient = redis.createClient();

class AuthService {
  // 
  generateAccessToken(user) {
    return jwt.sign(
      { 
        id: user.id,
        username: user.username,
        role: user.role
      },
      process.env.JWT_ACCESS_SECRET,
      { expiresIn: '15m' }
    );
  }
  
  // 
  generateRefreshToken(user) {
    const token = jwt.sign(
      { id: user.id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    // Redis
    redisClient.setex(
      `refresh_token:${user.id}`,
      7 * 24 * 60 * 60,
      token
    );
    
    return token;
  }
  
  // 
  verifyAccessToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_ACCESS_SECRET);
    } catch (error) {
      throw new Error('Invalid access token');
    }
  }
  
  // 
  async refreshAccessToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
      
      // Redis
      const storedToken = await redisClient.get(`refresh_token:${decoded.id}`);
      if (storedToken !== refreshToken) {
        throw new Error('Invalid refresh token');
      }
      
      // 
      const user = await User.findById(decoded.id);
      
      // 
      return this.generateAccessToken(user);
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }
  
  // 
  async logout(userId) {
    await redisClient.del(`refresh_token:${userId}`);
  }
}

// 
function authenticate(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const authService = new AuthService();
    req.user = authService.verifyAccessToken(token);
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}
```

## OAuth 2.0

### 

```javascript
const express = require('express');
const axios = require('axios');

const app = express();

// 1. 
app.get('/auth/github', (req, res) => {
  const authUrl = 'https://github.com/login/oauth/authorize';
  const params = new URLSearchParams({
    client_id: process.env.GITHUB_CLIENT_ID,
    redirect_uri: 'http://localhost:3000/auth/github/callback',
    scope: 'user:email'
  });
  
  res.redirect(`${authUrl}?${params}`);
});

// 2. 
app.get('/auth/github/callback', async (req, res) => {
  const { code } = req.query;
  
  try {
    // 3. 
    const tokenResponse = await axios.post(
      'https://github.com/login/oauth/access_token',
      {
        client_id: process.env.GITHUB_CLIENT_ID,
        client_secret: process.env.GITHUB_CLIENT_SECRET,
        code: code
      },
      {
        headers: { Accept: 'application/json' }
      }
    );
    
    const accessToken = tokenResponse.data.access_token;
    
    // 4. 
    const userResponse = await axios.get('https://api.github.com/user', {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    
    const user = userResponse.data;
    
    // 5. 
    req.session.user = user;
    
    res.redirect('/dashboard');
  } catch (error) {
    res.status(500).json({ error: 'Authentication failed' });
  }
});
```

## SSO

### CAS

```javascript
class CASClient {
  constructor(casServerUrl, serviceUrl) {
    this.casServerUrl = casServerUrl;
    this.serviceUrl = serviceUrl;
  }
  
  // URL
  getLoginUrl() {
    return `${this.casServerUrl}/login?service=${encodeURIComponent(this.serviceUrl)}`;
  }
  
  // 
  async validateTicket(ticket) {
    const validateUrl = `${this.casServerUrl}/serviceValidate`;
    const params = new URLSearchParams({
      service: this.serviceUrl,
      ticket: ticket
    });
    
    const response = await axios.get(`${validateUrl}?${params}`);
    
    // XML
    const user = this.parseValidationResponse(response.data);
    return user;
  }
  
  // 
  getLogoutUrl() {
    return `${this.casServerUrl}/logout?service=${encodeURIComponent(this.serviceUrl)}`;
  }
}

// 
app.get('/login', (req, res) => {
  const cas = new CASClient(
    'https://cas.example.com',
    'http://myapp.com'
  );
  res.redirect(cas.getLoginUrl());
});

app.get('/auth/callback', async (req, res) => {
  const { ticket } = req.query;
  const cas = new CASClient(
    'https://cas.example.com',
    'http://myapp.com'
  );
  
  try {
    const user = await cas.validateTicket(ticket);
    req.session.user = user;
    res.redirect('/dashboard');
  } catch (error) {
    res.status(401).json({ error: 'Authentication failed' });
  }
});
```

## MFA

### TOTP

```javascript
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');

// 
function generateSecret(username) {
  return speakeasy.generateSecret({
    name: `MyApp (${username})`,
    length: 32
  });
}

// 
async function generateQRCode(secret) {
  return await QRCode.toDataURL(secret.otpauth_url);
}

// TOTP
function verifyTOTP(token, secret) {
  return speakeasy.totp.verify({
    secret: secret,
    encoding: 'base32',
    token: token,
    window: 2  // 2
  });
}

// 
app.post('/api/mfa/setup', authenticate, async (req, res) => {
  const secret = generateSecret(req.user.username);
  const qrCode = await generateQRCode(secret);
  
  // secret
  await User.update(req.user.id, {
    mfa_secret: secret.base32
  });
  
  res.json({ qrCode });
});

app.post('/api/mfa/verify', authenticate, async (req, res) => {
  const { token } = req.body;
  const user = await User.findById(req.user.id);
  
  const isValid = verifyTOTP(token, user.mfa_secret);
  
  if (isValid) {
    req.session.mfaVerified = true;
    res.json({ success: true });
  } else {
    res.status(401).json({ error: 'Invalid token' });
  }
});
```

## 

1. ****AES-256RSA-2048
2. ****
3. ****
4. ****
5. **HTTPS**HTTPS
6. ****
7. ****

## 


-  
-  
-  JWT
-  OAuth 2.0
-  SSO
-  

