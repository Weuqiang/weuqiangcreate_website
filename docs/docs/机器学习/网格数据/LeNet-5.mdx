---
sidebar_position: 1
title: LeNet-5
---

LeNet-5CNNCNN

## 


(convolutional neural network)CNN

3x35x57x7over padding



6x6

$$
\mathbf{A} = \begin{bmatrix}
a_{11} & a_{12} & a_{13} & a_{14} & a_{15} & a_{16} \\
a_{21} & a_{22} & a_{23} & a_{24} & a_{25} & a_{26} \\
a_{31} & a_{32} & a_{33} & a_{34} & a_{35} & a_{36} \\
a_{41} & a_{42} & a_{43} & a_{44} & a_{45} & a_{46} \\
a_{51} & a_{52} & a_{53} & a_{54} & a_{55} & a_{56} \\
a_{61} & a_{62} & a_{63} & a_{64} & a_{65} & a_{66} \\
\end{bmatrix}
$$



3x3

$$
\mathbf{K} = \begin{bmatrix}
k_{11} & k_{12} & k_{13} \\
k_{21} & k_{22} & k_{23} \\
k_{31} & k_{32} & k_{33} \\
\end{bmatrix}
$$




$$
\begin{bmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33} \\
\end{bmatrix}
$$

$O_{11}$

$$
\begin{aligned}
O_{11} &= k_{11} \cdot a_{11} + k_{12} \cdot a_{12} + k_{13} \cdot a_{13} \\ 
&\quad + k_{21} \cdot a_{21} + k_{22} \cdot a_{22} + k_{23} \cdot a_{23} \\ 
&\quad + k_{31} \cdot a_{31} + k_{32} \cdot a_{32} + k_{33} \cdot a_{33}
\end{aligned}
$$



6x6()4x4

<details>
<summary></summary>
``` jsx live
// 
function example(props) {
  //  XPath 
  const xpathSelector =
    "/html/body/div/div[2]/div/div/main/div/div/div/div/article/div[2]/div[1]/div[4]";
  const myElement = document.evaluate(
    xpathSelector,
    document,
    null,
    XPathResult.FIRST_ORDERED_NODE_TYPE,
    null
  ).singleNodeValue;
  // 
  const matrixSize = 6;
  // 
  const kernelSize = 3;
  const matrix = Array.from({ length: matrixSize }, (_, i) =>
    Array.from({ length: matrixSize }, (_, j) => `a${i + 1}${j + 1}`)
  );
  const [position, setPosition] = useState([0, 0]);
  useEffect(() => {
    const positions = [];
    for (let i = 0; i <= matrixSize - kernelSize; i++) {
      for (let j = 0; j <= matrixSize - kernelSize; j++) {
        positions.push([i, j]);
      }
    }

    let index = 0;
    const interval = setInterval(() => {
      setPosition(positions[index]);
      index = (index + 1) % positions.length;
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', backgroundColor: '#f0f0f0' }}>
      <div style={{ display: 'grid', gridTemplateColumns: `repeat(${matrixSize}, 50px)`, gridGap: '5px', position: 'relative' }}>
        {matrix.map((row, i) =>
          row.map((cell, j) => (
            <div
              key={`${i}-${j}`}
              style={{
                width: '50px',
                height: '50px',
                backgroundColor: '#fff',
                border: '1px solid #ccc',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                fontSize: '18px',
                backgroundColor: i >= position[0] && i < position[0] + kernelSize && j >= position[1] && j < position[1] + kernelSize ? 'yellow' : '#fff'
              }}
            >
              {cell}
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```
</details>


$\mathbf{O}$

$$
\mathbf{O} = \begin{bmatrix}
O_{11} & O_{12} & O_{13} & O_{14} \\
O_{21} & O_{22} & O_{23} & O_{24} \\
O_{31} & O_{32} & O_{33} & O_{34} \\
O_{41} & O_{42} & O_{43} & O_{44} \\
\end{bmatrix}
$$

$O_{ij}$



### 


1. ****
   $$
   \begin{bmatrix}
   -1 & -1 & -1 \\
   0 & 0 & 0 \\
   1 & 1 & 1
   \end{bmatrix}
   $$
   

2. ****
   $$
   \begin{bmatrix}
   -1 & 0 & 1 \\
   -1 & 0 & 1 \\
   -1 & 0 & 1
   \end{bmatrix}
   $$
   

3. **Sobel**
   $$
   \begin{bmatrix}
   -1 & 0 & 1 \\
   -2 & 0 & 2 \\
   -1 & 0 & 1
   \end{bmatrix}
   $$
   

4. **Sobel**
   $$
   \begin{bmatrix}
   1 & 2 & 1 \\
   0 & 0 & 0 \\
   -1 & -2 & -1
   \end{bmatrix}
   $$
   

5. ****
   $$
   \begin{bmatrix}
   0 & 1 & 0 \\
   1 & -4 & 1 \\
   0 & 1 & 0
   \end{bmatrix}
   $$
   

6. ****
   $$
   \begin{bmatrix}
   0 & -1 & 0 \\
   -1 & 5 & -1 \\
   0 & -1 & 0
   \end{bmatrix}
   $$
   

7. **3x3**
   $$
   \frac{1}{16}
   \begin{bmatrix}
   1 & 2 & 1 \\
   2 & 4 & 2 \\
   1 & 2 & 1
   \end{bmatrix}
   $$
   

8. **5x5**
   $$
   \frac{1}{256}
   \begin{bmatrix}
   1 & 4 & 6 & 4 & 1 \\
   4 & 16 & 24 & 16 & 4 \\
   6 & 24 & 36 & 24 & 6 \\
   4 & 16 & 24 & 16 & 4 \\
   1 & 4 & 6 & 4 & 1
   \end{bmatrix}
   $$
   

9. ****
   $$
   \begin{bmatrix}
   -1 & -1 & -1 \\
   -1 & 9 & -1 \\
   -1 & -1 & -1
   \end{bmatrix}
   $$
   

10. ****
    $$
    \frac{1}{9}
    \begin{bmatrix}
    1 & 1 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1
    \end{bmatrix}
    $$
    

```python showLineNumbers
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
import cv2

# 
# (windows)
font_path = r'C:\Windows\Fonts\simhei.ttf'  
# mac
# font_path = '/System/Library/Fonts/STHeiti Light.ttc' 
font_prop = FontProperties(fname=font_path)

# 
image = np.array(cv2.imread('data/people.bmp',cv2.IMREAD_GRAYSCALE))

# 
kernels = {
    '': np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]]),
    '': np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]]),
    'Sobel': np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]),
    'Sobel': np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]),
    '': np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),
    '': np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]]),
    '3x3': np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) / 16,
    '5x5': np.array([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]]) / 256,
    '': np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]),
    '': np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) / 9
}

# NumPy
def convolve2d(image, kernel):
    # 
    i_height, i_width = image.shape
    k_height, k_width = kernel.shape
    
    # 
    o_height = i_height - k_height + 1
    o_width = i_width - k_width + 1
    
    # 
    output = np.zeros((o_height, o_width))
    
    # 
    for y in range(o_height):
        for x in range(o_width):
            # 
            region = image[y:y+k_height, x:x+k_width]
            # 
            output[y, x] = np.sum(region * kernel)
    
    return output

# 
results = {}
for name, kernel in kernels.items():
    # 
    if kernel.shape[0] == 5:  # 5x5
        pad_width = 2
    else:  # 3x3
        pad_width = 1
    
    padded_image = np.pad(image, pad_width, mode='constant')
    filtered_image = convolve2d(padded_image, kernel)
    
    # 
    filtered_image = np.clip(filtered_image, 0, 255).astype(np.uint8)
    results[name] = filtered_image

# 
plt.figure(figsize=(15, 8))
for i, (name, result) in enumerate(results.items()):
    plt.subplot(3, 4, i + 1)
    plt.imshow(result, cmap='gray')
    plt.title(name, fontproperties=font_prop)
    plt.axis('off')

plt.tight_layout()
plt.show()

```

## 


PoolingCNN

2x23x34x4Padding
****Max Pooling****Average Pooling
```python showLineNumbers
import numpy as np

def pooling(input_array, pool_size=(2, 2), stride=None, mode='max'):
    """
    
    
    :
        input_array: [height, width][batch, height, width, channels]
        pool_size: (2, 2)
        stride: pool_size
        mode: 'max''avg'
        
    :
        
    """
    # stridepool_size
    if stride is None:
        stride = pool_size
    
    # numpy
    input_array = np.asarray(input_array)
    
    # 
    if input_array.ndim == 2:  # 2D
        h, w = input_array.shape
        d = 1
        input_array = input_array.reshape(1, h, w, 1)
    elif input_array.ndim == 3:  # 3D
        raise ValueError("2D4D")
    elif input_array.ndim == 4:  # 4D [batch, height, width, channels]
        pass
    else:
        raise ValueError("2D4D")
    
    # 
    batch_size, height, width, channels = input_array.shape
    
    # 
    out_height = (height - pool_size[0]) // stride[0] + 1
    out_width = (width - pool_size[1]) // stride[1] + 1
    
    # 
    output = np.zeros((batch_size, out_height, out_width, channels))
    
    # 
    for b in range(batch_size):
        for c in range(channels):
            for i in range(out_height):
                for j in range(out_width):
                    h_start = i * stride[0]
                    h_end = h_start + pool_size[0]
                    w_start = j * stride[1]
                    w_end = w_start + pool_size[1]
                    
                    pool_region = input_array[b, h_start:h_end, w_start:w_end, c]
                    
                    if mode == 'max':
                        output[b, i, j, c] = np.max(pool_region)
                    elif mode == 'avg':
                        output[b, i, j, c] = np.mean(pool_region)
                    else:
                        raise ValueError("'max''avg'")
    
    # 2D2D
    if input_array.shape[0] == 1 and input_array.shape[3] == 1:
        return output[0, :, :, 0]
    
    return output

# 
if __name__ == "__main__":
    # 
    test_data = np.array([
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12],
        [13, 14, 15, 16]
    ])
    
    # 
    max_pooled = pooling(test_data, pool_size=(2, 2), mode='max')
    print(":")
    print(max_pooled)
    
    # 
    avg_pooled = pooling(test_data, pool_size=(2, 2), mode='avg')
    print(":")
    print(avg_pooled)
'''
:
[[ 6.  8.]
 [14. 16.]]
:
[[ 3.5  5.5]
 [11.5 13.5]]
'''
```

- over padding()
  


```python
import numpy as np
import matplotlib.pyplot as plt

# 
inputs = np.array([
  [255,1,2],
  [255,1,2],
  [255,1,2],]

)
# 
kernel = np.array([
  [0,1,0],
  [0,1,0],
  [0,1,0]]
)

# 
'''
[[0.   2.   0.]
 [0.   2.   0.]
 [0.   2.   0.]]
'''


# 
# array: 
# pad_width: ()
# mode: 'constant',
# 011
# constant_values: 0
inputs = np.pad(
    array=inputs,
    pad_width=1,
    mode='constant',
    constant_values=0
)


# 
out_put = np.zeros((inputs.shape[0] - kernel.shape[0] + 1, inputs.shape[1] - kernel.shape[1] + 1))
out_put_w = out_put.shape[0]
out_put_h = out_put.shape[1]

for i in range(out_put_w):
    for j in range(out_put_h):
        conv_result = np.sum(inputs[i:i+kernel.shape[0], j:j+kernel.shape[1]] * kernel)
        out_put[i][j] = conv_result

# ,
print(out_put)
'''
[[510.   2.   4.]
 [765.   3.   6.]
 [510.   2.   4.]]
'''
```


## 


:::tip
Receptive Fieldfeature map
:::

```python showLineNumbers
import numpy as np

def convolution_2d(input_array, kernel, stride=3):
    """
    2D
    
    :
        input_array:  (height, width)
        kernel:  (kernel_size, kernel_size)
        stride: 3
        
    :
        
    """
    # 
    input_height, input_width = input_array.shape
    kernel_size = kernel.shape[0]
    
    # 
    output_height = (input_height - kernel_size) // stride + 1
    output_width = (input_width - kernel_size) // stride + 1
    
    # 
    output = np.zeros((output_height, output_width))
    
    # 
    for i in range(output_height):
        for j in range(output_width):
            # 
            start_i = i * stride
            start_j = j * stride
            
            # 
            window = input_array[start_i:start_i+kernel_size, start_j:start_j+kernel_size]
            
            # 
            output[i, j] = np.sum(window * kernel)
    
    return output

# 
if __name__ == "__main__":
    # 10x10
    input_array = np.ones((8, 8))
    #  0-7 0-7
    
    # 5x5
    kernel = np.ones((5, 5))
    
    # 3
    #  0-4 0-4
    #  3-7 3-7
    result = convolution_2d(input_array, kernel, stride=3)
    
    print(":", input_array.shape)
    print(":", kernel.shape)
    print(":", result.shape)
    print("\n:")
    print(input_array)
    print("\n:")
    print(kernel)
    print("\n:")
    print(result)
'''
: (10, 10)
: (5, 5)
: (2, 2)

:
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]

:
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]

:
[[25. 25.]
 [25. 25.]]
'''
```


## 


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="torch" label="pytorch" default>
    pytorch

```python showLineNumbers
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
import numpy as np

#  & 
digits = load_digits()
X = digits.images.astype(np.float32) / 16.0  # 0~1
y = digits.target
X = X[..., np.newaxis]  #  (n,8,8,1)
num_classes = 10

# /
X_train, X_val, y_train, y_val = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# PyTorchNCHW
X_train = torch.tensor(X_train).permute(0, 3, 1, 2)  # NHWC -> NCHW
X_val = torch.tensor(X_val).permute(0, 3, 1, 2)
y_train = torch.tensor(y_train, dtype=torch.long)
y_val = torch.tensor(y_val, dtype=torch.long)


# 
class SimpleConvNet(nn.Module):
    def __init__(self):
        super(SimpleConvNet, self).__init__()
        self.conv = nn.Conv2d(1, 8, kernel_size=3, padding=1)  # 18
        self.relu = nn.ReLU()
        self.pool = nn.MaxPool2d(kernel_size=2)  # 2x2
        self.fc = nn.Linear(4 * 4 * 8, num_classes)  # 

    def forward(self, x):
        x = self.conv(x)  # 
        x = self.relu(x)  # ReLU
        x = self.pool(x)  # 
        x = x.reshape(x.shape[0], -1)
        x = self.fc(x)  # 
        return x


# 
model = SimpleConvNet()
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.1)

# 
epochs = 10
batch_size = 64

# 
for epoch in range(epochs):
    # 
    indices = torch.randperm(len(X_train))

    model.train()  # 
    total_loss = 0

    # 
    for i in range(0, len(X_train), batch_size):
        # 
        batch_indices = indices[i : i + batch_size]
        x_batch = X_train[batch_indices]
        y_batch = y_train[batch_indices]

        # 
        outputs = model(x_batch)
        loss = criterion(outputs, y_batch)
        total_loss += loss.item()

        # 
        optimizer.zero_grad()  # 
        loss.backward()  # 
        optimizer.step()  # 

    # 
    model.eval()  # 
    with torch.no_grad():  # 
        outputs = model(X_val)
        _, predicted = torch.max(outputs, 1)  # 
        accuracy = (predicted == y_val).float().mean()

    print(
        f"Epoch {epoch+1}/{epochs}  loss={total_loss/len(indices)*batch_size:.4f}  val_acc={accuracy:.4f}"
    )
'''
Epoch 1/10  loss=2.2956  val_acc=0.4472
Epoch 2/10  loss=2.0604  val_acc=0.6167
Epoch 3/10  loss=1.5787  val_acc=0.7861
Epoch 4/10  loss=1.0126  val_acc=0.8000
Epoch 5/10  loss=0.6914  val_acc=0.7972
Epoch 6/10  loss=0.5458  val_acc=0.7917
Epoch 7/10  loss=0.4080  val_acc=0.8417
Epoch 8/10  loss=0.3853  val_acc=0.8778
Epoch 9/10  loss=0.3235  val_acc=0.9111
Epoch 10/10  loss=0.2700  val_acc=0.9250
'''
```
  </TabItem>
  <TabItem value="numpy" label="numpy">
    numpy

```python showLineNumbers
import numpy as np
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split


# 
def conv2d_forward(x, w, b):
    # x: (N,H,W,C)
    # w: (Kh,Kw,C,Cout)
    # b: Cout
    N, H, W, C = x.shape  # 
    Kh, Kw, _, Cout = w.shape  # 
    padding = 1  # padding=1
    Ho = (H + 2 * padding - Kh) + 1  # 
    Wo = (W + 2 * padding - Kw) + 1  # 
    # 
    x_pad = np.pad(
        x, [(0, 0), (padding, padding), (padding, padding), (0, 0)], "constant"
    )
    # 
    y = np.zeros((N, Ho, Wo, Cout), dtype=x.dtype)

    # 
    for n in range(N):  # 
        for i in range(Ho):  # 
            for j in range(Wo):  # 
                # 
                patch = x_pad[n, i : i + Kh, j : j + Kw, :]
                for cout in range(Cout):  # 
                    # 
                    y[n, i, j, cout] = np.sum(patch * w[:, :, :, cout]) + b[cout]

    cache = (x, w, b, x_pad)  # 
    return y, cache


# 
def conv2d_backward(dy, cache):
    # dy: 
    # cache: 
    x, w, b, x_pad = cache  # 
    N, H, W, C = x.shape  # 
    Kh, Kw, _, Cout = w.shape  # 
    _, Ho, Wo, _ = dy.shape  # 
    padding = 1  # padding=1

    # 
    dx_pad = np.zeros_like(x_pad)  # 
    dw = np.zeros_like(w)  # 
    db = np.zeros_like(b)  # 

    # 
    for n in range(N):  # 
        for i in range(Ho):  # 
            for j in range(Wo):  # 
                # 
                patch = x_pad[n, i : i + Kh, j : j + Kw, :]
                for cout in range(Cout):  # 
                    # 
                    dw[:, :, :, cout] += patch * dy[n, i, j, cout]
                    # 
                    dx_pad[n, i : i + Kh, j : j + Kw, :] += (
                        w[:, :, :, cout] * dy[n, i, j, cout]
                    )
                    # 
                    db[cout] += dy[n, i, j, cout]

    # 
    dx = dx_pad[:, padding:-padding, padding:-padding, :]
    return dx, dw, db


# ReLU
def relu_forward(x):
    # x: 
    y = np.maximum(0, x)  # ReLUmax(0,x)
    return y, x  # (x)


# ReLU
def relu_backward(dy, cache):
    # dy: 
    # cache: x
    x = cache
    # ReLUx>010
    return dy * (x > 0)


# 
def maxpool_forward(x):
    # x: (N,H,W,C)
    N, H, W, C = x.shape  # 
    pool_size = (2, 2)  # 2x2
    ph, pw = pool_size
    # 
    Ho = (H - ph) // 2 + 1
    Wo = (W - pw) // 2 + 1

    # 
    y = np.zeros((N, Ho, Wo, C), dtype=x.dtype)
    mask = {}  # 

    # 
    for n in range(N):  # 
        for i in range(Ho):  # 
            for j in range(Wo):  # 
                # 
                patch = x[n, i * 2 : i * 2 + ph, j * 2 : j * 2 + pw, :]
                # 
                y[n, i, j, :] = patch.max(axis=(0, 1))

                # 
                for c in range(C):
                    idx = np.unravel_index(np.argmax(patch[:, :, c]), (ph, pw))
                    mask[(n, i, j, c)] = (i * 2 + idx[0], j * 2 + idx[1])

    return y, (x, mask)  # 


# 
def maxpool_backward(dy, cache):
    # dy: 
    # cache: 
    x, mask = cache  # 

    # 
    dx = np.zeros_like(x)
    N, Ho, Wo, C = dy.shape  # 

    # 
    for n in range(N):  # 
        for i in range(Ho):  # 
            for j in range(Wo):  # 
                for c in range(C):  # 
                    # 
                    xi, xj = mask[(n, i, j, c)]
                    dx[n, xi, xj, c] += dy[n, i, j, c]

    return dx


# 
def flatten_forward(x):
    # x: (N,H,W,C)
    # (N, H*W*C)
    return x.reshape(x.shape[0], -1), x.shape


# 
def flatten_backward(dy, cache):
    # dy: (N, H*W*C)
    # cache: 
    # 
    return dy.reshape(cache)


# 
def dense_forward(x, w, b):
    # x: (N, Din)
    # w: (Din, Dout)
    # b: Dout
    y = x.dot(w) + b  # y = x·w + b
    return y, (x, w, b)  # 


# 
def dense_backward(dy, cache):
    # dy: (N, Dout)
    # cache: 
    x, w, b = cache  # 

    # 
    dx = dy.dot(w.T)  # dy·w^T
    dw = x.T.dot(dy)  # x^T·dy
    db = dy.sum(axis=0)  # 

    return dx, dw, db


# Softmax
def softmax_crossentropy_forward(logits, labels):
    # logits: (N, )
    # labels: (N, )one-hot

    # softmax
    ex = np.exp(logits - logits.max(axis=1, keepdims=True))
    proba = ex / ex.sum(axis=1, keepdims=True)

    N = logits.shape[0]  # 
    # 
    loss = -np.sum(labels * np.log(proba + 1e-12)) / N

    return loss, (proba, labels, N)  # 


# Softmax
def softmax_crossentropy_backward(cache):
    # cache: 
    proba, labels, N = cache  # 
    # (softmax - ) / 
    return (proba - labels) / N


# 
digits = load_digits()
X = digits.images.astype(np.float32) / 16.0  # 0~1
y = digits.target
X = X[..., np.newaxis]  # (N,8,8,1)
num_classes = 10

# one-hot
Y = np.eye(num_classes)[y]

# 
X_train, X_val, Y_train, Y_val = train_test_split(X, Y, test_size=0.2, stratify=y)
y_val_labels = Y_val.argmax(axis=1)  # ()

# (He)
w1 = np.random.randn(3, 3, 1, 8).astype(np.float32) * np.sqrt(2 / 9)  # 
b1 = np.zeros(8, dtype=np.float32)  # 
w2 = np.random.randn(4 * 4 * 8, num_classes).astype(np.float32) * np.sqrt(
    2 / 128
)  # 
b2 = np.zeros(num_classes, dtype=np.float32)  # 

# 
epochs = 10  # 
batch_size = 64  # 
lr = 0.1  # 

# 
num_train = X_train.shape[0]  # 
for ep in range(epochs):
    # 
    perm = np.random.permutation(num_train)
    X_train = X_train[perm]
    Y_train = Y_train[perm]

    # 
    for i in range(0, num_train, batch_size):
        xb = X_train[i : i + batch_size]  # 
        yb = Y_train[i : i + batch_size]  # 

        # 
        out1, c1 = conv2d_forward(xb, w1, b1)  # 
        out1r, c1r = relu_forward(out1)  # ReLU
        out2, c2 = maxpool_forward(out1r)  # 
        flat, cf = flatten_forward(out2)  # 
        logits, c3 = dense_forward(flat, w2, b2)  # 
        loss, c4 = softmax_crossentropy_forward(logits, yb)  # 

        # 
        dlogits = softmax_crossentropy_backward(c4)  # 
        dflat, dw2, db2 = dense_backward(dlogits, c3)  # 
        dout2 = flatten_backward(dflat, cf)  # 
        dout1r = maxpool_backward(dout2, c2)  # 
        dout1 = relu_backward(dout1r, c1r)  # ReLU
        _, dw1, db1 = conv2d_backward(dout1, c1)  # 

        # ()
        w1 -= lr * dw1  # 
        b1 -= lr * db1  # 
        w2 -= lr * dw2  # 
        b2 -= lr * db2  # 

    # 
    out1, _ = conv2d_forward(X_val, w1, b1)  # 
    out1r, _ = relu_forward(out1)  # ReLU
    out2, _ = maxpool_forward(out1r)  # 
    flat, _ = flatten_forward(out2)  # 
    logits, _ = dense_forward(flat, w2, b2)  # 
    preds = np.argmax(logits, axis=1)  # 
    acc = (preds == y_val_labels).mean()  # 
    print(f" {ep+1}/{epochs}  ={loss:.4f}  ={acc:.4f}")
```
  </TabItem>

</Tabs>
