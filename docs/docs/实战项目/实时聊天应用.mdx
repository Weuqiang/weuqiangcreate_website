---
sidebar_position: 2
title: å®æ—¶èŠå¤©åº”ç”¨å®æˆ˜
tags: [å®æˆ˜é¡¹ç›®, WebSocket, å®æ—¶é€šä¿¡]
---

# å®æ—¶èŠå¤©åº”ç”¨å®æˆ˜

æœ¬æ–‡å°†å¸¦ä½ æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„å®æ—¶èŠå¤©åº”ç”¨ï¼Œæ”¯æŒç§èŠã€ç¾¤èŠã€æ–‡ä»¶ä¼ è¾“ç­‰åŠŸèƒ½ã€‚

## é¡¹ç›®æ¦‚è¿°

### æŠ€æœ¯æ ˆ

```javascript
const techStack = {
  frontend: {
    framework: 'Vue 3',
    state: 'Pinia',
    websocket: 'Socket.io-client',
    ui: 'Element Plus',
    build: 'Vite'
  },
  
  backend: {
    runtime: 'Node.js',
    framework: 'Express',
    websocket: 'Socket.io',
    database: 'MongoDB',
    cache: 'Redis',
    storage: 'MinIO'
  }
};
```

### æ ¸å¿ƒåŠŸèƒ½

```javascript
const features = {
  messaging: [
    'å®æ—¶æ¶ˆæ¯å‘é€/æ¥æ”¶',
    'æ¶ˆæ¯å·²è¯»/æœªè¯»',
    'æ¶ˆæ¯æ’¤å›',
    'æ¶ˆæ¯è½¬å‘',
    '@æé†’åŠŸèƒ½'
  ],
  
  chat: [
    'ç§èŠ',
    'ç¾¤èŠ',
    'èŠå¤©å®¤åˆ—è¡¨',
    'åœ¨çº¿çŠ¶æ€'
  ],
  
  media: [
    'å›¾ç‰‡å‘é€',
    'æ–‡ä»¶ä¼ è¾“',
    'è¯­éŸ³æ¶ˆæ¯',
    'è§†é¢‘é€šè¯'
  ],
  
  other: [
    'æ¶ˆæ¯æœç´¢',
    'èŠå¤©è®°å½•',
    'è¡¨æƒ…åŒ…',
    'æ¶ˆæ¯é€šçŸ¥'
  ]
};
```

## åç«¯å®ç°

### WebSocketæœåŠ¡

```javascript
// server.js
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');
const Redis = require('ioredis');
const mongoose = require('mongoose');

const app = express();
const server = http.createServer(app);
const io = socketIO(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST']
  }
});

const redis = new Redis();

// ç”¨æˆ·åœ¨çº¿çŠ¶æ€ç®¡ç†
class OnlineManager {
  constructor() {
    this.users = new Map(); // userId -> socketId
  }
  
  addUser(userId, socketId) {
    this.users.set(userId, socketId);
    redis.sadd('online_users', userId);
  }
  
  removeUser(userId) {
    this.users.delete(userId);
    redis.srem('online_users', userId);
  }
  
  getSocketId(userId) {
    return this.users.get(userId);
  }
  
  async getOnlineUsers() {
    return await redis.smembers('online_users');
  }
}

const onlineManager = new OnlineManager();

// Socket.ioè¿æ¥å¤„ç†
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // ç”¨æˆ·ç™»å½•
  socket.on('login', async (userId) => {
    socket.userId = userId;
    onlineManager.addUser(userId, socket.id);
    
    // åŠ å…¥ç”¨æˆ·çš„æ‰€æœ‰èŠå¤©å®¤
    const rooms = await getUserRooms(userId);
    rooms.forEach(room => {
      socket.join(room.id);
    });
    
    // å¹¿æ’­ç”¨æˆ·ä¸Šçº¿
    socket.broadcast.emit('user_online', userId);
    
    // å‘é€ç¦»çº¿æ¶ˆæ¯
    const offlineMessages = await getOfflineMessages(userId);
    socket.emit('offline_messages', offlineMessages);
  });
  
  // å‘é€æ¶ˆæ¯
  socket.on('send_message', async (data) => {
    const { roomId, content, type, to } = data;
    
    const message = {
      id: generateId(),
      from: socket.userId,
      to,
      roomId,
      content,
      type,
      timestamp: Date.now(),
      status: 'sent'
    };
    
    // ä¿å­˜æ¶ˆæ¯
    await saveMessage(message);
    
    if (roomId) {
      // ç¾¤èŠæ¶ˆæ¯
      io.to(roomId).emit('new_message', message);
    } else {
      // ç§èŠæ¶ˆæ¯
      const targetSocketId = onlineManager.getSocketId(to);
      
      if (targetSocketId) {
        // ç”¨æˆ·åœ¨çº¿ï¼Œç›´æ¥å‘é€
        io.to(targetSocketId).emit('new_message', message);
        socket.emit('message_sent', { messageId: message.id, status: 'delivered' });
      } else {
        // ç”¨æˆ·ç¦»çº¿ï¼Œå­˜å‚¨ç¦»çº¿æ¶ˆæ¯
        await saveOfflineMessage(to, message);
        socket.emit('message_sent', { messageId: message.id, status: 'sent' });
      }
    }
  });
  
  // æ¶ˆæ¯å·²è¯»
  socket.on('message_read', async (data) => {
    const { messageId, roomId } = data;
    
    await markMessageAsRead(messageId, socket.userId);
    
    // é€šçŸ¥å‘é€è€…
    const message = await getMessage(messageId);
    const senderSocketId = onlineManager.getSocketId(message.from);
    
    if (senderSocketId) {
      io.to(senderSocketId).emit('message_read', {
        messageId,
        readBy: socket.userId
      });
    }
  });
  
  // æ­£åœ¨è¾“å…¥
  socket.on('typing', (data) => {
    const { roomId, to } = data;
    
    if (roomId) {
      socket.to(roomId).emit('user_typing', {
        userId: socket.userId,
        roomId
      });
    } else {
      const targetSocketId = onlineManager.getSocketId(to);
      if (targetSocketId) {
        io.to(targetSocketId).emit('user_typing', {
          userId: socket.userId
        });
      }
    }
  });
  
  // åœæ­¢è¾“å…¥
  socket.on('stop_typing', (data) => {
    const { roomId, to } = data;
    
    if (roomId) {
      socket.to(roomId).emit('user_stop_typing', {
        userId: socket.userId,
        roomId
      });
    } else {
      const targetSocketId = onlineManager.getSocketId(to);
      if (targetSocketId) {
        io.to(targetSocketId).emit('user_stop_typing', {
          userId: socket.userId
        });
      }
    }
  });
  
  // åˆ›å»ºç¾¤èŠ
  socket.on('create_room', async (data) => {
    const { name, members } = data;
    
    const room = await createRoom({
      name,
      creator: socket.userId,
      members: [socket.userId, ...members]
    });
    
    // æ‰€æœ‰æˆå‘˜åŠ å…¥æˆ¿é—´
    room.members.forEach(memberId => {
      const socketId = onlineManager.getSocketId(memberId);
      if (socketId) {
        io.sockets.sockets.get(socketId)?.join(room.id);
      }
    });
    
    // é€šçŸ¥æ‰€æœ‰æˆå‘˜
    io.to(room.id).emit('room_created', room);
  });
  
  // åŠ å…¥ç¾¤èŠ
  socket.on('join_room', async (roomId) => {
    socket.join(roomId);
    
    await addRoomMember(roomId, socket.userId);
    
    socket.to(roomId).emit('user_joined', {
      roomId,
      userId: socket.userId
    });
  });
  
  // ç¦»å¼€ç¾¤èŠ
  socket.on('leave_room', async (roomId) => {
    socket.leave(roomId);
    
    await removeRoomMember(roomId, socket.userId);
    
    socket.to(roomId).emit('user_left', {
      roomId,
      userId: socket.userId
    });
  });
  
  // æ–‡ä»¶ä¼ è¾“
  socket.on('send_file', async (data) => {
    const { roomId, to, file } = data;
    
    // ä¸Šä¼ æ–‡ä»¶åˆ°å­˜å‚¨æœåŠ¡
    const fileUrl = await uploadFile(file);
    
    const message = {
      id: generateId(),
      from: socket.userId,
      to,
      roomId,
      content: fileUrl,
      type: 'file',
      fileName: file.name,
      fileSize: file.size,
      timestamp: Date.now()
    };
    
    await saveMessage(message);
    
    if (roomId) {
      io.to(roomId).emit('new_message', message);
    } else {
      const targetSocketId = onlineManager.getSocketId(to);
      if (targetSocketId) {
        io.to(targetSocketId).emit('new_message', message);
      }
    }
  });
  
  // è§†é¢‘é€šè¯
  socket.on('call_user', (data) => {
    const { to, offer } = data;
    const targetSocketId = onlineManager.getSocketId(to);
    
    if (targetSocketId) {
      io.to(targetSocketId).emit('incoming_call', {
        from: socket.userId,
        offer
      });
    }
  });
  
  socket.on('answer_call', (data) => {
    const { to, answer } = data;
    const targetSocketId = onlineManager.getSocketId(to);
    
    if (targetSocketId) {
      io.to(targetSocketId).emit('call_answered', {
        from: socket.userId,
        answer
      });
    }
  });
  
  socket.on('ice_candidate', (data) => {
    const { to, candidate } = data;
    const targetSocketId = onlineManager.getSocketId(to);
    
    if (targetSocketId) {
      io.to(targetSocketId).emit('ice_candidate', {
        from: socket.userId,
        candidate
      });
    }
  });
  
  // æ–­å¼€è¿æ¥
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
    
    if (socket.userId) {
      onlineManager.removeUser(socket.userId);
      socket.broadcast.emit('user_offline', socket.userId);
    }
  });
});

server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### æ•°æ®æ¨¡å‹

```javascript
// models/Message.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  from: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  to: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  roomId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Room'
  },
  content: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['text', 'image', 'file', 'audio', 'video'],
    default: 'text'
  },
  fileName: String,
  fileSize: Number,
  status: {
    type: String,
    enum: ['sent', 'delivered', 'read'],
    default: 'sent'
  },
  readBy: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    readAt: Date
  }],
  deleted: {
    type: Boolean,
    default: false
  },
  deletedAt: Date
}, {
  timestamps: true
});

messageSchema.index({ from: 1, to: 1, createdAt: -1 });
messageSchema.index({ roomId: 1, createdAt: -1 });

module.exports = mongoose.model('Message', messageSchema);

// models/Room.js
const roomSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['private', 'group'],
    default: 'group'
  },
  creator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  members: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  avatar: String,
  description: String,
  lastMessage: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Message'
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Room', roomSchema);
```

## å‰ç«¯å®ç°

### Socketè¿æ¥ç®¡ç†

```javascript
// services/socket.js
import { io } from 'socket.io-client';
import { useUserStore } from '@/stores/user';
import { useChatStore } from '@/stores/chat';

class SocketService {
  constructor() {
    this.socket = null;
    this.connected = false;
  }
  
  connect() {
    this.socket = io('http://localhost:3000', {
      autoConnect: false
    });
    
    this.setupListeners();
    this.socket.connect();
  }
  
  setupListeners() {
    const userStore = useUserStore();
    const chatStore = useChatStore();
    
    this.socket.on('connect', () => {
      console.log('Connected to server');
      this.connected = true;
      
      // ç™»å½•
      this.socket.emit('login', userStore.user.id);
    });
    
    this.socket.on('disconnect', () => {
      console.log('Disconnected from server');
      this.connected = false;
    });
    
    // æ–°æ¶ˆæ¯
    this.socket.on('new_message', (message) => {
      chatStore.addMessage(message);
      
      // æ˜¾ç¤ºé€šçŸ¥
      if (Notification.permission === 'granted') {
        new Notification('æ–°æ¶ˆæ¯', {
          body: message.content,
          icon: '/logo.png'
        });
      }
      
      // æ’­æ”¾æç¤ºéŸ³
      const audio = new Audio('/notification.mp3');
      audio.play();
    });
    
    // ç¦»çº¿æ¶ˆæ¯
    this.socket.on('offline_messages', (messages) => {
      messages.forEach(message => {
        chatStore.addMessage(message);
      });
    });
    
    // æ¶ˆæ¯å·²è¯»
    this.socket.on('message_read', ({ messageId, readBy }) => {
      chatStore.markMessageAsRead(messageId, readBy);
    });
    
    // ç”¨æˆ·ä¸Šçº¿
    this.socket.on('user_online', (userId) => {
      chatStore.setUserOnline(userId, true);
    });
    
    // ç”¨æˆ·ç¦»çº¿
    this.socket.on('user_offline', (userId) => {
      chatStore.setUserOnline(userId, false);
    });
    
    // æ­£åœ¨è¾“å…¥
    this.socket.on('user_typing', ({ userId, roomId }) => {
      chatStore.setUserTyping(userId, roomId, true);
    });
    
    // åœæ­¢è¾“å…¥
    this.socket.on('user_stop_typing', ({ userId, roomId }) => {
      chatStore.setUserTyping(userId, roomId, false);
    });
    
    // è§†é¢‘é€šè¯
    this.socket.on('incoming_call', ({ from, offer }) => {
      chatStore.handleIncomingCall(from, offer);
    });
    
    this.socket.on('call_answered', ({ from, answer }) => {
      chatStore.handleCallAnswered(from, answer);
    });
    
    this.socket.on('ice_candidate', ({ from, candidate }) => {
      chatStore.handleIceCandidate(from, candidate);
    });
  }
  
  // å‘é€æ¶ˆæ¯
  sendMessage(data) {
    this.socket.emit('send_message', data);
  }
  
  // æ ‡è®°å·²è¯»
  markAsRead(messageId, roomId) {
    this.socket.emit('message_read', { messageId, roomId });
  }
  
  // æ­£åœ¨è¾“å…¥
  typing(data) {
    this.socket.emit('typing', data);
  }
  
  // åœæ­¢è¾“å…¥
  stopTyping(data) {
    this.socket.emit('stop_typing', data);
  }
  
  // åˆ›å»ºç¾¤èŠ
  createRoom(data) {
    this.socket.emit('create_room', data);
  }
  
  // å‘é€æ–‡ä»¶
  sendFile(data) {
    this.socket.emit('send_file', data);
  }
  
  // å‘èµ·è§†é¢‘é€šè¯
  callUser(to, offer) {
    this.socket.emit('call_user', { to, offer });
  }
  
  // æ¥å¬è§†é¢‘é€šè¯
  answerCall(to, answer) {
    this.socket.emit('answer_call', { to, answer });
  }
  
  // ICEå€™é€‰
  sendIceCandidate(to, candidate) {
    this.socket.emit('ice_candidate', { to, candidate });
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
    }
  }
}

export default new SocketService();
```

### èŠå¤©ç»„ä»¶

```vue
<!-- components/ChatWindow.vue -->
<template>
  <div class="chat-window">
    <div class="chat-header">
      <div class="chat-info">
        <el-avatar :src="currentChat.avatar" />
        <div>
          <h3>{{ currentChat.name }}</h3>
          <span v-if="isTyping" class="typing-indicator">
            æ­£åœ¨è¾“å…¥...
          </span>
          <span v-else class="online-status">
            {{ currentChat.online ? 'åœ¨çº¿' : 'ç¦»çº¿' }}
          </span>
        </div>
      </div>
      
      <div class="chat-actions">
        <el-button @click="startVideoCall" icon="VideoCamera">
          è§†é¢‘é€šè¯
        </el-button>
      </div>
    </div>
    
    <div class="message-list" ref="messageList">
      <div
        v-for="message in messages"
        :key="message.id"
        :class="['message', message.from === userId ? 'sent' : 'received']"
      >
        <el-avatar :src="getUserAvatar(message.from)" />
        
        <div class="message-content">
          <div class="message-info">
            <span class="username">{{ getUserName(message.from) }}</span>
            <span class="time">{{ formatTime(message.timestamp) }}</span>
          </div>
          
          <div v-if="message.type === 'text'" class="text-message">
            {{ message.content }}
          </div>
          
          <div v-else-if="message.type === 'image'" class="image-message">
            <el-image :src="message.content" fit="cover" />
          </div>
          
          <div v-else-if="message.type === 'file'" class="file-message">
            <el-icon><Document /></el-icon>
            <span>{{ message.fileName }}</span>
            <el-button size="small" @click="downloadFile(message)">
              ä¸‹è½½
            </el-button>
          </div>
          
          <div class="message-status">
            <el-icon v-if="message.status === 'sent'"><Check /></el-icon>
            <el-icon v-else-if="message.status === 'delivered'">
              <Check /><Check />
            </el-icon>
            <el-icon v-else class="read"><Check /><Check /></el-icon>
          </div>
        </div>
      </div>
    </div>
    
    <div class="message-input">
      <el-button @click="selectEmoji" icon="Smile" circle />
      <el-button @click="selectImage" icon="Picture" circle />
      <el-button @click="selectFile" icon="Paperclip" circle />
      
      <el-input
        v-model="inputMessage"
        @input="handleTyping"
        @keyup.enter="sendMessage"
        placeholder="è¾“å…¥æ¶ˆæ¯..."
        type="textarea"
        :rows="3"
      />
      
      <el-button type="primary" @click="sendMessage">
        å‘é€
      </el-button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, nextTick } from 'vue';
import { useChatStore } from '@/stores/chat';
import { useUserStore } from '@/stores/user';
import socketService from '@/services/socket';

const chatStore = useChatStore();
const userStore = useUserStore();

const inputMessage = ref('');
const messageList = ref(null);
const typingTimer = ref(null);

const userId = computed(() => userStore.user.id);
const currentChat = computed(() => chatStore.currentChat);
const messages = computed(() => chatStore.currentMessages);
const isTyping = computed(() => chatStore.isUserTyping(currentChat.value?.id));

// å‘é€æ¶ˆæ¯
const sendMessage = () => {
  if (!inputMessage.value.trim()) return;
  
  socketService.sendMessage({
    to: currentChat.value.id,
    roomId: currentChat.value.roomId,
    content: inputMessage.value,
    type: 'text'
  });
  
  inputMessage.value = '';
  stopTyping();
};

// å¤„ç†è¾“å…¥
const handleTyping = () => {
  socketService.typing({
    to: currentChat.value.id,
    roomId: currentChat.value.roomId
  });
  
  clearTimeout(typingTimer.value);
  typingTimer.value = setTimeout(stopTyping, 3000);
};

const stopTyping = () => {
  socketService.stopTyping({
    to: currentChat.value.id,
    roomId: currentChat.value.roomId
  });
};

// é€‰æ‹©å›¾ç‰‡
const selectImage = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (file) {
      uploadImage(file);
    }
  };
  
  input.click();
};

// ä¸Šä¼ å›¾ç‰‡
const uploadImage = async (file) => {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await fetch('/api/upload', {
    method: 'POST',
    body: formData
  });
  
  const { url } = await response.json();
  
  socketService.sendMessage({
    to: currentChat.value.id,
    roomId: currentChat.value.roomId,
    content: url,
    type: 'image'
  });
};

// å‘èµ·è§†é¢‘é€šè¯
const startVideoCall = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  });
  
  const pc = new RTCPeerConnection();
  
  stream.getTracks().forEach(track => {
    pc.addTrack(track, stream);
  });
  
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  
  socketService.callUser(currentChat.value.id, offer);
};

// æ»šåŠ¨åˆ°åº•éƒ¨
const scrollToBottom = () => {
  nextTick(() => {
    if (messageList.value) {
      messageList.value.scrollTop = messageList.value.scrollHeight;
    }
  });
};

watch(messages, scrollToBottom);
</script>

<style scoped>
.chat-window {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.message-list {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.message {
  display: flex;
  margin-bottom: 20px;
}

.message.sent {
  flex-direction: row-reverse;
}

.message-content {
  max-width: 60%;
  margin: 0 10px;
}

.message-input {
  display: flex;
  gap: 10px;
  padding: 20px;
  border-top: 1px solid #eee;
}
</style>
```

## æ€»ç»“

å®æ—¶èŠå¤©åº”ç”¨è¦ç‚¹ï¼š
- ğŸ”Œ **WebSocket**ï¼šSocket.ioå®ç°å®æ—¶é€šä¿¡
- ğŸ’¬ **æ¶ˆæ¯ç³»ç»Ÿ**ï¼šå‘é€ã€æ¥æ”¶ã€å·²è¯»ã€æ’¤å›
- ğŸ‘¥ **åœ¨çº¿çŠ¶æ€**ï¼šRedisç®¡ç†åœ¨çº¿ç”¨æˆ·
- ğŸ“ **æ–‡ä»¶ä¼ è¾“**ï¼šæ”¯æŒå›¾ç‰‡ã€æ–‡ä»¶å‘é€
- ğŸ“¹ **è§†é¢‘é€šè¯**ï¼šWebRTCå®ç°éŸ³è§†é¢‘
- ğŸ”” **æ¶ˆæ¯é€šçŸ¥**ï¼šæµè§ˆå™¨é€šçŸ¥ã€æç¤ºéŸ³

è®°ä½ï¼š**å®æ—¶æ€§ã€å¯é æ€§ã€ç”¨æˆ·ä½“éªŒæ˜¯å…³é”®ï¼**

