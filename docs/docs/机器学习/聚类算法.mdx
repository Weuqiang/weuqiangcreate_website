---
sidebar_position: 1
title: 
---

1005100

""

10,N





## K 

 K 

K 

1.  K centroids

2.  K 

3. 

4.  2  3

DBSCAN



, A(x1),B(x2), A,B 

$
|AB|=\sqrt{(x1-x2)^2}
$

, A(x1,y1),B(x2,y2), A,B 

$
|AB|=\sqrt{(x1-x2)^2+(y1-y2)^2}
$

, A(x1,y1,z1),B(x2,y2,z2), A,B 

$
|AB|=\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2}
$



### 

10*10

12

12

5

<details>
<summary></summary>
``` jsx live 
function KMeansAnimation() {
  const gridSize = 10;
  
  const [dataPoints, setDataPoints] = React.useState([]);
  const [centroids, setCentroids] = React.useState([
    { x: 0, y: 0 },
    { x: 5, y: 5 }
  ]);
  const [step, setStep] = React.useState(0);
  const [iteration, setIteration] = React.useState(0);
  const [ready, setReady] = React.useState(false);
  
  React.useEffect(() => {
    const generateAllGridPoints = () => {
      const points = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          points.push({
            x: i,
            y: j,
            cluster: null
          });
        }
      }
      return points;
    };
    
    setDataPoints(generateAllGridPoints());
    
    // 5
    const initialTimer = setTimeout(() => {
      setReady(true);
    }, 5000);
    
    return () => clearTimeout(initialTimer);
  }, []);
  
  const distance = (point1, point2) => {
    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
  };
  
  React.useEffect(() => {
    if (dataPoints.length === 0 || !ready) return;
    
    const timer = setTimeout(() => {
      if (step === 0) {
        const newDataPoints = dataPoints.map(point => {
          const dist1 = distance(point, centroids[0]);
          const dist2 = distance(point, centroids[1]);
          return {
            ...point,
            cluster: dist1 <= dist2 ? 0 : 1
          };
        });
        setDataPoints(newDataPoints);
        setStep(1);
      } else if (step === 1) {
        const cluster0Points = dataPoints.filter(p => p.cluster === 0);
        const cluster1Points = dataPoints.filter(p => p.cluster === 1);
        
        if (cluster0Points.length > 0 && cluster1Points.length > 0) {
          const newX0 = Math.round(cluster0Points.reduce((sum, p) => sum + p.x, 0) / cluster0Points.length);
          const newY0 = Math.round(cluster0Points.reduce((sum, p) => sum + p.y, 0) / cluster0Points.length);
          
          const newX1 = Math.round(cluster1Points.reduce((sum, p) => sum + p.x, 0) / cluster1Points.length);
          const newY1 = Math.round(cluster1Points.reduce((sum, p) => sum + p.y, 0) / cluster1Points.length);
          
          setCentroids([
            { x: newX0, y: newY0 },
            { x: newX1, y: newY1 }
          ]);
        }
        
        setStep(0);
        setIteration(prev => prev + 1);
        
        // 5
        setReady(false);
        setTimeout(() => {
          setReady(true);
        }, 5000);
      }
    }, 1000);
    
    return () => clearTimeout(timer);
  }, [step, dataPoints, centroids, ready]);
  
  const renderGrid = () => {
    const grid = [];
    
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const pointAtPosition = dataPoints.find(p => p.x === x && p.y === y);
        
        const isCentroid0 = centroids[0].x === x && centroids[0].y === y;
        const isCentroid1 = centroids[1].x === x && centroids[1].y === y;
        
        let cellStyle = {
          width: '32px',
          height: '32px',
          border: '1px solid #cbd5e0',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        };
        
        if (pointAtPosition) {
          if (pointAtPosition.cluster === 0) {
            cellStyle.backgroundColor = '#9ae6b4';
          } else if (pointAtPosition.cluster === 1) {
            cellStyle.backgroundColor = '#90cdf4';
          }
        }
        
        if (isCentroid0) {
          cellStyle.backgroundColor = '#276749';
        } else if (isCentroid1) {
          cellStyle.backgroundColor = '#2b6cb0';
        }
        
        grid.push(
          <div key={`${x}-${y}`} style={cellStyle}></div>
        );
      }
    }
    
    return grid;
  };
  
  return (
    <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '16px'}}>
      <h2 style={{fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '16px'}}>K-Means </h2>
      <div style={{marginBottom: '16px'}}>
        : {iteration}
        {!ready && <span style={{marginLeft: '10px', color: '#718096'}}>...</span>}
      </div>
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(10, 1fr)',
        gap: '4px',
        marginBottom: '16px'
      }}>
        {renderGrid()}
      </div>
      <div style={{marginTop: '16px', display: 'flex', gap: '24px'}}>
        <div style={{display: 'flex', alignItems: 'center'}}>
          <div style={{width: '16px', height: '16px', backgroundColor: '#9ae6b4', marginRight: '8px'}}></div>
          <span>1</span>
        </div>
        <div style={{display: 'flex', alignItems: 'center'}}>
          <div style={{width: '16px', height: '16px', backgroundColor: '#276749', marginRight: '8px'}}></div>
          <span>1</span>
        </div>
        <div style={{display: 'flex', alignItems: 'center'}}>
          <div style={{width: '16px', height: '16px', backgroundColor: '#90cdf4', marginRight: '8px'}}></div>
          <span>2</span>
        </div>
        <div style={{display: 'flex', alignItems: 'center'}}>
          <div style={{width: '16px', height: '16px', backgroundColor: '#2b6cb0', marginRight: '8px'}}></div>
          <span>2</span>
        </div>
      </div>
    </div>
  );
}
```
</details>


### 

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="numpy" label="numpy">

``` python showLineNumbers
import numpy as np
from sklearn.datasets import load_iris

def kmeans(datas, k=3, max_iter=1000, tolerance=1e-6):
    """
    K-means
    
    :
    datas: numpy
    k: 2
    max_iter: 100
    tolerance: 1e-4
    
    :
    kernels: 
    labels: 
    """
    # K
    kernels = datas[:k].copy().astype(float)
    labels = np.zeros(len(datas), dtype=int)
    
    for iteration in range(max_iter):
        # 
        old_kernels = kernels.copy()
        
        # 1: 
        for i, point in enumerate(datas):
            # 
            distances = np.array([np.sum((kernel - point) ** 2) for kernel in kernels])
            # 
            labels[i] = np.argmin(distances)
        
        # 2: 
        for j in range(k):
            # j
            cluster_points = datas[labels == j]
            if len(cluster_points) > 0:
                # 
                kernels[j] = np.mean(cluster_points, axis=0)
        
        # 
        if np.all(np.abs(kernels - old_kernels) < tolerance):
            print(f"{iteration + 1}")
            break
    else:
        print(f"{max_iter}")
    
    return kernels, labels

# 
if __name__ == "__main__":
    # iris
    iris = load_iris()
    iris_X = iris.data
    iris_y = iris.target

    # K-means
    centers, labels = kmeans(iris_X, k=3)

    # 
    '''
    K-means0,1,2iris0,1,2
    01
    12
    20
    K-means0,1,2iris0,1,2
    '''
    for i,j in zip(labels,iris_y):
        print(i,j)
    dicts = {0:2,1:1,2:0}

    error = 0
    for i in range(len(iris_y)):
        if iris_y[i] != dicts[labels[i]]:
            error += 1
    accuracy = 1 - error / len(iris_y)
    print(f": {accuracy:.2f}") # : 0.89

```
  </TabItem>
  <TabItem value="sklearn" label="sklearn" default>

```python showLineNumbers
# 
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import load_iris
# 
iris = load_iris()
iris_X = iris.data
iris_y = iris.target

# K
kmeans = KMeans(n_clusters=3)
# 
kmeans.fit(iris_X)

# 
centers = kmeans.cluster_centers_
labels = kmeans.labels_
print(iris_y)
print(labels)

```
  </TabItem>

</Tabs>

### 

```python showLineNumbers
# 012102
exchange={0:1,1:0,2:2}
exchange_labels = [exchange[i] if i in exchange else i for i in labels]

right = 0
error = 0
for i in zip(exchange_labels,iris_y):
    if i[0] == i[1]:
        right +=1
    else:
        error +=1

print('{}%'.format(right/(right+error)*100))
```

### 

```python showLineNumbers
# 12
plt.scatter(iris_X[:, 0], iris_X[:, 1], c=labels)
plt.scatter(centers[:, 0], centers[:,1], c="red", marker="x")
plt.title("Kmeans")
plt.show()
# 34
plt.scatter(iris_X[:, 2], iris_X[:,3], c=labels)
plt.scatter(centers[:, 2], centers[:,3], c="red", marker="x")
plt.show()
```

###  K

 K 



 K  K  K 


```python showLineNumbers
from sklearn.model_selection import cross_val_score
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris

iris = load_iris()
X = iris.data
y = iris.target

k_range = range(1, 31)
k_scores = []
for k in k_range:
    knn = KNeighborsClassifier(n_neighbors=k)
    # loss = -cross_val_score(knn, X, y, cv=10, scoring='mean_squared_error') # for regression
    # 10,scoringaccuracyr2mean_squared_error
    # 10910
    # 
    scores = cross_val_score(knn, X, y, cv=10, scoring='accuracy') # for classification

    # .mean()
    k_scores.append(scores.mean())

plt.plot(k_range, k_scores)
plt.xlabel('Value of K for KNN')
plt.ylabel('Cross-Validated Accuracy')
plt.show()
```

### 

#### 

 96615  64

`sklearn.datasets.load_sample_image("china.jpg")`

#### 

```python showLineNumbers
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin
from sklearn.datasets import load_sample_image
from sklearn.utils import shuffle
from time import time

n_colors = 64

# Load the Summer Palace photo
china = load_sample_image("china.jpg")

# Convert to floats instead of the default 8 bits integer coding. Dividing by
# 255 is important so that plt.imshow behaves works well on float data (need to
# be in the range [0-1])
china = np.array(china, dtype=np.float64) / 255

# Load Image and transform to a 2D numpy array.
w, h, d = original_shape = tuple(china.shape)
assert d == 3
image_array = np.reshape(china, (w * h, d))

print("Fitting model on a small sub-sample of the data")
t0 = time()
image_array_sample = shuffle(image_array, random_state=0)[:1000]
kmeans = KMeans(n_clusters=n_colors, random_state=0).fit(image_array_sample)
print("done in %0.3fs." % (time() - t0))

# Get labels for all points
print("Predicting color indices on the full image (k-means)")
t0 = time()
labels = kmeans.predict(image_array)
print("done in %0.3fs." % (time() - t0))


codebook_random = shuffle(image_array, random_state=0)[:n_colors]
print("Predicting color indices on the full image (random)")
t0 = time()
labels_random = pairwise_distances_argmin(codebook_random,
                                          image_array,
                                          axis=0)
print("done in %0.3fs." % (time() - t0))


def recreate_image(codebook, labels, w, h):
    """Recreate the (compressed) image from the code book & labels"""
    d = codebook.shape[1]
    image = np.zeros((w, h, d))
    label_idx = 0
    for i in range(w):
        for j in range(h):
            image[i][j] = codebook[labels[label_idx]]
            label_idx += 1
    return image

# Display all results, alongside original image
plt.figure(1)
plt.clf()
plt.axis('off')
plt.title('Original image (96,615 colors)')
plt.imshow(china)

plt.figure(2)
plt.clf()
plt.axis('off')
plt.title('Quantized image (64 colors, K-Means)')
plt.imshow(recreate_image(kmeans.cluster_centers_, labels, w, h))

plt.figure(3)
plt.clf()
plt.axis('off')
plt.title('Quantized image (64 colors, Random)')
plt.imshow(recreate_image(codebook_random, labels_random, w, h))

```

## DBSCAN

DBSCANDensity-Based Spatial Clustering of Applications with Noise

DBSCANK-means

- ****
- ****
- ****
- ****

DBSCAN

**ε-Epsilon Neighborhood**pε-pεN_ε(p)

**Core Point**pε-min_samplespp

**Border Point**ε-

**Noise Point**

**Directly Density-Reachable**qpε-pqp

**Density-Reachable**p₁, p₂, ..., pₙp₁=p, pₙ=qipᵢ₊₁pᵢqp

**Density-Connected**opqopq

### 

DBSCAN

**1. ** - eps min_samples-1

**2. **
   -  eps 
   -  ≥ min_samples****3
   -  < min_samples

**3. **
   - ID
   - 
   - 4

**4. **
   - 
     - -1
     - 
   - 

**5. 2-4**

****
- ****ID
- ****-1

****

### 
<Tabs>
  <TabItem value="numpy" label="numpy">

```python showLineNumbers
from sklearn.datasets import load_iris
from sklearn.preprocessing import StandardScaler
import numpy as np

def dbscan(X, eps=0.5, min_samples=5):
    """
    DBSCAN
    """
    n_points = len(X)
    labels = np.full(n_points, -1)  # -1
    cluster_id = 0
    
    def euclidean_distance(p1, p2):
        return np.sqrt(np.sum((p1 - p2) ** 2))
    
    def get_neighbors(point_idx):
        neighbors = []
        for i in range(n_points):
            if euclidean_distance(X[point_idx], X[i]) <= eps:
                neighbors.append(i)
        return neighbors
    
    for i in range(n_points):
        if labels[i] != -1:
            continue
        neighbors = get_neighbors(i)
        if len(neighbors) < min_samples:
            continue
        labels[i] = cluster_id  # 
        seed_set = neighbors.copy()  # 
        j = 0
        while j < len(seed_set):
            current_point = seed_set[j]
            if labels[current_point] == -1:
                labels[current_point] = cluster_id
                current_neighbors = get_neighbors(current_point)
                if len(current_neighbors) >= min_samples:
                    for neighbor in current_neighbors:
                        if neighbor not in seed_set:
                            seed_set.append(neighbor)
            j += 1
        cluster_id += 1
    
    return labels

# 
iris = load_iris()
X, y_true = iris.data, iris.target

# 
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# DBSCAN
y_pred = dbscan(X_scaled, eps=0.5, min_samples=5)

```

  </TabItem>
  <TabItem value="sklearn" label="sklearn">

```python showLineNumbers
from sklearn.datasets import load_iris
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler

# 
iris = load_iris()
X, y_true = iris.data, iris.target

# 
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# DBSCAN
dbscan = DBSCAN(eps=0.5, min_samples=5)
y_pred = dbscan.fit_predict(X_scaled)

```

  </TabItem>
</Tabs>

