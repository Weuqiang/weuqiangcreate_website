---
sidebar_position: 2
title: 
tags: [, , Node.js, , ]
---

# 

Node.js

## Node.js

### 1. 

```javascript
/**
 * Node.js6
 */

// 
console.log('1: ');

setTimeout(() => {
  console.log('2: setTimeout');
}, 0);

setImmediate(() => {
  console.log('3: setImmediate');
});

process.nextTick(() => {
  console.log('4: nextTick');
});

Promise.resolve().then(() => {
  console.log('5: Promise');
});

console.log('6: ');

// 1 -> 6 -> 4 -> 5 -> 2 -> 3
// nextTick > Promise > setTimeout > setImmediate

// 
const phases = {
  timers: 'setTimeout/setInterval',
  pending: 'I/O',
  idle: '',
  poll: 'I/O',
  check: 'setImmediate',
  close: ''
};
```

### 2. Stream

```javascript
/**
 * Node.js
 */

const fs = require('fs');

// 
const readStream = fs.createReadStream('large-file.txt', {
  encoding: 'utf8',
  highWaterMark: 64 * 1024 // 64KB
});

readStream.on('data', (chunk) => {
  console.log(':', chunk.length);
});

readStream.on('end', () => {
  console.log('');
});

// 
const writeStream = fs.createWriteStream('output.txt');

writeStream.write('Hello\n');
writeStream.write('World\n');
writeStream.end();

// 
readStream.pipe(writeStream);

// 
const { Readable } = require('stream');

class MyReadable extends Readable {
  constructor(data) {
    super();
    this.data = data;
    this.index = 0;
  }
  
  _read() {
    if (this.index < this.data.length) {
      this.push(this.data[this.index++]);
    } else {
      this.push(null); // 
    }
  }
}

const myStream = new MyReadable(['a', 'b', 'c']);
myStream.on('data', (chunk) => {
  console.log(chunk.toString());
});

// Transform
const { Transform } = require('stream');

class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
}

const upperCase = new UpperCaseTransform();
process.stdin.pipe(upperCase).pipe(process.stdout);
```

### 3. 

```javascript
/**
 * 
 */

const cluster = require('cluster');
const os = require('os');
const http = require('http');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  
  console.log(`Master ${process.pid} is running`);
  
  // 
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // 
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork(); // 
  });
  
  // 
  Object.values(cluster.workers).forEach(worker => {
    worker.send({ msg: 'Hello from master' });
  });
  
} else {
  // 
  const server = http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Worker ${process.pid} handled request`);
  });
  
  server.listen(8000);
  
  // 
  process.on('message', (msg) => {
    console.log('Worker received:', msg);
  });
  
  console.log(`Worker ${process.pid} started`);
}

// Child Process
const { spawn, exec, fork } = require('child_process');

// spawn
const ls = spawn('ls', ['-lh', '/usr']);
ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

// exec
exec('ls -lh /usr', (error, stdout, stderr) => {
  if (error) {
    console.error(`error: ${error}`);
    return;
  }
  console.log(`stdout: ${stdout}`);
});

// forkNode.js
const child = fork('child.js');
child.send({ hello: 'world' });
child.on('message', (msg) => {
  console.log('Message from child:', msg);
});
```

## 

### 1. MySQL

```sql
-- 
-- 1. B+
CREATE INDEX idx_name ON users(name);

-- 2. 
CREATE INDEX idx_email USING HASH ON users(email);

-- 3. 
CREATE FULLTEXT INDEX idx_content ON articles(content);

-- 4. 
CREATE SPATIAL INDEX idx_location ON places(location);

-- 
CREATE INDEX idx_name_age ON users(name, age);

-- 
SELECT * FROM users WHERE name = 'John';           -- 
SELECT * FROM users WHERE name = 'John' AND age = 25; -- 
SELECT * FROM users WHERE age = 25;                -- 

-- 
CREATE INDEX idx_name_age_email ON users(name, age, email);
SELECT name, age, email FROM users WHERE name = 'John'; -- 

-- 
-- 1. 
SELECT * FROM users WHERE name LIKE '%John%';  --  
SELECT * FROM users WHERE name LIKE 'John%';   --  

SELECT * FROM users WHERE age + 1 = 26;        --  
SELECT * FROM users WHERE age = 25;            -- 

-- 2. EXPLAIN
EXPLAIN SELECT * FROM users WHERE name = 'John';

-- 3. 
SELECT COUNT(DISTINCT name) / COUNT(*) FROM users; -- 1
```

### 2. 

```sql
-- ACID
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT; --  ROLLBACK

-- 
-- 1. READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 2. READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 3. REPEATABLE READMySQL
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 4. SERIALIZABLE
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 
-- 1. S
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

-- 2. X
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 3. 
UPDATE users SET name = 'John' WHERE id = 1; -- id=1

-- 4. 
LOCK TABLES users WRITE;
-- 
UNLOCK TABLES;

-- 
-- 1
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 2

-- 2
START TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
UPDATE accounts SET balance = balance + 50 WHERE id = 1;  -- 1

-- 
-- 1. 
-- 2. 
-- 3. 
```

### 3. Redis

```javascript
/**
 * Redis
 */

const redis = require('redis');
const client = redis.createClient();

// 1. String
await client.set('key', 'value');
await client.get('key');
await client.incr('counter');
await client.expire('key', 60); // 60

// 2. Hash
await client.hset('user:1', 'name', 'John');
await client.hset('user:1', 'age', '25');
await client.hgetall('user:1');

// 3. List
await client.lpush('queue', 'task1');
await client.rpush('queue', 'task2');
await client.lpop('queue');

// 4. Set
await client.sadd('tags', 'javascript');
await client.sadd('tags', 'nodejs');
await client.smembers('tags');

// 5. Sorted Set
await client.zadd('leaderboard', 100, 'player1');
await client.zadd('leaderboard', 200, 'player2');
await client.zrange('leaderboard', 0, -1, 'WITHSCORES');

// 
// 1. 
async function getUser(id) {
  const cached = await client.get(`user:${id}`);
  if (cached) return JSON.parse(cached);
  
  const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);
  await client.setex(`user:${id}`, 3600, JSON.stringify(user));
  
  return user;
}

// 2. 
async function acquireLock(key, ttl = 10000) {
  const lockKey = `lock:${key}`;
  const lockValue = `${Date.now()}-${Math.random()}`;
  
  const result = await client.set(lockKey, lockValue, 'PX', ttl, 'NX');
  return result === 'OK' ? lockValue : null;
}

// 3. 
async function rateLimit(userId, limit = 100, window = 60) {
  const key = `rate:${userId}`;
  const count = await client.incr(key);
  
  if (count === 1) {
    await client.expire(key, window);
  }
  
  return count <= limit;
}

// 4. 
const publisher = redis.createClient();
const subscriber = redis.createClient();

subscriber.subscribe('channel');
subscriber.on('message', (channel, message) => {
  console.log(`Received: ${message}`);
});

publisher.publish('channel', 'Hello');
```

## 

### 1. HTTP

```javascript
/**
 * HTTP
 */

// HTTP
const methods = {
  GET: '',
  POST: '',
  PUT: '',
  PATCH: '',
  DELETE: '',
  HEAD: '',
  OPTIONS: ''
};

// HTTP
const statusCodes = {
  // 1xx 
  100: 'Continue',
  101: 'Switching Protocols',
  
  // 2xx 
  200: 'OK',
  201: 'Created',
  204: 'No Content',
  
  // 3xx 
  301: 'Moved Permanently',
  302: 'Found',
  304: 'Not Modified',
  
  // 4xx 
  400: 'Bad Request',
  401: 'Unauthorized',
  403: 'Forbidden',
  404: 'Not Found',
  
  // 5xx 
  500: 'Internal Server Error',
  502: 'Bad Gateway',
  503: 'Service Unavailable'
};

// HTTP
const headers = {
  // 
  'Content-Type': 'application/json',
  'Authorization': 'Bearer token',
  'User-Agent': 'Mozilla/5.0',
  'Accept': 'application/json',
  'Cookie': 'session=abc123',
  
  // 
  'Content-Length': '1234',
  'Cache-Control': 'max-age=3600',
  'Set-Cookie': 'session=abc123; HttpOnly',
  'Access-Control-Allow-Origin': '*'
};

// HTTPS
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem')
};

https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('Secure connection');
}).listen(443);
```

### 2. WebSocket

```javascript
/**
 * WebSocket
 */

const WebSocket = require('ws');

// 
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('Client connected');
  
  ws.on('message', (message) => {
    console.log('Received:', message);
    
    // 
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  ws.on('close', () => {
    console.log('Client disconnected');
  });
  
  // 
  ws.isAlive = true;
  ws.on('pong', () => {
    ws.isAlive = true;
  });
});

// 
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) {
      return ws.terminate();
    }
    
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// 
const ws = new WebSocket('ws://localhost:8080');

ws.on('open', () => {
  console.log('Connected');
  ws.send('Hello Server');
});

ws.on('message', (data) => {
  console.log('Received:', data);
});
```

## 

### 1. 

```javascript
/**
 * 
 */

// 1. Cache-Aside
async function getData(key) {
  // 
  let data = await cache.get(key);
  
  if (!data) {
    // 
    data = await db.query(key);
    
    // 
    await cache.set(key, data, 3600);
  }
  
  return data;
}

async function updateData(key, value) {
  // 
  await db.update(key, value);
  
  // 
  await cache.del(key);
}

// 2. Read-Through
class CacheProxy {
  async get(key) {
    let data = await this.cache.get(key);
    
    if (!data) {
      data = await this.db.query(key);
      await this.cache.set(key, data);
    }
    
    return data;
  }
}

// 3. Write-Through
class CacheProxy {
  async set(key, value) {
    await this.cache.set(key, value);
    await this.db.update(key, value);
  }
}

// 4. Write-Behind
class CacheProxy {
  async set(key, value) {
    await this.cache.set(key, value);
    
    // 
    this.queue.push({ key, value });
  }
  
  async flush() {
    const batch = this.queue.splice(0, 100);
    await this.db.batchUpdate(batch);
  }
}

// 
// 1. 
async function getDataWithBloomFilter(key) {
  // 
  if (!bloomFilter.contains(key)) {
    return null;
  }
  
  let data = await cache.get(key);
  if (!data) {
    data = await db.query(key);
    if (data) {
      await cache.set(key, data);
    } else {
      // 
      await cache.set(key, null, 60);
    }
  }
  
  return data;
}

// 2. 
async function getDataWithMutex(key) {
  let data = await cache.get(key);
  
  if (!data) {
    // 
    const lock = await acquireLock(key);
    
    if (lock) {
      try {
        data = await db.query(key);
        await cache.set(key, data, 3600);
      } finally {
        await releaseLock(key, lock);
      }
    } else {
      // 
      await sleep(100);
      return getDataWithMutex(key);
    }
  }
  
  return data;
}

// 3. 
async function setDataWithRandomTTL(key, data) {
  const ttl = 3600 + Math.floor(Math.random() * 300); // 3600-3900
  await cache.set(key, data, ttl);
}
```

### 2. 

```javascript
/**
 * 
 */

// 1. 
class FixedWindowRateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.counter = 0;
    this.resetTime = Date.now() + window;
  }
  
  async allow() {
    const now = Date.now();
    
    if (now >= this.resetTime) {
      this.counter = 0;
      this.resetTime = now + this.window;
    }
    
    if (this.counter < this.limit) {
      this.counter++;
      return true;
    }
    
    return false;
  }
}

// 2. 
class SlidingWindowRateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.requests = [];
  }
  
  async allow() {
    const now = Date.now();
    
    // 
    this.requests = this.requests.filter(time => now - time < this.window);
    
    if (this.requests.length < this.limit) {
      this.requests.push(now);
      return true;
    }
    
    return false;
  }
}

// 3. 
class TokenBucketRateLimiter {
  constructor(capacity, refillRate) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate;
    this.lastRefill = Date.now();
  }
  
  async allow() {
    this.refill();
    
    if (this.tokens > 0) {
      this.tokens--;
      return true;
    }
    
    return false;
  }
  
  refill() {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    const tokensToAdd = (elapsed / 1000) * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// 4. 
class LeakyBucketRateLimiter {
  constructor(capacity, leakRate) {
    this.capacity = capacity;
    this.queue = [];
    this.leakRate = leakRate;
    
    setInterval(() => this.leak(), 1000 / leakRate);
  }
  
  async allow() {
    if (this.queue.length < this.capacity) {
      this.queue.push(Date.now());
      return true;
    }
    
    return false;
  }
  
  leak() {
    if (this.queue.length > 0) {
      this.queue.shift();
    }
  }
}
```

## 


-  **Node.js**Stream
-  ****Redis
-  ****HTTPWebSocketTCP/IP
-  ****
-  ****
-  ****

****

