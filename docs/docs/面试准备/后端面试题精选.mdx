---
sidebar_position: 2
title: åç«¯é¢è¯•é¢˜ç²¾é€‰
tags: [é¢è¯•, åç«¯, Node.js, æ•°æ®åº“, ç³»ç»Ÿè®¾è®¡]
---

# åç«¯é¢è¯•é¢˜ç²¾é€‰

æœ¬æ–‡ç²¾é€‰åç«¯é«˜é¢‘é¢è¯•é¢˜ï¼Œæ¶µç›–Node.jsã€æ•°æ®åº“ã€ç½‘ç»œç­‰æ ¸å¿ƒçŸ¥è¯†ç‚¹ã€‚

## Node.js

### 1. äº‹ä»¶å¾ªç¯

```javascript
/**
 * Node.jsäº‹ä»¶å¾ªç¯çš„6ä¸ªé˜¶æ®µ
 */

// æ‰§è¡Œé¡ºåºç¤ºä¾‹
console.log('1: åŒæ­¥ä»£ç ');

setTimeout(() => {
  console.log('2: setTimeout');
}, 0);

setImmediate(() => {
  console.log('3: setImmediate');
});

process.nextTick(() => {
  console.log('4: nextTick');
});

Promise.resolve().then(() => {
  console.log('5: Promise');
});

console.log('6: åŒæ­¥ä»£ç ');

// è¾“å‡ºé¡ºåºï¼š1 -> 6 -> 4 -> 5 -> 2 -> 3
// nextTick > Promiseå¾®ä»»åŠ¡ > setTimeout > setImmediate

// äº‹ä»¶å¾ªç¯é˜¶æ®µ
const phases = {
  timers: 'setTimeout/setIntervalå›è°ƒ',
  pending: 'I/Oå›è°ƒ',
  idle: 'å†…éƒ¨ä½¿ç”¨',
  poll: 'è½®è¯¢I/Oäº‹ä»¶',
  check: 'setImmediateå›è°ƒ',
  close: 'å…³é—­å›è°ƒ'
};
```

### 2. Streamæµ

```javascript
/**
 * Node.jsæµï¼šå¤„ç†å¤§æ–‡ä»¶çš„é«˜æ•ˆæ–¹å¼
 */

const fs = require('fs');

// å¯è¯»æµ
const readStream = fs.createReadStream('large-file.txt', {
  encoding: 'utf8',
  highWaterMark: 64 * 1024 // 64KB
});

readStream.on('data', (chunk) => {
  console.log('è¯»å–æ•°æ®:', chunk.length);
});

readStream.on('end', () => {
  console.log('è¯»å–å®Œæˆ');
});

// å¯å†™æµ
const writeStream = fs.createWriteStream('output.txt');

writeStream.write('Hello\n');
writeStream.write('World\n');
writeStream.end();

// ç®¡é“
readStream.pipe(writeStream);

// è‡ªå®šä¹‰å¯è¯»æµ
const { Readable } = require('stream');

class MyReadable extends Readable {
  constructor(data) {
    super();
    this.data = data;
    this.index = 0;
  }
  
  _read() {
    if (this.index < this.data.length) {
      this.push(this.data[this.index++]);
    } else {
      this.push(null); // ç»“æŸ
    }
  }
}

const myStream = new MyReadable(['a', 'b', 'c']);
myStream.on('data', (chunk) => {
  console.log(chunk.toString());
});

// Transformæµ
const { Transform } = require('stream');

class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
}

const upperCase = new UpperCaseTransform();
process.stdin.pipe(upperCase).pipe(process.stdout);
```

### 3. è¿›ç¨‹ä¸é›†ç¾¤

```javascript
/**
 * å¤šè¿›ç¨‹ä¸é›†ç¾¤
 */

const cluster = require('cluster');
const os = require('os');
const http = require('http');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  
  console.log(`Master ${process.pid} is running`);
  
  // åˆ›å»ºå·¥ä½œè¿›ç¨‹
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // ç›‘å¬å·¥ä½œè¿›ç¨‹é€€å‡º
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork(); // é‡å¯
  });
  
  // è¿›ç¨‹é—´é€šä¿¡
  Object.values(cluster.workers).forEach(worker => {
    worker.send({ msg: 'Hello from master' });
  });
  
} else {
  // å·¥ä½œè¿›ç¨‹
  const server = http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Worker ${process.pid} handled request`);
  });
  
  server.listen(8000);
  
  // æ¥æ”¶ä¸»è¿›ç¨‹æ¶ˆæ¯
  process.on('message', (msg) => {
    console.log('Worker received:', msg);
  });
  
  console.log(`Worker ${process.pid} started`);
}

// Child Process
const { spawn, exec, fork } = require('child_process');

// spawnï¼šæµå¼æ•°æ®
const ls = spawn('ls', ['-lh', '/usr']);
ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

// execï¼šç¼“å†²è¾“å‡º
exec('ls -lh /usr', (error, stdout, stderr) => {
  if (error) {
    console.error(`error: ${error}`);
    return;
  }
  console.log(`stdout: ${stdout}`);
});

// forkï¼šä¸“é—¨ç”¨äºNode.jsè„šæœ¬
const child = fork('child.js');
child.send({ hello: 'world' });
child.on('message', (msg) => {
  console.log('Message from child:', msg);
});
```

## æ•°æ®åº“

### 1. MySQLç´¢å¼•

```sql
-- ç´¢å¼•ç±»å‹
-- 1. B+æ ‘ç´¢å¼•ï¼ˆé»˜è®¤ï¼‰
CREATE INDEX idx_name ON users(name);

-- 2. å“ˆå¸Œç´¢å¼•
CREATE INDEX idx_email USING HASH ON users(email);

-- 3. å…¨æ–‡ç´¢å¼•
CREATE FULLTEXT INDEX idx_content ON articles(content);

-- 4. ç©ºé—´ç´¢å¼•
CREATE SPATIAL INDEX idx_location ON places(location);

-- è”åˆç´¢å¼•ï¼ˆæœ€å·¦å‰ç¼€åŸåˆ™ï¼‰
CREATE INDEX idx_name_age ON users(name, age);

-- å¯ä»¥ä½¿ç”¨çš„æŸ¥è¯¢
SELECT * FROM users WHERE name = 'John';           -- âœ“
SELECT * FROM users WHERE name = 'John' AND age = 25; -- âœ“
SELECT * FROM users WHERE age = 25;                -- âœ—

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_name_age_email ON users(name, age, email);
SELECT name, age, email FROM users WHERE name = 'John'; -- ä¸éœ€è¦å›è¡¨

-- ç´¢å¼•ä¼˜åŒ–
-- 1. é¿å…ç´¢å¼•å¤±æ•ˆ
SELECT * FROM users WHERE name LIKE '%John%';  -- âœ— å‰ç¼€æ¨¡ç³Š
SELECT * FROM users WHERE name LIKE 'John%';   -- âœ“ åç¼€æ¨¡ç³Š

SELECT * FROM users WHERE age + 1 = 26;        -- âœ— å‡½æ•°æ“ä½œ
SELECT * FROM users WHERE age = 25;            -- âœ“

-- 2. ä½¿ç”¨EXPLAINåˆ†æ
EXPLAIN SELECT * FROM users WHERE name = 'John';

-- 3. ç´¢å¼•é€‰æ‹©æ€§
SELECT COUNT(DISTINCT name) / COUNT(*) FROM users; -- è¶Šæ¥è¿‘1è¶Šå¥½
```

### 2. äº‹åŠ¡ä¸é”

```sql
-- äº‹åŠ¡ACIDç‰¹æ€§
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT; -- æˆ– ROLLBACK

-- éš”ç¦»çº§åˆ«
-- 1. READ UNCOMMITTEDï¼ˆè¯»æœªæäº¤ï¼‰
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 2. READ COMMITTEDï¼ˆè¯»å·²æäº¤ï¼‰
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 3. REPEATABLE READï¼ˆå¯é‡å¤è¯»ï¼ŒMySQLé»˜è®¤ï¼‰
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 4. SERIALIZABLEï¼ˆä¸²è¡ŒåŒ–ï¼‰
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- é”ç±»å‹
-- 1. å…±äº«é”ï¼ˆSé”ï¼‰
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

-- 2. æ’ä»–é”ï¼ˆXé”ï¼‰
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 3. è¡Œé”
UPDATE users SET name = 'John' WHERE id = 1; -- é”å®šid=1çš„è¡Œ

-- 4. è¡¨é”
LOCK TABLES users WRITE;
-- æ“ä½œ
UNLOCK TABLES;

-- æ­»é”ç¤ºä¾‹
-- äº‹åŠ¡1
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- ç­‰å¾…äº‹åŠ¡2

-- äº‹åŠ¡2
START TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
UPDATE accounts SET balance = balance + 50 WHERE id = 1;  -- ç­‰å¾…äº‹åŠ¡1ï¼Œæ­»é”ï¼

-- é¿å…æ­»é”
-- 1. æŒ‰ç›¸åŒé¡ºåºè®¿é—®èµ„æº
-- 2. ç¼©çŸ­äº‹åŠ¡æ—¶é—´
-- 3. ä½¿ç”¨è¾ƒä½çš„éš”ç¦»çº§åˆ«
```

### 3. Redis

```javascript
/**
 * Redisæ•°æ®ç»“æ„ä¸åº”ç”¨
 */

const redis = require('redis');
const client = redis.createClient();

// 1. String
await client.set('key', 'value');
await client.get('key');
await client.incr('counter');
await client.expire('key', 60); // 60ç§’è¿‡æœŸ

// 2. Hash
await client.hset('user:1', 'name', 'John');
await client.hset('user:1', 'age', '25');
await client.hgetall('user:1');

// 3. List
await client.lpush('queue', 'task1');
await client.rpush('queue', 'task2');
await client.lpop('queue');

// 4. Set
await client.sadd('tags', 'javascript');
await client.sadd('tags', 'nodejs');
await client.smembers('tags');

// 5. Sorted Set
await client.zadd('leaderboard', 100, 'player1');
await client.zadd('leaderboard', 200, 'player2');
await client.zrange('leaderboard', 0, -1, 'WITHSCORES');

// åº”ç”¨åœºæ™¯
// 1. ç¼“å­˜
async function getUser(id) {
  const cached = await client.get(`user:${id}`);
  if (cached) return JSON.parse(cached);
  
  const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);
  await client.setex(`user:${id}`, 3600, JSON.stringify(user));
  
  return user;
}

// 2. åˆ†å¸ƒå¼é”
async function acquireLock(key, ttl = 10000) {
  const lockKey = `lock:${key}`;
  const lockValue = `${Date.now()}-${Math.random()}`;
  
  const result = await client.set(lockKey, lockValue, 'PX', ttl, 'NX');
  return result === 'OK' ? lockValue : null;
}

// 3. é™æµ
async function rateLimit(userId, limit = 100, window = 60) {
  const key = `rate:${userId}`;
  const count = await client.incr(key);
  
  if (count === 1) {
    await client.expire(key, window);
  }
  
  return count <= limit;
}

// 4. å‘å¸ƒè®¢é˜…
const publisher = redis.createClient();
const subscriber = redis.createClient();

subscriber.subscribe('channel');
subscriber.on('message', (channel, message) => {
  console.log(`Received: ${message}`);
});

publisher.publish('channel', 'Hello');
```

## ç½‘ç»œåè®®

### 1. HTTP

```javascript
/**
 * HTTPåè®®
 */

// HTTPæ–¹æ³•
const methods = {
  GET: 'è·å–èµ„æº',
  POST: 'åˆ›å»ºèµ„æº',
  PUT: 'æ›´æ–°èµ„æºï¼ˆå®Œæ•´ï¼‰',
  PATCH: 'æ›´æ–°èµ„æºï¼ˆéƒ¨åˆ†ï¼‰',
  DELETE: 'åˆ é™¤èµ„æº',
  HEAD: 'è·å–å“åº”å¤´',
  OPTIONS: 'è·å–æ”¯æŒçš„æ–¹æ³•'
};

// HTTPçŠ¶æ€ç 
const statusCodes = {
  // 1xx ä¿¡æ¯
  100: 'Continue',
  101: 'Switching Protocols',
  
  // 2xx æˆåŠŸ
  200: 'OK',
  201: 'Created',
  204: 'No Content',
  
  // 3xx é‡å®šå‘
  301: 'Moved Permanently',
  302: 'Found',
  304: 'Not Modified',
  
  // 4xx å®¢æˆ·ç«¯é”™è¯¯
  400: 'Bad Request',
  401: 'Unauthorized',
  403: 'Forbidden',
  404: 'Not Found',
  
  // 5xx æœåŠ¡å™¨é”™è¯¯
  500: 'Internal Server Error',
  502: 'Bad Gateway',
  503: 'Service Unavailable'
};

// HTTPå¤´
const headers = {
  // è¯·æ±‚å¤´
  'Content-Type': 'application/json',
  'Authorization': 'Bearer token',
  'User-Agent': 'Mozilla/5.0',
  'Accept': 'application/json',
  'Cookie': 'session=abc123',
  
  // å“åº”å¤´
  'Content-Length': '1234',
  'Cache-Control': 'max-age=3600',
  'Set-Cookie': 'session=abc123; HttpOnly',
  'Access-Control-Allow-Origin': '*'
};

// HTTPS
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem')
};

https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('Secure connection');
}).listen(443);
```

### 2. WebSocket

```javascript
/**
 * WebSocketå®æ—¶é€šä¿¡
 */

const WebSocket = require('ws');

// æœåŠ¡ç«¯
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('Client connected');
  
  ws.on('message', (message) => {
    console.log('Received:', message);
    
    // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  ws.on('close', () => {
    console.log('Client disconnected');
  });
  
  // å¿ƒè·³æ£€æµ‹
  ws.isAlive = true;
  ws.on('pong', () => {
    ws.isAlive = true;
  });
});

// å¿ƒè·³æ£€æµ‹
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) {
      return ws.terminate();
    }
    
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// å®¢æˆ·ç«¯
const ws = new WebSocket('ws://localhost:8080');

ws.on('open', () => {
  console.log('Connected');
  ws.send('Hello Server');
});

ws.on('message', (data) => {
  console.log('Received:', data);
});
```

## ç³»ç»Ÿè®¾è®¡

### 1. ç¼“å­˜ç­–ç•¥

```javascript
/**
 * ç¼“å­˜ç­–ç•¥
 */

// 1. Cache-Asideï¼ˆæ—è·¯ç¼“å­˜ï¼‰
async function getData(key) {
  // å…ˆæŸ¥ç¼“å­˜
  let data = await cache.get(key);
  
  if (!data) {
    // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
    data = await db.query(key);
    
    // å†™å…¥ç¼“å­˜
    await cache.set(key, data, 3600);
  }
  
  return data;
}

async function updateData(key, value) {
  // å…ˆæ›´æ–°æ•°æ®åº“
  await db.update(key, value);
  
  // åˆ é™¤ç¼“å­˜
  await cache.del(key);
}

// 2. Read-Throughï¼ˆè¯»ç©¿é€ï¼‰
class CacheProxy {
  async get(key) {
    let data = await this.cache.get(key);
    
    if (!data) {
      data = await this.db.query(key);
      await this.cache.set(key, data);
    }
    
    return data;
  }
}

// 3. Write-Throughï¼ˆå†™ç©¿é€ï¼‰
class CacheProxy {
  async set(key, value) {
    await this.cache.set(key, value);
    await this.db.update(key, value);
  }
}

// 4. Write-Behindï¼ˆå†™å›ï¼‰
class CacheProxy {
  async set(key, value) {
    await this.cache.set(key, value);
    
    // å¼‚æ­¥å†™å…¥æ•°æ®åº“
    this.queue.push({ key, value });
  }
  
  async flush() {
    const batch = this.queue.splice(0, 100);
    await this.db.batchUpdate(batch);
  }
}

// ç¼“å­˜é—®é¢˜
// 1. ç¼“å­˜ç©¿é€ï¼šæŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®
async function getDataWithBloomFilter(key) {
  // å¸ƒéš†è¿‡æ»¤å™¨åˆ¤æ–­
  if (!bloomFilter.contains(key)) {
    return null;
  }
  
  let data = await cache.get(key);
  if (!data) {
    data = await db.query(key);
    if (data) {
      await cache.set(key, data);
    } else {
      // ç¼“å­˜ç©ºå€¼
      await cache.set(key, null, 60);
    }
  }
  
  return data;
}

// 2. ç¼“å­˜å‡»ç©¿ï¼šçƒ­ç‚¹æ•°æ®è¿‡æœŸ
async function getDataWithMutex(key) {
  let data = await cache.get(key);
  
  if (!data) {
    // è·å–äº’æ–¥é”
    const lock = await acquireLock(key);
    
    if (lock) {
      try {
        data = await db.query(key);
        await cache.set(key, data, 3600);
      } finally {
        await releaseLock(key, lock);
      }
    } else {
      // ç­‰å¾…åé‡è¯•
      await sleep(100);
      return getDataWithMutex(key);
    }
  }
  
  return data;
}

// 3. ç¼“å­˜é›ªå´©ï¼šå¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸ
async function setDataWithRandomTTL(key, data) {
  const ttl = 3600 + Math.floor(Math.random() * 300); // 3600-3900ç§’
  await cache.set(key, data, ttl);
}
```

### 2. é™æµç®—æ³•

```javascript
/**
 * é™æµç®—æ³•
 */

// 1. å›ºå®šçª—å£
class FixedWindowRateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.counter = 0;
    this.resetTime = Date.now() + window;
  }
  
  async allow() {
    const now = Date.now();
    
    if (now >= this.resetTime) {
      this.counter = 0;
      this.resetTime = now + this.window;
    }
    
    if (this.counter < this.limit) {
      this.counter++;
      return true;
    }
    
    return false;
  }
}

// 2. æ»‘åŠ¨çª—å£
class SlidingWindowRateLimiter {
  constructor(limit, window) {
    this.limit = limit;
    this.window = window;
    this.requests = [];
  }
  
  async allow() {
    const now = Date.now();
    
    // ç§»é™¤è¿‡æœŸè¯·æ±‚
    this.requests = this.requests.filter(time => now - time < this.window);
    
    if (this.requests.length < this.limit) {
      this.requests.push(now);
      return true;
    }
    
    return false;
  }
}

// 3. ä»¤ç‰Œæ¡¶
class TokenBucketRateLimiter {
  constructor(capacity, refillRate) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate;
    this.lastRefill = Date.now();
  }
  
  async allow() {
    this.refill();
    
    if (this.tokens > 0) {
      this.tokens--;
      return true;
    }
    
    return false;
  }
  
  refill() {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    const tokensToAdd = (elapsed / 1000) * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// 4. æ¼æ¡¶
class LeakyBucketRateLimiter {
  constructor(capacity, leakRate) {
    this.capacity = capacity;
    this.queue = [];
    this.leakRate = leakRate;
    
    setInterval(() => this.leak(), 1000 / leakRate);
  }
  
  async allow() {
    if (this.queue.length < this.capacity) {
      this.queue.push(Date.now());
      return true;
    }
    
    return false;
  }
  
  leak() {
    if (this.queue.length > 0) {
      this.queue.shift();
    }
  }
}
```

## æ€»ç»“

åç«¯é¢è¯•æ ¸å¿ƒï¼š
- ğŸ”„ **Node.js**ï¼šäº‹ä»¶å¾ªç¯ã€Streamã€é›†ç¾¤
- ğŸ’¾ **æ•°æ®åº“**ï¼šç´¢å¼•ã€äº‹åŠ¡ã€Redis
- ğŸŒ **ç½‘ç»œ**ï¼šHTTPã€WebSocketã€TCP/IP
- ğŸ—ï¸ **ç³»ç»Ÿè®¾è®¡**ï¼šç¼“å­˜ã€é™æµã€è´Ÿè½½å‡è¡¡
- ğŸ”’ **å®‰å…¨**ï¼šè®¤è¯ã€æˆæƒã€åŠ å¯†
- ğŸ“Š **æ€§èƒ½**ï¼šä¼˜åŒ–ã€ç›‘æ§ã€è°ƒä¼˜

è®°ä½ï¼š**ç†è§£åŸç†ï¼Œæ³¨é‡å®è·µï¼**

