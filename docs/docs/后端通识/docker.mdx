---
sidebarDepth: 4
---

# Docker

Docker是容器化技术的老大，能把应用和环境打包在一起，到哪都能跑。再也不用听"我电脑上能跑啊"这种话了。

## 核心概念

简单理解：
- **镜像（Image）**：应用的安装包，只读的
- **容器（Container）**：镜像跑起来就是容器，可以理解为一个轻量级虚拟机
- **仓库（Registry）**：放镜像的地方，类似GitHub但存的是镜像

## 镜像管理

```bash
# 查看本地镜像
docker images
docker image ls

# 搜索镜像
docker search nginx

# 拉取镜像
docker pull nginx
docker pull nginx:1.21  # 指定版本

# 删除镜像
docker rmi nginx
docker image rm nginx

# 查看镜像详情
docker inspect nginx

# 查看镜像历史
docker history nginx

# 导出/导入镜像
docker save nginx > nginx.tar
docker load < nginx.tar
```

## 容器管理

### 运行容器

```bash
# 基础运行
docker run nginx

# 后台运行
docker run -d nginx

# 端口映射
docker run -d -p 8080:80 nginx  # 主机8080 -> 容器80

# 命名容器
docker run -d --name my-nginx nginx

# 挂载目录
docker run -d -v /host/path:/container/path nginx

# 环境变量
docker run -d -e MYSQL_ROOT_PASSWORD=123456 mysql

# 交互式运行
docker run -it ubuntu /bin/bash

# 完整示例
docker run -d \
  --name my-app \
  -p 3000:3000 \
  -v $(pwd):/app \
  -e NODE_ENV=production \
  node:16
```

### 容器操作

```bash
# 查看容器
docker ps              # 运行中的容器
docker ps -a           # 所有容器

# 启动/停止/重启
docker start <container>
docker stop <container>
docker restart <container>

# 删除容器
docker rm <container>
docker rm -f <container>  # 强制删除运行中的容器

# 进入容器
docker exec -it <container> /bin/bash
docker attach <container>  # 不推荐，退出会停止容器

# 查看日志
docker logs <container>
docker logs -f <container>  # 实时查看
docker logs --tail 100 <container>  # 最后100行

# 查看容器详情
docker inspect <container>

# 查看容器资源占用
docker stats
docker stats <container>

# 复制文件
docker cp <container>:/path/to/file ./local/path
docker cp ./local/file <container>:/path/to/
```

## 构建镜像

### Dockerfile

```dockerfile
# 基础镜像
FROM node:16-alpine

# 设置工作目录
WORKDIR /app

# 复制文件
COPY package*.json ./

# 安装依赖
RUN npm install --production

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 3000

# 设置环境变量
ENV NODE_ENV=production

# 启动命令
CMD ["node", "server.js"]
```

### 构建和推送

```bash
# 构建镜像
docker build -t my-app:1.0 .
docker build -t my-app:latest .

# 查看构建历史
docker history my-app

# 标记镜像
docker tag my-app:1.0 username/my-app:1.0

# 登录 Docker Hub
docker login

# 推送镜像
docker push username/my-app:1.0

# 登出
docker logout
```

### Dockerfile 最佳实践

```dockerfile
# 使用轻量级基础镜像
FROM node:16-alpine

# 设置工作目录
WORKDIR /app

# 利用缓存，先复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 再复制应用代码
COPY . .

# 使用非 root 用户
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001
USER nodejs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD node healthcheck.js

# 启动命令
CMD ["node", "server.js"]
```

### .dockerignore

```
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.DS_Store
dist
coverage
```

## Docker Compose

Docker Compose 用于定义和运行多容器应用。

### docker-compose.yml

```yaml
version: '3.8'

services:
  # Web 应用
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=db
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  # 数据库
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root123
      - MYSQL_DATABASE=myapp
    volumes:
      - db-data:/var/lib/mysql
    ports:
      - "3306:3306"

  # Redis
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

  # Nginx
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

volumes:
  db-data:
```

### Compose 命令

```bash
# 启动所有服务
docker-compose up
docker-compose up -d  # 后台运行

# 停止所有服务
docker-compose down
docker-compose down -v  # 同时删除 volumes

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs
docker-compose logs -f web  # 实时查看 web 服务日志

# 重启服务
docker-compose restart
docker-compose restart web

# 构建镜像
docker-compose build
docker-compose build --no-cache

# 执行命令
docker-compose exec web npm install
docker-compose exec db mysql -u root -p

# 扩展服务
docker-compose up -d --scale web=3
```

## 实战场景

### Node.js 应用

```dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    volumes:
      - ./logs:/app/logs
```

### 前端应用（Nginx）

```dockerfile
# 多阶段构建
FROM node:16-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 生产镜像
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 全栈应用

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "3000:3000"
    environment:
      - DB_HOST=db
      - REDIS_HOST=redis
    depends_on:
      - db
      - redis

  db:
    image: postgres:14
    environment:
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=myapp
    volumes:
      - db-data:/var/lib/postgresql/data

  redis:
    image: redis:alpine

volumes:
  db-data:
```

## 数据持久化

### Volume

```bash
# 创建 volume
docker volume create my-data

# 查看 volumes
docker volume ls

# 查看 volume 详情
docker volume inspect my-data

# 删除 volume
docker volume rm my-data

# 清理未使用的 volumes
docker volume prune

# 使用 volume
docker run -d -v my-data:/app/data nginx
```

### Bind Mount

```bash
# 挂载主机目录
docker run -d -v /host/path:/container/path nginx
docker run -d -v $(pwd):/app node:16

# 只读挂载
docker run -d -v $(pwd):/app:ro nginx
```

## 网络

```bash
# 查看网络
docker network ls

# 创建网络
docker network create my-network

# 查看网络详情
docker network inspect my-network

# 删除网络
docker network rm my-network

# 容器连接到网络
docker network connect my-network my-container

# 运行时指定网络
docker run -d --network my-network nginx
```

## 清理和维护

```bash
# 清理停止的容器
docker container prune

# 清理未使用的镜像
docker image prune
docker image prune -a  # 清理所有未使用的镜像

# 清理未使用的 volumes
docker volume prune

# 清理未使用的网络
docker network prune

# 一键清理所有
docker system prune
docker system prune -a --volumes

# 查看磁盘占用
docker system df
```

## 常见问题

### 容器无法启动

```bash
# 查看容器日志
docker logs <container>

# 查看容器详情
docker inspect <container>

# 进入容器调试
docker exec -it <container> /bin/sh
```

### 端口被占用

```bash
# 查看端口占用
netstat -ano | findstr :3000  # Windows
lsof -i :3000                 # Linux/Mac

# 使用其他端口
docker run -d -p 3001:3000 my-app
```

### 镜像拉取慢

配置镜像加速器，或使用代理：

```bash
docker pull nginx --registry-mirror=https://xxx.mirror.aliyuncs.com
```

## 最佳实践

1. **使用轻量级基础镜像**：优先选择 alpine 版本
2. **利用构建缓存**：合理安排 Dockerfile 指令顺序
3. **多阶段构建**：减小最终镜像体积
4. **使用 .dockerignore**：排除不必要的文件
5. **不要在容器中存储数据**：使用 volume 持久化
6. **使用非 root 用户**：提高安全性
7. **设置健康检查**：及时发现问题
8. **限制资源使用**：防止容器占用过多资源

```bash
# 限制 CPU 和内存
docker run -d \
  --cpus=".5" \
  --memory="512m" \
  nginx
```

## 参考资源

- [Docker 官方文档](https://docs.docker.com/)
- [Docker Hub](https://hub.docker.com/)
- [Dockerfile 最佳实践](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
