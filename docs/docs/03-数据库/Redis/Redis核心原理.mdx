---
sidebar_position: 3
title: Redis
tags: [, Redis, , ]
---

# Redis

RedisRedis

## 

### 1. String

```bash
# 
SET key value
GET key
DEL key

# 
SET counter 0
INCR counter        # 1
INCRBY counter 10   # 11
DECR counter        # 10

# 
MSET key1 value1 key2 value2
MGET key1 key2

# 
SETEX key 3600 value  # 
EXPIRE key 3600       # 
TTL key              # 

# 
# 1. 
SET user:1:info '{"name":"John","age":30}'

# 2. 
INCR page:views
INCR user:1:followers

# 3. 
SET lock:order:123 uuid NX EX 30
```

### 2. Hash

```bash
# 
HSET user:1 name John
HSET user:1 age 30
HGET user:1 name
HGETALL user:1

# 
HMSET user:1 name John age 30 email john@example.com
HMGET user:1 name age

# 
HINCRBY user:1 age 1

# 
# 1. 
HMSET product:1 name iPhone price 999 stock 100

# 2. 
HSET cart:user:1 product:1 2
HSET cart:user:1 product:2 1
HGETALL cart:user:1
```

### 3. List

```bash
# 
LPUSH list value1    # 
RPUSH list value2    # 
LPOP list           # 
RPOP list           # 
LRANGE list 0 -1    # 

# 
BLPOP list 30       # 30

# 
# 1. 
LPUSH queue:tasks task1
BRPOP queue:tasks 0

# 2. 
LPUSH news:latest article1
LRANGE news:latest 0 9  # 10

# 3. 
LPUSH timeline:user:1 post1
LRANGE timeline:user:1 0 19  # 20
```

### 4. Set

```bash
# 
SADD set member1
SREM set member1
SMEMBERS set
SISMEMBER set member1

# 
SINTER set1 set2     # 
SUNION set1 set2     # 
SDIFF set1 set2      # 

# 
# 1. 
SADD user:1:tags tech music
SADD user:2:tags tech sports
SINTER user:1:tags user:2:tags  # 

# 2. 
SADD user:1:friends user:2 user:3
SADD user:2:friends user:1 user:4
SINTER user:1:friends user:2:friends  # 

# 3. 
SADD unique:visitors user:1
SCARD unique:visitors  # 
```

### 5. Sorted Set

```bash
# 
ZADD zset 100 member1
ZADD zset 200 member2
ZRANGE zset 0 -1 WITHSCORES
ZREVRANGE zset 0 -1  # 

# 
ZRANGEBYSCORE zset 100 200
ZCOUNT zset 100 200

# 
ZRANK zset member1
ZREVRANK zset member1

# 
# 1. 
ZADD leaderboard 1000 user:1
ZADD leaderboard 2000 user:2
ZREVRANGE leaderboard 0 9 WITHSCORES  # Top 10

# 2. 
ZADD delay:queue 1704067200 task1  # 
ZRANGEBYSCORE delay:queue 0 []  # 

# 3. 
ZINCRBY hot:articles 1 article:1
ZREVRANGE hot:articles 0 9  # Top 10
```

## 

### RDB

```bash
# 
save 900 1      # 9001key
save 300 10     # 30010key
save 60 10000   # 6010000key

# 
SAVE            # 
BGSAVE          # 

# RDB
dbfilename dump.rdb
dir /var/lib/redis

# 
# 1. 
# 2. 
# 3. fork

# 
# 1. 
# 2. fork
```

### AOF

```bash
# 
appendonly yes
appendfilename "appendonly.aof"

# 
appendfsync always      # 
appendfsync everysec    # 
appendfsync no          # OS

# AOF
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 
BGREWRITEAOF

# 
# 1. 
# 2. 
# 3. 

# 
# 1. 
# 2. 
# 3. 
```

### 

```bash
# Redis 4.0+
aof-use-rdb-preamble yes

# AOF = RDB + AOF
#  + 
```

## 

### 1. Cache-Aside

```javascript
class CacheAside {
  async get(key) {
    // 1. 
    let value = await redis.get(key);
    
    if (value) {
      return JSON.parse(value);
    }
    
    // 2. 
    value = await db.query(`SELECT * FROM users WHERE id = ?`, [key]);
    
    if (value) {
      // 3. 
      await redis.setex(key, 3600, JSON.stringify(value));
    }
    
    return value;
  }
  
  async update(key, value) {
    // 1. 
    await db.query(`UPDATE users SET ... WHERE id = ?`, [key]);
    
    // 2. 
    await redis.del(key);
  }
}
```

### 2. Read-Through

```javascript
class ReadThrough {
  async get(key) {
    // 
    return await cache.get(key, async () => {
      return await db.query(`SELECT * FROM users WHERE id = ?`, [key]);
    });
  }
}
```

### 3. Write-Through

```javascript
class WriteThrough {
  async update(key, value) {
    // 
    await Promise.all([
      redis.set(key, JSON.stringify(value)),
      db.query(`UPDATE users SET ... WHERE id = ?`, [key])
    ]);
  }
}
```

### 4. Write-Behind

```javascript
class WriteBehind {
  constructor() {
    this.writeQueue = [];
  }
  
  async update(key, value) {
    // 1. 
    await redis.set(key, JSON.stringify(value));
    
    // 2. 
    this.writeQueue.push({ key, value });
    
    if (this.writeQueue.length >= 100) {
      await this.flush();
    }
  }
  
  async flush() {
    const batch = this.writeQueue.splice(0, 100);
    
    // 
    await db.batchUpdate(batch);
  }
}
```

## 

### 1. 

```javascript
// 
// 1
class CachePenetration {
  async get(key) {
    let value = await redis.get(key);
    
    if (value === 'NULL') {
      return null;
    }
    
    if (value) {
      return JSON.parse(value);
    }
    
    value = await db.query(`SELECT * FROM users WHERE id = ?`, [key]);
    
    if (value) {
      await redis.setex(key, 3600, JSON.stringify(value));
    } else {
      // 
      await redis.setex(key, 60, 'NULL');
    }
    
    return value;
  }
}

// 2
class BloomFilter {
  constructor(size = 10000000, hashCount = 7) {
    this.size = size;
    this.hashCount = hashCount;
  }
  
  async add(key) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(key, i) % this.size;
      await redis.setbit('bloom:filter', hash, 1);
    }
  }
  
  async contains(key) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(key, i) % this.size;
      const bit = await redis.getbit('bloom:filter', hash);
      if (bit === 0) {
        return false;
      }
    }
    return true;
  }
  
  hash(key, seed) {
    let hash = seed;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash) + key.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

### 2. 

```javascript
// key
// 
class CacheBreakdown {
  async get(key) {
    let value = await redis.get(key);
    
    if (value) {
      return JSON.parse(value);
    }
    
    // 
    const lockKey = `lock:${key}`;
    const locked = await redis.set(lockKey, '1', 'NX', 'EX', 10);
    
    if (locked) {
      try {
        // 
        value = await redis.get(key);
        if (value) {
          return JSON.parse(value);
        }
        
        // 
        value = await db.query(`SELECT * FROM users WHERE id = ?`, [key]);
        
        if (value) {
          await redis.setex(key, 3600, JSON.stringify(value));
        }
        
        return value;
      } finally {
        await redis.del(lockKey);
      }
    } else {
      // 
      await new Promise(resolve => setTimeout(resolve, 50));
      return await this.get(key);
    }
  }
}
```

### 3. 

```javascript
// key
// 1
class CacheAvalanche {
  async set(key, value, ttl = 3600) {
    // Â±10%
    const randomTTL = ttl + Math.floor(Math.random() * ttl * 0.2 - ttl * 0.1);
    await redis.setex(key, randomTTL, JSON.stringify(value));
  }
}

// 2
class MultiLevelCache {
  async get(key) {
    // L1: 
    let value = localCache.get(key);
    if (value) return value;
    
    // L2: Redis
    value = await redis.get(key);
    if (value) {
      localCache.set(key, value, 60);
      return JSON.parse(value);
    }
    
    // L3: 
    value = await db.query(`SELECT * FROM users WHERE id = ?`, [key]);
    if (value) {
      await redis.setex(key, 3600, JSON.stringify(value));
      localCache.set(key, value, 60);
    }
    
    return value;
  }
}
```

## 

```javascript
class RedisLock {
  async acquire(key, ttl = 30) {
    const value = this.generateUUID();
    
    // SET key value NX EX ttl
    const result = await redis.set(
      `lock:${key}`,
      value,
      'NX',
      'EX',
      ttl
    );
    
    if (result === 'OK') {
      return value;
    }
    
    return null;
  }
  
  async release(key, value) {
    // Lua
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await redis.eval(script, 1, `lock:${key}`, value);
  }
  
  async withLock(key, callback, ttl = 30) {
    const lockValue = await this.acquire(key, ttl);
    
    if (!lockValue) {
      throw new Error('Failed to acquire lock');
    }
    
    try {
      return await callback();
    } finally {
      await this.release(key, lockValue);
    }
  }
  
  generateUUID() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 
const lock = new RedisLock();

await lock.withLock('order:123', async () => {
  // 
  const order = await getOrder(123);
  order.status = 'paid';
  await saveOrder(order);
});
```

## Redis

### 

```bash
# 
replicaof 127.0.0.1 6379
masterauth password

# 
INFO replication

# 
# 1. 
# 2. 
# 3. 

# 
# 1. SYNC
# 2. BGSAVE
# 3. RDB
# 4. 
# 5. RDB
```

### 

```bash
# 
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000

# 
# 1. 
# 2. 
# 3. 
# 4. 
```

### Cluster

```bash
# 
redis-cli --cluster create \
  127.0.0.1:7000 127.0.0.1:7001 \
  127.0.0.1:7002 127.0.0.1:7003 \
  127.0.0.1:7004 127.0.0.1:7005 \
  --cluster-replicas 1

# 
# 1. 16384
# 2. 
# 3. 

# 
# CRC16(key) % 16384

# 
# MOVED
# ASK
```

## 

```javascript
const optimizationTips = {
  // 1. Pipeline
  pipeline: async () => {
    const pipeline = redis.pipeline();
    for (let i = 0; i < 1000; i++) {
      pipeline.set(`key:${i}`, `value:${i}`);
    }
    await pipeline.exec();
  },
  
  // 2. 
  batch: async () => {
    await redis.mset('key1', 'value1', 'key2', 'value2');
    const values = await redis.mget('key1', 'key2');
  },
  
  // 3. key
  avoidBigKey: {
    problem: 'String > 10KB, List/Set/Hash > 5000',
    solution: 'key'
  },
  
  // 4. 
  expiration: async () => {
    await redis.setex('key', 3600, 'value');
  },
  
  // 5. 
  dataStructure: {
    counter: 'String + INCR',
    ranking: 'Sorted Set',
    uniqueCount: 'HyperLogLog',
    bitmap: 'Bitmap'
  }
};
```

## 

Redis
-  ****StringHashListSetSorted Set
-  ****RDB + AOF
-  ****Cache-AsideRead/Write-Through
-  ****
-  ****SET NX EX + Lua
-  ****Cluster

**Redis**

