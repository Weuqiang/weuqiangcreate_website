---
sidebar_position: 1
title: Node.jsæ·±å…¥å®è·µ
tags: [åç«¯, Node.js, Express, Koa, å¼‚æ­¥ç¼–ç¨‹]
---

# Node.jsæ·±å…¥å®è·µ

Node.jsæ˜¯åŸºäºChrome V8å¼•æ“çš„JavaScriptè¿è¡Œæ—¶ï¼Œæœ¬æ–‡å°†æ·±å…¥è®²è§£Node.jsçš„æ ¸å¿ƒåŸç†å’Œå®æˆ˜æŠ€å·§ã€‚

## Node.jsæ ¸å¿ƒæ¦‚å¿µ

### äº‹ä»¶å¾ªç¯

```javascript
const eventLoopPhases = {
  // äº‹ä»¶å¾ªç¯çš„6ä¸ªé˜¶æ®µ
  phases: {
    timers: {
      description: 'æ‰§è¡ŒsetTimeoutå’ŒsetIntervalçš„å›è°ƒ',
      example: 'setTimeout(() => console.log("timer"), 0)'
    },
    
    pendingCallbacks: {
      description: 'æ‰§è¡Œå»¶è¿Ÿåˆ°ä¸‹ä¸€ä¸ªå¾ªç¯è¿­ä»£çš„I/Oå›è°ƒ',
      example: 'TCPé”™è¯¯å›è°ƒ'
    },
    
    idle: {
      description: 'ä»…ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨',
      example: 'prepareé˜¶æ®µ'
    },
    
    poll: {
      description: 'æ£€ç´¢æ–°çš„I/Oäº‹ä»¶ï¼Œæ‰§è¡ŒI/Oå›è°ƒ',
      example: 'æ–‡ä»¶è¯»å–ã€ç½‘ç»œè¯·æ±‚'
    },
    
    check: {
      description: 'æ‰§è¡ŒsetImmediateå›è°ƒ',
      example: 'setImmediate(() => console.log("immediate"))'
    },
    
    closeCallbacks: {
      description: 'æ‰§è¡Œå…³é—­å›è°ƒ',
      example: 'socket.on("close", callback)'
    }
  }
};

// äº‹ä»¶å¾ªç¯ç¤ºä¾‹
console.log('1: åŒæ­¥ä»£ç ');

setTimeout(() => {
  console.log('2: setTimeout');
}, 0);

setImmediate(() => {
  console.log('3: setImmediate');
});

process.nextTick(() => {
  console.log('4: nextTick');
});

Promise.resolve().then(() => {
  console.log('5: Promise');
});

console.log('6: åŒæ­¥ä»£ç ');

// è¾“å‡ºé¡ºåºï¼š1 -> 6 -> 4 -> 5 -> 2 -> 3
// nextTick > Promise > setTimeout > setImmediate
```

### å¼‚æ­¥ç¼–ç¨‹

```javascript
// 1. å›è°ƒå‡½æ•°ï¼ˆCallbackï¼‰
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});

// å›è°ƒåœ°ç‹±
fs.readFile('file1.txt', (err, data1) => {
  if (err) return console.error(err);
  
  fs.readFile('file2.txt', (err, data2) => {
    if (err) return console.error(err);
    
    fs.readFile('file3.txt', (err, data3) => {
      if (err) return console.error(err);
      
      console.log(data1, data2, data3);
    });
  });
});

// 2. Promise
const readFilePromise = (filename) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
};

readFilePromise('file1.txt')
  .then(data1 => {
    console.log(data1);
    return readFilePromise('file2.txt');
  })
  .then(data2 => {
    console.log(data2);
    return readFilePromise('file3.txt');
  })
  .then(data3 => {
    console.log(data3);
  })
  .catch(err => console.error(err));

// 3. Async/Await
const fs_promises = require('fs').promises;

async function readFiles() {
  try {
    const data1 = await fs_promises.readFile('file1.txt', 'utf8');
    const data2 = await fs_promises.readFile('file2.txt', 'utf8');
    const data3 = await fs_promises.readFile('file3.txt', 'utf8');
    
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}

// å¹¶è¡Œæ‰§è¡Œ
async function readFilesParallel() {
  try {
    const [data1, data2, data3] = await Promise.all([
      fs_promises.readFile('file1.txt', 'utf8'),
      fs_promises.readFile('file2.txt', 'utf8'),
      fs_promises.readFile('file3.txt', 'utf8')
    ]);
    
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}
```

## Expressæ¡†æ¶

### åŸºç¡€åº”ç”¨

```javascript
const express = require('express');
const app = express();

// ä¸­é—´ä»¶
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// æ—¥å¿—ä¸­é—´ä»¶
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// è·¯ç”±
app.get('/', (req, res) => {
  res.json({ message: 'Hello World' });
});

app.get('/users/:id', (req, res) => {
  const { id } = req.params;
  res.json({ id, name: 'John' });
});

app.post('/users', (req, res) => {
  const { name, email } = req.body;
  res.status(201).json({ id: 1, name, email });
});

// é”™è¯¯å¤„ç†
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### RESTful API

```javascript
const express = require('express');
const router = express.Router();

// ç”¨æˆ·è·¯ç”±
class UserController {
  // GET /api/users
  async getUsers(req, res, next) {
    try {
      const { page = 1, pageSize = 20 } = req.query;
      
      const users = await User.find()
        .skip((page - 1) * pageSize)
        .limit(pageSize);
      
      const total = await User.countDocuments();
      
      res.json({
        data: users,
        pagination: {
          page: Number(page),
          pageSize: Number(pageSize),
          total,
          totalPages: Math.ceil(total / pageSize)
        }
      });
    } catch (err) {
      next(err);
    }
  }
  
  // GET /api/users/:id
  async getUser(req, res, next) {
    try {
      const { id } = req.params;
      const user = await User.findById(id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // POST /api/users
  async createUser(req, res, next) {
    try {
      const { name, email, password } = req.body;
      
      // éªŒè¯
      if (!name || !email || !password) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(409).json({ error: 'Email already exists' });
      }
      
      // åˆ›å»ºç”¨æˆ·
      const user = await User.create({
        name,
        email,
        password: await bcrypt.hash(password, 10)
      });
      
      res.status(201).json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // PUT /api/users/:id
  async updateUser(req, res, next) {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const user = await User.findByIdAndUpdate(
        id,
        updates,
        { new: true, runValidators: true }
      );
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // DELETE /api/users/:id
  async deleteUser(req, res, next) {
    try {
      const { id } = req.params;
      const user = await User.findByIdAndDelete(id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.status(204).send();
    } catch (err) {
      next(err);
    }
  }
}

const userController = new UserController();

router.get('/users', userController.getUsers);
router.get('/users/:id', userController.getUser);
router.post('/users', userController.createUser);
router.put('/users/:id', userController.updateUser);
router.delete('/users/:id', userController.deleteUser);

module.exports = router;
```

### ä¸­é—´ä»¶

```javascript
// è®¤è¯ä¸­é—´ä»¶
const jwt = require('jsonwebtoken');

function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
}

// æƒé™ä¸­é—´ä»¶
function requireRole(...roles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// é™æµä¸­é—´ä»¶
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100, // æœ€å¤š100ä¸ªè¯·æ±‚
  message: 'Too many requests'
});

// éªŒè¯ä¸­é—´ä»¶
const { body, validationResult } = require('express-validator');

const validateUser = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }),
  body('name').trim().notEmpty(),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  }
];

// ä½¿ç”¨ä¸­é—´ä»¶
app.post('/api/users',
  limiter,
  validateUser,
  authMiddleware,
  requireRole('admin'),
  userController.createUser
);
```

## Koaæ¡†æ¶

### åŸºç¡€åº”ç”¨

```javascript
const Koa = require('koa');
const Router = require('@koa/router');
const bodyParser = require('koa-bodyparser');

const app = new Koa();
const router = new Router();

// ä¸­é—´ä»¶
app.use(bodyParser());

// æ—¥å¿—ä¸­é—´ä»¶
app.use(async (ctx, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});

// é”™è¯¯å¤„ç†
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    ctx.status = err.status || 500;
    ctx.body = {
      error: err.message
    };
    ctx.app.emit('error', err, ctx);
  }
});

// è·¯ç”±
router.get('/', async (ctx) => {
  ctx.body = { message: 'Hello World' };
});

router.get('/users/:id', async (ctx) => {
  const { id } = ctx.params;
  ctx.body = { id, name: 'John' };
});

router.post('/users', async (ctx) => {
  const { name, email } = ctx.request.body;
  ctx.status = 201;
  ctx.body = { id: 1, name, email };
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### æ´‹è‘±æ¨¡å‹

```javascript
// Koaçš„æ´‹è‘±æ¨¡å‹
app.use(async (ctx, next) => {
  console.log('1: è¿›å…¥ä¸­é—´ä»¶1');
  await next();
  console.log('6: ç¦»å¼€ä¸­é—´ä»¶1');
});

app.use(async (ctx, next) => {
  console.log('2: è¿›å…¥ä¸­é—´ä»¶2');
  await next();
  console.log('5: ç¦»å¼€ä¸­é—´ä»¶2');
});

app.use(async (ctx, next) => {
  console.log('3: è¿›å…¥ä¸­é—´ä»¶3');
  ctx.body = 'Hello';
  console.log('4: ç¦»å¼€ä¸­é—´ä»¶3');
});

// è¾“å‡ºé¡ºåºï¼š1 -> 2 -> 3 -> 4 -> 5 -> 6

// è‡ªå®šä¹‰ä¸­é—´ä»¶
function logger() {
  return async (ctx, next) => {
    const start = Date.now();
    await next();
    const ms = Date.now() - start;
    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
  };
}

function errorHandler() {
  return async (ctx, next) => {
    try {
      await next();
    } catch (err) {
      ctx.status = err.status || 500;
      ctx.body = { error: err.message };
    }
  };
}

app.use(errorHandler());
app.use(logger());
```

## æ•°æ®åº“æ“ä½œ

### MongoDB + Mongoose

```javascript
const mongoose = require('mongoose');

// è¿æ¥æ•°æ®åº“
mongoose.connect('mongodb://localhost/myapp', {
  useNewUrlParser: true,
  useUnifiedTopology: true
});

// å®šä¹‰Schema
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// ä¸­é—´ä»¶
userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

// å®ä¾‹æ–¹æ³•
userSchema.methods.comparePassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

// é™æ€æ–¹æ³•
userSchema.statics.findByEmail = function(email) {
  return this.findOne({ email });
};

const User = mongoose.model('User', userSchema);

// ä½¿ç”¨
async function createUser() {
  const user = new User({
    name: 'John',
    email: 'john@example.com',
    password: 'password123'
  });
  
  await user.save();
}

async function findUsers() {
  const users = await User.find({ role: 'user' })
    .select('name email')
    .limit(10)
    .sort({ createdAt: -1 });
  
  return users;
}
```

### MySQL + Sequelize

```javascript
const { Sequelize, DataTypes } = require('sequelize');

// è¿æ¥æ•°æ®åº“
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'mysql',
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

// å®šä¹‰æ¨¡å‹
const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false
  }
}, {
  timestamps: true,
  hooks: {
    beforeCreate: async (user) => {
      user.password = await bcrypt.hash(user.password, 10);
    }
  }
});

// å…³è”
const Post = sequelize.define('Post', {
  title: DataTypes.STRING,
  content: DataTypes.TEXT
});

User.hasMany(Post);
Post.belongsTo(User);

// åŒæ­¥æ•°æ®åº“
await sequelize.sync({ force: false });

// ä½¿ç”¨
async function createUser() {
  const user = await User.create({
    name: 'John',
    email: 'john@example.com',
    password: 'password123'
  });
  
  return user;
}

async function findUsers() {
  const users = await User.findAll({
    where: {
      role: 'user'
    },
    attributes: ['id', 'name', 'email'],
    include: [{
      model: Post,
      attributes: ['title']
    }],
    limit: 10,
    order: [['createdAt', 'DESC']]
  });
  
  return users;
}
```

## æ–‡ä»¶ä¸Šä¼ 

```javascript
const multer = require('multer');
const path = require('path');

// é…ç½®å­˜å‚¨
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// æ–‡ä»¶è¿‡æ»¤
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (extname && mimetype) {
    cb(null, true);
  } else {
    cb(new Error('Only images are allowed'));
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
});

// å•æ–‡ä»¶ä¸Šä¼ 
app.post('/upload', upload.single('file'), (req, res) => {
  res.json({
    filename: req.file.filename,
    path: req.file.path,
    size: req.file.size
  });
});

// å¤šæ–‡ä»¶ä¸Šä¼ 
app.post('/upload-multiple', upload.array('files', 10), (req, res) => {
  res.json({
    files: req.files.map(file => ({
      filename: file.filename,
      path: file.path,
      size: file.size
    }))
  });
});
```

## WebSocket

```javascript
const WebSocket = require('ws');
const http = require('http');
const express = require('express');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// WebSocketè¿æ¥
wss.on('connection', (ws, req) => {
  console.log('Client connected');
  
  // æ¥æ”¶æ¶ˆæ¯
  ws.on('message', (message) => {
    console.log('Received:', message);
    
    // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  // æ–­å¼€è¿æ¥
  ws.on('close', () => {
    console.log('Client disconnected');
  });
  
  // é”™è¯¯å¤„ç†
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
  
  // å‘é€æ¬¢è¿æ¶ˆæ¯
  ws.send(JSON.stringify({ type: 'welcome', message: 'Connected to server' }));
});

// å¿ƒè·³æ£€æµ‹
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (ws.isAlive === false) {
      return ws.terminate();
    }
    
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

## æ€§èƒ½ä¼˜åŒ–

```javascript
// 1. ä½¿ç”¨é›†ç¾¤
const cluster = require('cluster');
const os = require('os');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork();
  });
} else {
  // Workerè¿›ç¨‹
  const app = express();
  // ... åº”ç”¨ä»£ç 
  app.listen(3000);
}

// 2. ä½¿ç”¨ç¼“å­˜
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 });

app.get('/api/users/:id', async (req, res) => {
  const { id } = req.params;
  
  // æ£€æŸ¥ç¼“å­˜
  const cached = cache.get(`user:${id}`);
  if (cached) {
    return res.json(cached);
  }
  
  // æŸ¥è¯¢æ•°æ®åº“
  const user = await User.findById(id);
  
  // å†™å…¥ç¼“å­˜
  cache.set(`user:${id}`, user);
  
  res.json(user);
});

// 3. å‹ç¼©å“åº”
const compression = require('compression');
app.use(compression());

// 4. ä½¿ç”¨æµ
const fs = require('fs');

app.get('/download', (req, res) => {
  const stream = fs.createReadStream('large-file.txt');
  stream.pipe(res);
});
```

## æ€»ç»“

Node.jså¼€å‘çš„æ ¸å¿ƒï¼š
- âš¡ **äº‹ä»¶å¾ªç¯**ï¼šç†è§£å¼‚æ­¥æœºåˆ¶
- ğŸš€ **å¼‚æ­¥ç¼–ç¨‹**ï¼šCallbackã€Promiseã€Async/Await
- ğŸ› ï¸ **æ¡†æ¶é€‰æ‹©**ï¼šExpressã€Koa
- ğŸ’¾ **æ•°æ®åº“**ï¼šMongoDBã€MySQL
- ğŸ“ **æ–‡ä»¶å¤„ç†**ï¼šä¸Šä¼ ã€ä¸‹è½½ã€æµ
- ğŸ”Œ **å®æ—¶é€šä¿¡**ï¼šWebSocket
- ğŸ¯ **æ€§èƒ½ä¼˜åŒ–**ï¼šé›†ç¾¤ã€ç¼“å­˜ã€å‹ç¼©

è®°ä½ï¼š**Node.jsé€‚åˆI/Oå¯†é›†å‹åº”ç”¨ï¼Œä¸é€‚åˆCPUå¯†é›†å‹ï¼**

