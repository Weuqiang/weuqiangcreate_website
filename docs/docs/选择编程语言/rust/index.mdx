# 

## 

`const`

``` rust
const HP: u32 = 100;
const PI: f32 = 3.14;
const N: u32 = 1 + 1;
```

``` rust
// error[E0015]: cannot call non-const fn `test` in constants
const hp: u32 = test();

fn test() -> u32 {
    return 200
}
```



## 

`let`immutable`let mut`mutable

``` rust
let mut mp: u32 = 100;
mp = 200; // ok

let hp: u32 = 100;
hp = 200; // error
```

### shadow

`let``shadow`JavaScript

``` javascript
function main() {
	  const { data } = test()
    const data2 = test2(data)
    return {
    	data: data2
    }
}

// 
function main() {
   const { data } = test()
    const data = test2(data)
    return {
    	data // 
    }
}
```

``` rust
let hp: u32 = 100;
let hp: f32 = 100.12;
println!("{}", hp) // 100.12
```





## 

``` rust
fn main() -> u32 {
    return 200
}
```



## 

### statement





### expression

AST`x + 1`

`1 + 1`Rust`if``loop``match``switch`

``` rust
let value = {
    let x = 1;
    x + 1
};
println!("{:?}", value) // 2
```

``` rust
let value = {};
println!("{:?}", value) // ()
```

## 

### if expression

Rust

``` rust
if 2 > 1 { // 

} else if 3 > 2 {

} else {

}
```

``` rust
let condition = true;
let number = if condition { 5 } else { 6 };

println!("The value of number is: {number}");
```



### loop expression

`loop``break``break``loop`

``` rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}"); // 20
}
```

#### loop label

`loop``loop``break``loop`

``` rust
fn main() {
  'test: loop {
    loop {
      break 'test;
    }
  }
}
```



### while

``` rust
fn main() {
  while true {
    // do somethign
  }
}
```



### for...in

JavaScriptkeyRust`for...in`

``` rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}

```

``` rust
fn main() {
    for number in (1..4).rev() { // (1..4)Range
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```



## 

### scalar

- 
  - `i32``i64`
  - `u32``u64`
- 
  - `f32``f64`
- 
  - `let value: bool = true;`
- 
  - `let c: char = 'a';`



### compound



#### 



``` rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
  let a = tup.0;
  let b = tup.1;
  let c = tup.2;
  let (x, y, z) = tup;
}

```



#### 

JavaScript

``` rust
fn main() {
    let q = [1, 2, 3, 4, 5];
    let w: [i32; 5] = [1, 2, 3, 4, 5];
    let e = [3; 5]; // [3, 3, 3, 3, 3]
  	let x = q[0];
  	let y = q[1];
}
```





## Struct

### impl

`impl``self``associted function`

``` rust
struct People {
    name: String,
    age: u32,
    male: bool,
}

impl People {
    fn is_male(&self) -> bool {
        self.male
    }

    fn is_young(&self) -> bool {
        self.age < 20
    }

    fn new(name: String, age: u32, male: bool) -> People {
        People {
            name,
            age,
            male,
        }
    }
}

fn main() {
   let p = People::new(String::from("akara"), 20, true);

   let is_male = p.is_male();
   let is_young = p.is_young();

   println!("{}, {}, {}", p.name, is_male, is_young);
}
```

### struct update syntax

`spread syntax`Rust`..`

``` rust
let p3 = People {
    age: 30,
    ..p2 // 
};
println!("{}, {}", p1.is_male(), p3.age)
```

### tuple struct

``` rust
struct Point(i32, i32, i32);

let p = Point(1, 1, 0);
let People(x, y, z) = p;
let a = p.0;
```

### unit-like struct

``` rust
struct Point;

let p = Point;
```



## Enum

Rust`enum``struct``enum Days``variants``unit-like struct``tuple struct``struct``Days`



``` rust
enum Days {
    One,
    Two(u32),
    Three(bool, bool),
  	Four {
        x: i32,
        y: i32,
  	}
}

fn main() {
    let num = test(Days::Two(20));
    println!("{}", num);
}


fn test(e: Days) -> u32 {
    match e {
        Days::One => (),
        Days::Two(num) => {
            num
        },
      	Days::Three(a, b) => (),
      	Days::Four { x, y } => (),
        _ => (),
    }
}
```



### `Option<T>`

Rust`Option<T>`

``` rust
enum Option<T> {
    None,
    Some(T),
}
```

``` rust
fn main() {
    let a = test(Option::Some(20));
    println!("{}", a)
}

fn test(o: Option<u32>) -> u32 {
    match o {
        None => 0,
        Some(value) => {
            value
        }
    }
}
```

### match expression

Rust`match``switch``pattern match ``wildcards`

`match`



### If let

Rust`match``if let`

``` rust
fn main() {
    let a = test(Option::Some(20));
    let b = test(Option::None);
    println!("{}, {}", a, b)
}


fn test(o: Option<u32>) -> u32 {
    if let Some(value) = o { // 
        value
    } else {
        0
    }
}
```









## Ownership

> - Each value in Rust has an *owner*.
> - There can only be one owner at a time.
> - When the owner goes out of scope, the value will be dropped.

CC++GoJavaJavaScriptGC“”GC

Rust****

1. Rust****`Rc<RefCell<Box<String>>>`Drop

2. ****Rust**Move****Move****Copy****Clone**

3. Drop TraitDrop

   1. `immutable``immutable`

   2. `mutable``immutable/mutable`

   3. `mutable``mutable``immutable`

   4. 

      ``` rust
      // ok
      let p = Box::new(String::from("hi"));
      let p2 = p;
      
      // ok
      let p = Box::new(String::from("hi"));
      let p2 = *p;
      
      // error
      let mut p = Box::new(String::from("hi"));
      let p2 = &mut p;
      let p3 = **p2; // cannot move out of `**p2` which is behind a mutable reference move occurs because `**p2` has type `String`, which does not implement the `Copy` trait
      ```

   `borrow``borrow`

   ``` rust
   let mut a = Rc::new(RefCell::new(Box::new(String::from("akara"))));
           
   let b = &*a;
   				- immutable borrow occurs here
   let c = &mut a;
   				^^^^^^ mutable borrow occurs here
   b;
   - immutable borrow later used here
   ```





### Move

`String``ptr``len``capacity``String`JavaScriptRust

``` rust
let s = String::from("akara");
let s2 = s;

println!("{:?}", s); // 
```

******Move****Copy****Move**`Copy Trait`**Copy**

**Move**`let s2 = s``s``ptr``len``capacity``s2``s``s``s`







### Copy

Move`Copy Trait`CopyCopy

`Copy Trait``Copy Trait``Copy Trait`

`Copy Trait``Copy Trait``Copy Trait`

``` rust
let tuple = (1, 2);
let tuple2 = tuple;

println!("{:?}", tuple); // ok
```

``` rust
let tuple = (1, 2, String::from("akara"));
let tuple2 = tuple;

println!("{:?}", tuple); // error
```





### Clone

MoveCopy`Copy Trait``Clone Trait``clone`

``` rust
let s = String::from("akara");
let ss = s.clone();
```



### borrow

RustMove

``` rust
fn main() {
    let A = String::from("hello");

    let B = test(A);
  	B.as_bytes();
}

fn test(C: String) -> String {
    println!("{:?}", C.as_bytes());
    C
}
```

Rust****

``` rust
let A: String = String::from("hello");
let B: &String = &A;
```

`&A``&`ABBA`borrow`

`immutable``&mut``mutable`

``` rust
let mut A: String = String::from("hello");
let B = &mut A;
B.push_str(" world");
println!("{:?}", A);
```



### LifeTimes

`borrow`

RustOwnerRustBorrow CheckerBorrow Checker

`s``s``r``s``r`

``` rust
fn main() {
    let r;
    {
        let s = String::from("hello");
        r = &s; // 
    }
    r.as_bytes();
}
```



### Generic Lifetimes Parameter

Rust`type parameter``T``lifetimes parameter``'a``T``'a`

RustBorrow Checker`longest``longest`Borrow Checker`longest``lifetimes parameter`

``` rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str { // 
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

``` rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { // 
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```





### Static Lifetimes

``` rust
let s: &str = "hello world"
```

`'static`











## Smart Pointers

`Deref``Drop`TraitStringVecHashMapBoxRcRefCell



### *Deref*

`&``*`

``` rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

`Deref Trait`

``` rust
let a = Rc::new(Box::new(String::from("akara")));
let b: &String = &**a;
```

#### Implicit Deref Coercions



``` rust
fn test(name: &str) {}

fn main() {
  let a = Rc::new(Box::new(String::from("akara")));
  test(&a); // 1
  a.as_bytes() // 2
}
```





### *Drop*

Drop Trait

``` rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}
```



### `Box<T>`



``` rust
let ptr = Box::new(100);
```



### `Rc<T>`

`Rc<T>`

``` rust
let ptr = Rc::new(Box::new(100));
let ptr2 = Rc::clone(&ptr);

assert_eq!(**ptr2, 100);
```

`Rc<T>`Owner

``` rust
let ptr = Rc::new(Box::new(100));
*ptr = Box::new(200)
// cannot assign to data in an `Rc` trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Rc<Box<i32>>`
```





### `RefCell<T>`

`RefCell<T>`*Interior mutability*`unsafe`Rust`immutable``RefCell`



****

``` rust
let ptr = Box::new(RefCell::new(100)); // mut
let mut ptr2 = ptr.borrow_mut();
*ptr2 = 200;

assert_eq!(200, *ptr2);
```



****

`Rc<T>``immutable``RefCell``Arc<T>``Mutex<T>`

``` rust
let ptr1 = Rc::new(RefCell::new(People {
		age: 100
}));
let ptr2 = Rc::clone(&ptr1);
(*ptr1.borrow_mut()).age = 300;

assert_eq!(300, ptr2.borrow().age);
```





## Collections

### Vector

`Vec``Vec`

``` rust
fn main() {
  let mut value: Vec<i32> = Vec::new();
  value.push(1);
  value.push(2);

  let mut value2 = vec![1, 2, 3]; // macro

  let a: &mut i32 = &mut value2[0];
  *a = 4;
  println!("{}", a);

  let b: Option<&i32> = value2.get(1);
  if let Some(x) = b {
      println!("{}", x);
  }



  for i in &mut value2 {
      *i = 20;
      println!("{}", i);
  }

  // ---


  fn largest(list: &[i32]) -> i32 {
      let mut largest = list[0];

      for &item in list { // 18,
          if item > largest {
              largest = item;
          }
      }

      largest
  }
}
```

#### 

``` rust
push pop insert remove clear append split_off retain truncate drain 
```









### String

`String`

``` rust
fn main() {
  let mut s = String::from("hello");
  s.push_str(" world");
  s.push('!'); // char
  println!("{}", s); 
}

```



### HashMap

`Vec``String``HashMap``preclude``use`

``` rust
use std::collections::HashMap;

fn main() {
  let mut scores = HashMap::new();
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Yellow"), 50);

  for (key, value) in &scores {
      println!("{}: {}", key, value);
  }
}

```



### Range

``` rust
use core::ops::Range;

let v: Vec<i32> = (1..4).into_iter().map( |x| x * x).collect();
```



## iteration

*Vector*`.iter()``.into_iter()`*Iterator**trait*`next`

- `.iter()`

- `.iter_mut()`
- `.into_iter()`





### *consuming adaptors*

`next`*consuming adaptor*`sum`

``` rust
fn main() {
    let v = vec![1, 2, 3];
    let sum: u32 = v.iter().sum();
    println!("{}", sum);
}
```





### *Iterator adaptors*

*iterator adaptor*`map`

``` rust
fn main() {
    let v = vec![1, 2, 3];
    let sum: u32 = v.iter().map(|x| 2 * x).sum();
    println!("{}", sum);
}
```

https://stackoverflow.com/questions/65766866/why-the-closure-passed-to-map-does-not-take-a-reference-while-the-one-passed-t 



## Generic

Rust

``` rust
struct People<K, V> {
    k: K,
    v: V,
}

impl People<u32, u32> {
    fn test1(&self) {} 
}

impl<K> People<K, bool> {
    fn test2(&self) {} 
}

impl<K, V> People<K, V> {
    fn test3(&self) {} 
}

pub fn main() {
		let p = People { k: 1, v: 1 };
    p.test1();
		p.test2(); // error
    p.test3();

    let p2 = People { k: true, v: false };
    p2.test1(); // error
    p2.test2();
    p2.test3();
}
```









### 

RustRust***monomorphization***

``` rust
enum Option<T> {
  Some(T);
  None;
}

fn main() {
		let integer = Some(5);
		let float = Some(5.0);
}
```

***static dispatch***

``` rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```



1. 
2. 





## Trait

RustTraitTraitJavaInterface

``` rust
struct People {
    name: String,
}

trait Test {
    fn run(&self) { // 
        println!("run") 
    } 
    fn get_name(&self) -> &str;
}

impl Test for People {
    fn get_name(&self) -> &str {
        &self.name
    }
}

fn main() {
    let p = People {
        name: String::from("akara"),
    };
    p.run();
    println!("{}", p.get_name());
}
```



### Trait Bound

TypeScript`extends`Rust*Trait Bound*T*Summary**Trait*

``` rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}

// 
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

*Trait*

``` rust
pub fn notify<T: Summary + Display>(item: &T);
  
pub fn notify(item: &(impl Summary + Display));
```

Trait Boundwhere

``` rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
  
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```



### Trait Object

Rust*heterogeneous*

``` rust
struct Dog {
    age: u32,
}

struct Cat {
    age: u32,
}

trait Run {}
impl Run for Dog {}
impl Run for Cat {}

fn main() {
    test(vec![Dog { age: 10 }, Cat { age: 5 }]) // mismatched types expected struct `Dog`, found struct `Cat`
}

fn test<T: Run>(a: Vec<T>) {}
```

Trait ObjectDSTDynamically Sized TypeTrait Object



### Trait Associated Type

``` rust
struct People<K, V> {
    k: K,
    v: V,
}

pub trait Skill {
    type Item;

    fn fire_ball(&self, hp: Self::Item, mp: Self::Item) {}
    fn water_ball(&self, hp: Self::Item, mp: Self::Item) -> Self::Item;

} 

impl<K> Skill for People<K, u32> {
    type Item = u32;
    fn fire_ball(&self, hp: Self::Item, mp: Self::Item) {}
    fn water_ball(&self, hp: Self::Item, mp: Self::Item) -> Self::Item {
        self.v
    }
}
```

**Trait Generic**Trait Generic

``` rust
struct People<K, V> {
    k: K,
    v: V,
}

pub trait Skill<Item> {
    fn fire_ball(&self, hp: Item, mp: Item) {}
    fn water_ball(&self, hp:Item, mp: Item) -> Item;
} 

impl<K, V: Copy> Skill<V> for People<K, V> {
    fn fire_ball(&self, hp: V, mp: V) {}
    fn water_ball(&self, hp: V, mp: V) -> V {
        self.v
    }
}

pub fn main() {
		let p = People { k: 1, v: 2 };
  	let p2 = p.water_ball(100, 200);
}
```



### SuperTrait

TraitTraitTraitTraitTraitTraitTraitTrait Bounding

``` rust
trait Skill: Copy + Clone {}

// 
trait Skill where Self: Copy + Clone {}
```













## Dynamically Sized Type

Rust**Dynamically Sized TypeDST**Unsized Type**Slice****Trait Object******



### Slice

StringVec`[T]``&[T]`

``` rust
let v1 = vec![1, 2, 3, 4];
let v2: &[i32] = &v1[..]; // slice

let a1 = [1, 2, 3, 4];
let a2: &[i32] = &a1[..]; // slice
```

String`[String]``str`String`&str`

``` rust
let s1 = String::from("hello");
let s2: &str = &s1[..];
```

`&str`





### Trait Object

Trait Object

`dyn TraitA`Trait ObjectTrait ObjectDST`&dyn TraitA``Box<dyn myTrait>`

``` rust
trait Run {}

struct Dog {
    age: u32,
}

struct Cat {
    age: u32,
}

impl Run for Dog {}

impl Run for Cat {}

fn main() {
    test2(vec![&Dog { age: 20 }, &Cat { age: 10 }]);
    test3(vec![Box::new(Dog { age: 20 }), Box::new(Cat { age: 10 })]);
}

fn test2(v: Vec<&dyn Run>) {}
fn test3(v: Vec<Box<dyn Run>>) {}
```



### DST

DST

- Slice
- Trait Objectvtable





## 

Rust

BUG`panic!`



### panic

`panic``unwind``abort``unwind`Rust`abort`

``` toml
# cargo.toml
[profile.release]
panic = 'abort'
```



### Result

``` rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Option<T>``Result<T, E>`

``` rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

`match``Result`



#### unwrap

`unwrap``Result``Ok``Err``panic`

``` rust
fn main() {
    let f = File::open("hello.txt").unwrap();
}
```



#### expect

`unwrap`

``` rust
fn main() {
    let f = File::open("hello.txt").expect("");
}
```



#### propagating errors

`propagating errors``Result``?`

`Result``Ok``Err``Err``test`

``` rust
fn test() {
    let f = File::open("hello.txt")?;
}
```



#### unwrap_or_else

`unwrap``expect``Err``panic``unwrap_or_else`



``` rust
fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
      // do something
  	})
}
```







## 

*JavaScript*`[[scope]]`VO



*JavaScript**Rust*

``` rust
fn main() {
    let s = "hello";
    fn test() {
        println!("{}", s) // 
    }

    test();
}
```

Rust

``` rust
fn main() {
    let s = "hello";
    let f = |name: &str| {
        println!("{}, {}", s, name)
    };
    f("world");
}
```

``` rust
let f = File::open("hello.txt").unwrap_or_else(|error| {
		// do something
})
```







## pattern match

`pattern`

- `1`
- `x`
- `[x, y, z]``(a, b, c)``Point { x, y }``Some(x)`
- `_``_`





- match

  ``` rust
  match VALUE {
      PATTERN => EXPRESSION,
      PATTERN => EXPRESSION,
      PATTERN => EXPRESSION,
  }
  ```

- if let

  ``` rust
  if let Some(x) = y {
    
  } else if xx {
    
  } else if let Some(z) = w {
    
  } else {
    
  }
  ```

- while let

  ``` rust
  while let Some(x) = y {
    
  }
  ```

- for...in

  ``` rust
  let vector = vec![Point { x: 100, y: 200}, Point { x: 200, y: 400}];
  for &Point { x, y } in vector.iter() {
      println!("{}, {}", x, y);
  }
  ```

- let

  `let`

  ``` rust
  let x = 5; // let PATTERN = EXPRESSION;
  ```

- 

  ``` rust
  fn print_coordinates(&(x, y): &(i32, i32)) {
      println!("Current location: ({}, {})", x, y);
  }
  
  fn main() {
      let point = (3, 5);
      print_coordinates(&point);
  }
  ```





### `refutable``irrefutable`

`refutable``irrefutable`

- `irrefutable``let x = 1``x`
- `refutable``if let Some(x) = y``Some(x)``y``None`

`let``for``irrefutable``let Some(x) = 100``if let``while let``irrefutable``if let x = 100`





### Multiple patterns

``` rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```



### `..=`

``` rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

``` rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```



### 

#### Struct

``` rust
let p = Point { x: 0, y: 7 };

let Point { x: a, y: b } = p;
```

#### 

`variants``irrefutable``let``match`

``` rust
enum Akara {
    P2 { x: u32, y: u32},
}

let aka = Akara::P2 { x: 100, y: 200 };
let Akara::P2 { x, y } = aka; // success
```

``` rust
enum Akara {
    P1,
    P2 { x: u32, y: u32},
}

let aka = Akara::P2 { x: 100, y: 200 };
let Akara::P2 { x, y } = aka; // error

match aka {
    Akara::P1 => (),
    Akara::P2 { x, y } => (),
    _ => () 
}
```

#### 

``` rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```



### 

`_``_``_``_x``_x``_`

``` rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

### Match Guard

`match``match guard``match guard``match``if`

``` rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {} is even", x),
    Some(x) => println!("The number {} is odd", x),
    None => (),
}
```



### @bindings

``` rust
enum Akara {
    P1,
    P2 { x: u32, y: u32},
}

let aka = Akara::P2 { x: 100, y: 200 };
match aka {
   Akara::P1 => (),
   Akara::P2 { x: 1..=200, y} => println!("{}, {}", x, y), // error. cannot find value `x` in this scope
   _ => () 
}
```

`@`

``` rust
match aka {
   Akara::P1 => (),
   Akara::P2 { x: xx @ 1..=200, y} => println!("{}, {}", xx, y),
   _ => () 
}
```









## 

``` rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

`thread::spawn`

### Join Handles

`thread::spawn``JoinHandle``join``unwrap`

``` rust
fn main() {
    let handle: JoinHandle<u32> = thread::spawn(|| {
        thread::sleep(Duration::from_secs(1));
        println!("");
        100 + 200
    });
    
    let value = handle.join().unwrap();

    println!("{}", value); // 300
}
```

### move 

RustBorrow Check

``` rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| { // error
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

`move`Rust

``` rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```



### 

*channel*`tx``rx``transmitter``receiver`

``` rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```















## 

### Unsafe Rust

### Advanced Traits

### Advanced Type

### Advanced Function 

### Macro

Rust*****declarative macros***** *procedural macros*

- *Custom `#[derive]` macros*
- *Attribute-like macros*
- *Function-like macros*

Token

#### 

##### 

``` rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

##### 

``` rust
let v: Vec<u32> = vec![1, 2, 3];
```





#### 

Trait

##### 

``` rust
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

##### 

``` rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```





#### 



##### 

``` rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
}
```



##### 

``` rust
#[route(GET, "/")]
fn index() {
}
```





#### 



##### 

``` rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
}
```



##### 

``` rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```





## 

### r#...#



``` rust
let html = r#"
    <!DOCTYPE html>
    <meta charset="utf-8">
    <title>Hello, world!</title>
    <h1 class="foo">Hello, <i>world!</i></h1>
"#;
```







