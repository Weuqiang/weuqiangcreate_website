---
sidebar_position: 3
title: 
tags: [, Next.js, Node.js, MongoDB, ]
---

# 

## 



### 

****
- Next.js 14 (App Router)
- TypeScript
- Tailwind CSS
- React Query
- Zustand

****
- Node.js + Express
- TypeScript
- MongoDB + Mongoose
- JWT
- Redis

### 

-  
-  Markdown
-  CRUD
-  
-  
-  
-  
-  
-  RSS

## 

### users

```typescript
interface User {
  _id: ObjectId;
  username: string;
  email: string;
  password: string; // 
  avatar?: string;
  bio?: string;
  followers: ObjectId[]; // 
  following: ObjectId[]; // 
  createdAt: Date;
  updatedAt: Date;
}
```

### posts

```typescript
interface Post {
  _id: ObjectId;
  title: string;
  content: string; // Markdown
  summary: string;
  coverImage?: string;
  author: ObjectId;
  tags: string[];
  category: string;
  views: number;
  likes: ObjectId[]; // 
  favorites: ObjectId[]; // 
  status: 'draft' | 'published';
  publishedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}
```

### comments

```typescript
interface Comment {
  _id: ObjectId;
  post: ObjectId;
  author: ObjectId;
  content: string;
  parentComment?: ObjectId; // 
  likes: ObjectId[];
  createdAt: Date;
  updatedAt: Date;
}
```

## 

### 1. 

```bash
mkdir blog-backend
cd blog-backend
npm init -y
npm install express mongoose jsonwebtoken bcryptjs cors dotenv
npm install -D typescript @types/node @types/express ts-node nodemon
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

### 2. 

```typescript
// src/models/User.ts
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  avatar?: string;
  bio?: string;
  followers: mongoose.Types.ObjectId[];
  following: mongoose.Types.ObjectId[];
  comparePassword(password: string): Promise<boolean>;
}

const UserSchema = new Schema<IUser>({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
  },
  avatar: String,
  bio: String,
  followers: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  following: [{ type: Schema.Types.ObjectId, ref: 'User' }],
}, {
  timestamps: true,
});

// 
UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// 
UserSchema.methods.comparePassword = async function(password: string) {
  return bcrypt.compare(password, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);
```

```typescript
// src/models/Post.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IPost extends Document {
  title: string;
  content: string;
  summary: string;
  coverImage?: string;
  author: mongoose.Types.ObjectId;
  tags: string[];
  category: string;
  views: number;
  likes: mongoose.Types.ObjectId[];
  favorites: mongoose.Types.ObjectId[];
  status: 'draft' | 'published';
  publishedAt?: Date;
}

const PostSchema = new Schema<IPost>({
  title: {
    type: String,
    required: true,
    trim: true,
  },
  content: {
    type: String,
    required: true,
  },
  summary: {
    type: String,
    required: true,
  },
  coverImage: String,
  author: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  tags: [String],
  category: {
    type: String,
    required: true,
  },
  views: {
    type: Number,
    default: 0,
  },
  likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  favorites: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  status: {
    type: String,
    enum: ['draft', 'published'],
    default: 'draft',
  },
  publishedAt: Date,
}, {
  timestamps: true,
});

// 
PostSchema.index({ title: 'text', content: 'text', summary: 'text' });

export default mongoose.model<IPost>('Post', PostSchema);
```

```typescript
// src/models/Comment.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IComment extends Document {
  post: mongoose.Types.ObjectId;
  author: mongoose.Types.ObjectId;
  content: string;
  parentComment?: mongoose.Types.ObjectId;
  likes: mongoose.Types.ObjectId[];
}

const CommentSchema = new Schema<IComment>({
  post: {
    type: Schema.Types.ObjectId,
    ref: 'Post',
    required: true,
  },
  author: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  parentComment: {
    type: Schema.Types.ObjectId,
    ref: 'Comment',
  },
  likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
}, {
  timestamps: true,
});

export default mongoose.model<IComment>('Comment', CommentSchema);
```

### 3. 

```typescript
// src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthRequest extends Request {
  userId?: string;
}

export const auth = (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: '' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    req.userId = decoded.userId;
    next();
  } catch (error) {
    res.status(401).json({ error: 'token' });
  }
};
```

### 4. 

```typescript
// src/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import User from '../models/User';

const router = express.Router();

// 
router.post('/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // 
    const existingUser = await User.findOne({
      $or: [{ email }, { username }]
    });
    
    if (existingUser) {
      return res.status(400).json({ error: '' });
    }
    
    // 
    const user = new User({ username, email, password });
    await user.save();
    
    // token
    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    );
    
    res.status(201).json({
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
      },
      token,
    });
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // 
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: '' });
    }
    
    // 
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ error: '' });
    }
    
    // token
    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    );
    
    res.json({
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
      },
      token,
    });
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

export default router;
```

```typescript
// src/routes/posts.ts
import express from 'express';
import Post from '../models/Post';
import { auth, AuthRequest } from '../middleware/auth';

const router = express.Router();

// 
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, category, tag, search } = req.query;
    
    const query: any = { status: 'published' };
    
    if (category) {
      query.category = category;
    }
    
    if (tag) {
      query.tags = tag;
    }
    
    if (search) {
      query.$text = { $search: search as string };
    }
    
    const posts = await Post.find(query)
      .populate('author', 'username avatar')
      .sort({ publishedAt: -1 })
      .limit(Number(limit))
      .skip((Number(page) - 1) * Number(limit));
    
    const total = await Post.countDocuments(query);
    
    res.json({
      posts,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit)),
      },
    });
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.get('/:id', async (req, res) => {
  try {
    const post = await Post.findById(req.params.id)
      .populate('author', 'username avatar bio');
    
    if (!post) {
      return res.status(404).json({ error: '' });
    }
    
    // 
    post.views += 1;
    await post.save();
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.post('/', auth, async (req: AuthRequest, res) => {
  try {
    const { title, content, summary, coverImage, tags, category, status } = req.body;
    
    const post = new Post({
      title,
      content,
      summary,
      coverImage,
      tags,
      category,
      status,
      author: req.userId,
      publishedAt: status === 'published' ? new Date() : undefined,
    });
    
    await post.save();
    await post.populate('author', 'username avatar');
    
    res.status(201).json(post);
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.put('/:id', auth, async (req: AuthRequest, res) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({ error: '' });
    }
    
    if (post.author.toString() !== req.userId) {
      return res.status(403).json({ error: '' });
    }
    
    const { title, content, summary, coverImage, tags, category, status } = req.body;
    
    post.title = title || post.title;
    post.content = content || post.content;
    post.summary = summary || post.summary;
    post.coverImage = coverImage || post.coverImage;
    post.tags = tags || post.tags;
    post.category = category || post.category;
    
    if (status && status !== post.status) {
      post.status = status;
      if (status === 'published' && !post.publishedAt) {
        post.publishedAt = new Date();
      }
    }
    
    await post.save();
    await post.populate('author', 'username avatar');
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.delete('/:id', auth, async (req: AuthRequest, res) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({ error: '' });
    }
    
    if (post.author.toString() !== req.userId) {
      return res.status(403).json({ error: '' });
    }
    
    await post.deleteOne();
    
    res.json({ message: '' });
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

// 
router.post('/:id/like', auth, async (req: AuthRequest, res) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({ error: '' });
    }
    
    const userId = req.userId!;
    const index = post.likes.indexOf(userId as any);
    
    if (index > -1) {
      // 
      post.likes.splice(index, 1);
    } else {
      // 
      post.likes.push(userId as any);
    }
    
    await post.save();
    
    res.json({ likes: post.likes.length });
  } catch (error) {
    res.status(500).json({ error: '' });
  }
});

export default router;
```

### 5. 

```typescript
// src/app.ts
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/auth';
import postRoutes from './routes/posts';
import commentRoutes from './routes/comments';

dotenv.config();

const app = express();

// 
app.use(cors());
app.use(express.json());

// 
app.use('/api/auth', authRoutes);
app.use('/api/posts', postRoutes);
app.use('/api/comments', commentRoutes);

// 
mongoose.connect(process.env.MONGODB_URI!)
  .then(() => console.log('MongoDB'))
  .catch(err => console.error('MongoDB:', err));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(` ${PORT}`);
});
```

## 

### 1. 

```bash
npx create-next-app@latest blog-frontend --typescript --tailwind --app
cd blog-frontend
npm install @tanstack/react-query axios zustand react-markdown
```

### 2. API

```typescript
// src/lib/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api',
});

// 
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

### 3. 

```typescript
// src/store/authStore.ts
import { create } from 'zustand';
import api from '@/lib/api';

interface User {
  id: string;
  username: string;
  email: string;
  avatar?: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  login: (email: string, password: string) => Promise<void>;
  register: (username: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  setUser: (user: User) => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  token: null,
  
  login: async (email, password) => {
    const { data } = await api.post('/auth/login', { email, password });
    localStorage.setItem('token', data.token);
    set({ user: data.user, token: data.token });
  },
  
  register: async (username, email, password) => {
    const { data } = await api.post('/auth/register', { username, email, password });
    localStorage.setItem('token', data.token);
    set({ user: data.user, token: data.token });
  },
  
  logout: () => {
    localStorage.removeItem('token');
    set({ user: null, token: null });
  },
  
  setUser: (user) => set({ user }),
}));
```

### 4. 

```typescript
// src/app/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import api from '@/lib/api';
import PostCard from '@/components/PostCard';
import { useState } from 'react';

export default function Home() {
  const [page, setPage] = useState(1);
  
  const { data, isLoading } = useQuery({
    queryKey: ['posts', page],
    queryFn: async () => {
      const { data } = await api.get(`/posts?page=${page}&limit=10`);
      return data;
    },
  });
  
  if (isLoading) {
    return <div className="text-center py-10">...</div>;
  }
  
  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      <h1 className="text-4xl font-bold mb-8"></h1>
      
      <div className="space-y-6">
        {data?.posts.map((post: any) => (
          <PostCard key={post._id} post={post} />
        ))}
      </div>
      
      {/*  */}
      <div className="flex justify-center gap-2 mt-8">
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
          className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
        >
          
        </button>
        <span className="px-4 py-2">
          {page} / {data?.pagination.pages}
        </span>
        <button
          onClick={() => setPage(p => p + 1)}
          disabled={page >= data?.pagination.pages}
          className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
        >
          
        </button>
      </div>
    </div>
  );
}
```

### 5. 

```typescript
// src/app/posts/[id]/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import api from '@/lib/api';
import ReactMarkdown from 'react-markdown';
import { useParams } from 'next/navigation';

export default function PostDetail() {
  const params = useParams();
  const id = params.id;
  
  const { data: post, isLoading } = useQuery({
    queryKey: ['post', id],
    queryFn: async () => {
      const { data } = await api.get(`/posts/${id}`);
      return data;
    },
  });
  
  if (isLoading) {
    return <div className="text-center py-10">...</div>;
  }
  
  return (
    <article className="max-w-4xl mx-auto px-4 py-8">
      {/*  */}
      {post.coverImage && (
        <img
          src={post.coverImage}
          alt={post.title}
          className="w-full h-96 object-cover rounded-lg mb-8"
        />
      )}
      
      {/*  */}
      <h1 className="text-4xl font-bold mb-4">{post.title}</h1>
      
      {/*  */}
      <div className="flex items-center gap-4 text-gray-600 mb-8">
        <img
          src={post.author.avatar || '/default-avatar.png'}
          alt={post.author.username}
          className="w-10 h-10 rounded-full"
        />
        <span>{post.author.username}</span>
        <span>·</span>
        <span>{new Date(post.publishedAt).toLocaleDateString()}</span>
        <span>·</span>
        <span>{post.views} </span>
      </div>
      
      {/*  */}
      <div className="flex gap-2 mb-8">
        {post.tags.map((tag: string) => (
          <span
            key={tag}
            className="px-3 py-1 bg-gray-200 rounded-full text-sm"
          >
            {tag}
          </span>
        ))}
      </div>
      
      {/*  */}
      <div className="prose max-w-none">
        <ReactMarkdown>{post.content}</ReactMarkdown>
      </div>
      
      {/*  */}
      <div className="mt-8 flex gap-4">
        <button className="px-6 py-2 bg-red-500 text-white rounded-lg">
           {post.likes.length}
        </button>
        <button className="px-6 py-2 bg-blue-500 text-white rounded-lg">
           
        </button>
      </div>
    </article>
  );
}
```

### 6. Markdown

```typescript
// src/components/MarkdownEditor.tsx
'use client';

import { useState } from 'react';
import ReactMarkdown from 'react-markdown';

interface MarkdownEditorProps {
  value: string;
  onChange: (value: string) => void;
}

export default function MarkdownEditor({ value, onChange }: MarkdownEditorProps) {
  const [preview, setPreview] = useState(false);
  
  return (
    <div className="border rounded-lg overflow-hidden">
      {/*  */}
      <div className="bg-gray-100 p-2 flex gap-2">
        <button
          onClick={() => setPreview(false)}
          className={`px-4 py-2 rounded ${!preview ? 'bg-white' : ''}`}
        >
          
        </button>
        <button
          onClick={() => setPreview(true)}
          className={`px-4 py-2 rounded ${preview ? 'bg-white' : ''}`}
        >
          
        </button>
      </div>
      
      {/* / */}
      <div className="p-4">
        {preview ? (
          <div className="prose max-w-none">
            <ReactMarkdown>{value}</ReactMarkdown>
          </div>
        ) : (
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="w-full h-96 p-4 border rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder=" Markdown ..."
          />
        )}
      </div>
    </div>
  );
}
```

## 

### 1. Docker

```dockerfile
# Dockerfile ()
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 5000

CMD ["node", "dist/app.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  mongodb:
    image: mongo:6
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  backend:
    build: ./blog-backend
    ports:
      - "5000:5000"
    environment:
      - MONGODB_URI=mongodb://mongodb:27017/blog
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-secret-key
    depends_on:
      - mongodb
      - redis
  
  frontend:
    build: ./blog-frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:5000/api
    depends_on:
      - backend

volumes:
  mongodb_data:
```

### 2. Vercel

```bash
#  Vercel CLI
npm i -g vercel

# 
cd blog-frontend
vercel
```

## 



1. ****Next.js + Node.js + MongoDB
2. ****JWT + 
3. ****MongoDB + Mongoose
4. ****Zustand + React Query
5. **Markdown**
6. ****Docker + Vercel

## 

- [Next.js](https://nextjs.org/docs)
- [MongoDB](https://docs.mongodb.com/)
- [Express](https://expressjs.com/)

