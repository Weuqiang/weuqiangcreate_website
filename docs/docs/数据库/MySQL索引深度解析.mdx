---
sidebar_position: 1
title: MySQL
tags: [, MySQL, , B+]
---

# MySQL

MySQL

## 

### B+

```javascript
// B+
class BPlusTreeNode {
  constructor(isLeaf = false) {
    this.isLeaf = isLeaf;
    this.keys = [];           // 
    this.children = [];       // 
    this.next = null;         // 
    this.parent = null;       // 
  }
}

class BPlusTree {
  constructor(order = 4) {
    this.root = new BPlusTreeNode(true);
    this.order = order;       // 
    this.minKeys = Math.ceil(order / 2) - 1;
  }
  
  // 
  search(key) {
    let node = this.root;
    
    // 
    while (!node.isLeaf) {
      let i = 0;
      while (i < node.keys.length && key >= node.keys[i]) {
        i++;
      }
      node = node.children[i];
    }
    
    // 
    const index = node.keys.indexOf(key);
    return index !== -1 ? node.children[index] : null;
  }
  
  // 
  insert(key, value) {
    const leaf = this.findLeaf(key);
    
    // 
    this.insertIntoLeaf(leaf, key, value);
    
    // 
    if (leaf.keys.length >= this.order) {
      this.splitLeaf(leaf);
    }
  }
  
  findLeaf(key) {
    let node = this.root;
    
    while (!node.isLeaf) {
      let i = 0;
      while (i < node.keys.length && key >= node.keys[i]) {
        i++;
      }
      node = node.children[i];
    }
    
    return node;
  }
  
  insertIntoLeaf(leaf, key, value) {
    let i = 0;
    while (i < leaf.keys.length && key > leaf.keys[i]) {
      i++;
    }
    
    leaf.keys.splice(i, 0, key);
    leaf.children.splice(i, 0, value);
  }
  
  splitLeaf(leaf) {
    const mid = Math.floor(this.order / 2);
    
    // 
    const newLeaf = new BPlusTreeNode(true);
    newLeaf.keys = leaf.keys.splice(mid);
    newLeaf.children = leaf.children.splice(mid);
    
    // 
    newLeaf.next = leaf.next;
    leaf.next = newLeaf;
    
    // 
    const promoteKey = newLeaf.keys[0];
    this.insertIntoParent(leaf, promoteKey, newLeaf);
  }
  
  insertIntoParent(left, key, right) {
    if (left === this.root) {
      // 
      const newRoot = new BPlusTreeNode(false);
      newRoot.keys = [key];
      newRoot.children = [left, right];
      left.parent = newRoot;
      right.parent = newRoot;
      this.root = newRoot;
      return;
    }
    
    const parent = left.parent;
    let i = 0;
    while (i < parent.keys.length && key > parent.keys[i]) {
      i++;
    }
    
    parent.keys.splice(i, 0, key);
    parent.children.splice(i + 1, 0, right);
    right.parent = parent;
    
    // 
    if (parent.keys.length >= this.order) {
      this.splitInternal(parent);
    }
  }
}

// B+
const bPlusTreeFeatures = {
  advantages: [
    '',
    '',
    '',
    'O(logN)',
    ''
  ],
  
  vsHashIndex: {
    bPlusTree: '',
    hash: ''
  },
  
  vsBTree: {
    bPlusTree: '',
    bTree: ''
  }
};
```

### 

```sql
-- 
-- InnoDB
CREATE TABLE users (
    id INT PRIMARY KEY,        -- 
    name VARCHAR(100),
    email VARCHAR(100),
    age INT
);

-- B+
/*

         [10, 20, 30]
        /      |      \
   [1-9]   [10-19]   [20-29]
     |        |         |
          
*/

-- 
CREATE INDEX idx_email ON users(email);

-- B+
/*

         [email_b, email_m, email_z]
        /           |              \
   [email_a]    [email_l]      [email_y]
      |            |               |
    id       id          id
*/

-- 
-- 1. 
-- 2. 
SELECT * FROM users WHERE email = 'john@example.com';

-- 
CREATE INDEX idx_email_name ON users(email, name);

-- 
SELECT name FROM users WHERE email = 'john@example.com';
```

## 

### 1. 

```sql
-- 
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    amount DECIMAL(10,2),
    created_at TIMESTAMP
);

-- 
-- 1. 
-- 2. 
-- 3. 

-- UUID
CREATE TABLE orders_uuid (
    id CHAR(36) PRIMARY KEY,  -- UUID
    user_id BIGINT,
    amount DECIMAL(10,2)
);

-- 
-- 1. 
-- 2. 
-- 3. 

-- 
CREATE TABLE order_items (
    order_id BIGINT,
    product_id BIGINT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

### 2. 

```sql
-- 
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20)
);

-- 
CREATE UNIQUE INDEX idx_email ON users(email);

--  vs 
/*

- 
- 


- NULL
- 
- 
*/

-- NULL
INSERT INTO users (id, email) VALUES (1, NULL);  -- 
INSERT INTO users (id, email) VALUES (2, NULL);  -- NULL
```

### 3. 

```sql
-- 
CREATE INDEX idx_user_time ON orders(user_id, created_at);

-- 
--  
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 1 AND created_at > '2024-01-01';

--  
SELECT * FROM orders WHERE created_at > '2024-01-01';

-- 
-- 1. 
-- 2. 
-- 3. 

-- 
CREATE INDEX idx_user_time ON orders(user_id, created_at);

SELECT * FROM orders 
WHERE user_id = 1 
ORDER BY created_at DESC;  -- 

-- Index Condition Pushdown
CREATE INDEX idx_name_age ON users(name, age);

SELECT * FROM users 
WHERE name LIKE 'John%' AND age > 20;

-- MySQL 5.6+age > 20
-- 
```

### 4. 

```sql
-- 
CREATE INDEX idx_email_prefix ON users(email(10));

-- 
SELECT 
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS sel_5,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS sel_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS sel_15,
    COUNT(DISTINCT email) / COUNT(*) AS sel_full
FROM users;

-- 

-- 
-- 1. ORDER BY
-- 2. GROUP BY
-- 3. 
```

### 5. 

```sql
-- 
CREATE TABLE articles (
    id BIGINT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT INDEX idx_fulltext (title, content)
) ENGINE=InnoDB;

-- 
-- 
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('MySQL' IN NATURAL LANGUAGE MODE);

-- 
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);

-- 
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('' WITH QUERY EXPANSION);

-- 
-- 
SET GLOBAL innodb_ft_min_token_size = 2;

-- 
CREATE TABLE my_stopwords (value VARCHAR(30));
INSERT INTO my_stopwords VALUES (''), (''), ('');
SET GLOBAL innodb_ft_server_stopword_table = 'mydb/my_stopwords';
```

## 

### 1. 

```sql
-- 
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS selectivity
FROM table_name;

-- 
--  = 1
--  < 0.1

-- 
SELECT 
    COUNT(DISTINCT gender) / COUNT(*) AS gender_sel,  -- 0.5
    COUNT(DISTINCT email) / COUNT(*) AS email_sel,    -- 1.0
    COUNT(DISTINCT age) / COUNT(*) AS age_sel         -- 0.05
FROM users;

-- emailgenderage
```

### 2. 

```sql
--  
SELECT * FROM users WHERE YEAR(created_at) = 2024;

--  
SELECT * FROM users 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';

--  
SELECT * FROM users WHERE phone = 12345678;  -- phoneVARCHAR

--  
SELECT * FROM users WHERE phone = '12345678';

--  NOT!=<>
SELECT * FROM users WHERE status != 'deleted';

--  IN
SELECT * FROM users WHERE status IN ('active', 'pending');

--  OR
SELECT * FROM users WHERE name = 'John' OR email = 'john@example.com';

--  UNION
SELECT * FROM users WHERE name = 'John'
UNION
SELECT * FROM users WHERE email = 'john@example.com';

--  LIKE
SELECT * FROM users WHERE name LIKE '%John';

--  LIKE
SELECT * FROM users WHERE name LIKE 'John%';

--  
SELECT * FROM orders WHERE amount * 0.9 > 100;

--  
SELECT * FROM orders WHERE amount > 100 / 0.9;
```

### 3. 

```sql
-- 
CREATE INDEX idx_covering ON users(name, email, age);

--  
SELECT name, email, age FROM users WHERE name = 'John';
-- Extra: Using index

--  
SELECT name, email, age, address FROM users WHERE name = 'John';
-- Extra: Using index condition

-- 
--  
SELECT * FROM users ORDER BY id LIMIT 1000000, 10;

--   + 
SELECT * FROM users
INNER JOIN (
    SELECT id FROM users ORDER BY id LIMIT 1000000, 10
) AS t USING(id);
```

### 4. 

```sql
-- 
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_age ON users(age);

-- MySQL
SELECT * FROM users WHERE name = 'John' AND age > 20;

-- 
EXPLAIN SELECT * FROM users WHERE name = 'John' AND age > 20;
-- Extra: Using intersect(idx_name, idx_age)

-- 
CREATE INDEX idx_name_age ON users(name, age);
```

## 

```sql
-- 
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 
SELECT 
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.CARDINALITY
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN INFORMATION_SCHEMA.INDEX_STATISTICS i
    ON s.TABLE_SCHEMA = i.TABLE_SCHEMA
    AND s.TABLE_NAME = i.TABLE_NAME
    AND s.INDEX_NAME = i.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND s.INDEX_NAME != 'PRIMARY'
    AND i.INDEX_NAME IS NULL;

-- 
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE DATABASE_NAME = 'your_database'
    AND STAT_NAME = 'size';

-- 
ANALYZE TABLE users;

-- 
OPTIMIZE TABLE users;
```

## 

MySQL
-  **B+**
-  ****
-  ****
-  ****
-  ****
-  ****

****

