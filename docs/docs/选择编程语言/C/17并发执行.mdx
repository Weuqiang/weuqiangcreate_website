---
sidebar_position: 17
title: 
---

# 

## 

ConcurrencyCMulti-threading

CC11`threads.h`POSIXpthreadWindowsAPI

## POSIXpthread

POSIXpthreadUnix/Linux

### 

- **Thread**
- **Main Thread**
- **Child Thread**

### 

```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

// 
void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    printf(" %d \n", thread_id);
    
    // 
    sleep(2);
    
    printf(" %d \n", thread_id);
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    int id1 = 1, id2 = 2;
    
    // 
    pthread_create(&thread1, NULL, thread_function, &id1);
    pthread_create(&thread2, NULL, thread_function, &id2);
    
    printf("...\n");
    
    // 
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("\n");
    return 0;
}
```

`gcc program.c -pthread -o program`

### 

```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

void* calculate_sum(void* arg) {
    int n = *(int*)arg;
    int* result = malloc(sizeof(int));
    
    *result = 0;
    for (int i = 1; i <= n; i++) {
        *result += i;
    }
    
    return result;
}

int main() {
    pthread_t thread;
    int n = 100;
    int* result;
    
    pthread_create(&thread, NULL, calculate_sum, &n);
    
    // 
    pthread_join(thread, (void**)&result);
    
    printf("1%d: %d\n", n, *result);
    
    free(result);
    return 0;
}
```

## Mutex



### 

```c showLineNumbers
#include <stdio.h>
#include <pthread.h>

int counter = 0;
pthread_mutex_t mutex;

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);    // 
        counter++;
        pthread_mutex_unlock(&mutex);  // 
    }
    return NULL;
}

int main() {
    pthread_t threads[5];
    
    // 
    pthread_mutex_init(&mutex, NULL);
    
    // 5
    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, increment, NULL);
    }
    
    // 
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf(": %d\n", counter);
    
    // 
    pthread_mutex_destroy(&mutex);
    
    return 0;
}
```

### 



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1, mutex2;

void* thread1_func(void* arg) {
    pthread_mutex_lock(&mutex1);
    printf("1mutex1\n");
    sleep(1);
    
    printf("1mutex2...\n");
    pthread_mutex_lock(&mutex2);  // 
    
    printf("1mutex2\n");
    
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2_func(void* arg) {
    pthread_mutex_lock(&mutex2);
    printf("2mutex2\n");
    sleep(1);
    
    printf("2mutex1...\n");
    pthread_mutex_lock(&mutex1);  // 
    
    printf("2mutex1\n");
    
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex2, NULL);
    
    pthread_create(&t1, NULL, thread1_func, NULL);
    pthread_create(&t2, NULL, thread2_func, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    pthread_mutex_destroy(&mutex1);
    pthread_mutex_destroy(&mutex2);
    
    return 0;
}
```

****
1. 
2. `pthread_mutex_trylock()`
3. 
4. 

## Condition Variable



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int ready = 0;

void* producer(void* arg) {
    sleep(2);  // 
    
    pthread_mutex_lock(&mutex);
    ready = 1;
    printf("\n");
    pthread_cond_signal(&cond);  // 
    pthread_mutex_unlock(&mutex);
    
    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    
    while (!ready) {
        printf("...\n");
        pthread_cond_wait(&cond, &mutex);  // 
    }
    
    printf("\n");
    pthread_mutex_unlock(&mutex);
    
    return NULL;
}

int main() {
    pthread_t prod, cons;
    
    pthread_create(&cons, NULL, consumer, NULL);
    pthread_create(&prod, NULL, producer, NULL);
    
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);
    
    return 0;
}
```

## Read-Write Lock



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_rwlock_t rwlock;
int shared_data = 0;

void* reader(void* arg) {
    int id = *(int*)arg;
    
    pthread_rwlock_rdlock(&rwlock);  // 
    printf("%d:  = %d\n", id, shared_data);
    sleep(1);
    pthread_rwlock_unlock(&rwlock);
    
    return NULL;
}

void* writer(void* arg) {
    int id = *(int*)arg;
    
    pthread_rwlock_wrlock(&rwlock);  // 
    shared_data++;
    printf("%d:  = %d\n", id, shared_data);
    sleep(1);
    pthread_rwlock_unlock(&rwlock);
    
    return NULL;
}

int main() {
    pthread_t readers[3], writers[2];
    int ids[5] = {1, 2, 3, 4, 5};
    
    pthread_rwlock_init(&rwlock, NULL);
    
    // 
    for (int i = 0; i < 3; i++) {
        pthread_create(&readers[i], NULL, reader, &ids[i]);
    }
    for (int i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer, &ids[i+3]);
    }
    
    // 
    for (int i = 0; i < 3; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }
    
    pthread_rwlock_destroy(&rwlock);
    
    return 0;
}
```

## Semaphore



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t semaphore;

void* worker(void* arg) {
    int id = *(int*)arg;
    
    printf("%d: ...\n", id);
    sem_wait(&semaphore);  // P-1
    
    printf("%d: \n", id);
    sleep(2);  // 
    printf("%d: \n", id);
    
    sem_post(&semaphore);  // V+1
    
    return NULL;
}

int main() {
    pthread_t threads[5];
    int ids[5] = {1, 2, 3, 4, 5};
    
    // 22
    sem_init(&semaphore, 0, 2);
    
    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, worker, &ids[i]);
    }
    
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    sem_destroy(&semaphore);
    
    return 0;
}
```

## Thread Local Storage



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>

// __thread
__thread int thread_local_var = 0;

void* thread_func(void* arg) {
    int id = *(int*)arg;
    
    thread_local_var = id * 100;
    printf("%d: thread_local_var = %d\n", id, thread_local_var);
    
    return NULL;
}

int main() {
    pthread_t threads[3];
    int ids[3] = {1, 2, 3};
    
    for (int i = 0; i < 3; i++) {
        pthread_create(&threads[i], NULL, thread_func, &ids[i]);
    }
    
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }
    
    return 0;
}
```

## 



```c showLineNumbers
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define THREAD_POOL_SIZE 4
#define TASK_QUEUE_SIZE 100

typedef struct {
    void (*function)(void*);
    void* argument;
} task_t;

typedef struct {
    pthread_t threads[THREAD_POOL_SIZE];
    task_t task_queue[TASK_QUEUE_SIZE];
    int queue_front;
    int queue_rear;
    int task_count;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int shutdown;
} thread_pool_t;

thread_pool_t pool;

void* worker_thread(void* arg) {
    while (1) {
        pthread_mutex_lock(&pool.mutex);
        
        while (pool.task_count == 0 && !pool.shutdown) {
            pthread_cond_wait(&pool.cond, &pool.mutex);
        }
        
        if (pool.shutdown) {
            pthread_mutex_unlock(&pool.mutex);
            pthread_exit(NULL);
        }
        
        task_t task = pool.task_queue[pool.queue_front];
        pool.queue_front = (pool.queue_front + 1) % TASK_QUEUE_SIZE;
        pool.task_count--;
        
        pthread_mutex_unlock(&pool.mutex);
        
        // 
        task.function(task.argument);
    }
    
    return NULL;
}

void thread_pool_init() {
    pool.queue_front = 0;
    pool.queue_rear = 0;
    pool.task_count = 0;
    pool.shutdown = 0;
    
    pthread_mutex_init(&pool.mutex, NULL);
    pthread_cond_init(&pool.cond, NULL);
    
    for (int i = 0; i < THREAD_POOL_SIZE; i++) {
        pthread_create(&pool.threads[i], NULL, worker_thread, NULL);
    }
}

void thread_pool_add_task(void (*function)(void*), void* argument) {
    pthread_mutex_lock(&pool.mutex);
    
    pool.task_queue[pool.queue_rear].function = function;
    pool.task_queue[pool.queue_rear].argument = argument;
    pool.queue_rear = (pool.queue_rear + 1) % TASK_QUEUE_SIZE;
    pool.task_count++;
    
    pthread_cond_signal(&pool.cond);
    pthread_mutex_unlock(&pool.mutex);
}

void thread_pool_destroy() {
    pthread_mutex_lock(&pool.mutex);
    pool.shutdown = 1;
    pthread_cond_broadcast(&pool.cond);
    pthread_mutex_unlock(&pool.mutex);
    
    for (int i = 0; i < THREAD_POOL_SIZE; i++) {
        pthread_join(pool.threads[i], NULL);
    }
    
    pthread_mutex_destroy(&pool.mutex);
    pthread_cond_destroy(&pool.cond);
}

// 
void example_task(void* arg) {
    int task_id = *(int*)arg;
    printf(" %d\n", task_id);
    sleep(1);
    printf(" %d \n", task_id);
}

int main() {
    thread_pool_init();
    
    int task_ids[10];
    for (int i = 0; i < 10; i++) {
        task_ids[i] = i + 1;
        thread_pool_add_task(example_task, &task_ids[i]);
    }
    
    sleep(5);  // 
    
    thread_pool_destroy();
    
    return 0;
}
```

## 



```c showLineNumbers
#include <stdio.h>
#include <pthread.h>
#include <stdatomic.h>

atomic_int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        atomic_fetch_add(&counter, 1);  // 
    }
    return NULL;
}

int main() {
    pthread_t threads[5];
    
    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, increment, NULL);
    }
    
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf(": %d\n", counter);
    
    return 0;
}
```

## 

### 

- ****
- ****
- ****

### 

1. ****
2. ****
3. ****
4. ****CPU

### 

1. **/**
2. ****
3. ****
4. ****joindetach

## 

### 1. 

```c showLineNumbers
#include <stdio.h>
#include <pthread.h>

#define ARRAY_SIZE 1000000
#define NUM_THREADS 4

int array[ARRAY_SIZE];
long partial_sums[NUM_THREADS];

typedef struct {
    int thread_id;
    int start;
    int end;
} thread_data_t;

void* calculate_partial_sum(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    long sum = 0;
    
    for (int i = data->start; i < data->end; i++) {
        sum += array[i];
    }
    
    partial_sums[data->thread_id] = sum;
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    thread_data_t thread_data[NUM_THREADS];
    
    // 
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array[i] = i + 1;
    }
    
    // 
    int chunk_size = ARRAY_SIZE / NUM_THREADS;
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_data[i].thread_id = i;
        thread_data[i].start = i * chunk_size;
        thread_data[i].end = (i == NUM_THREADS - 1) ? ARRAY_SIZE : (i + 1) * chunk_size;
        pthread_create(&threads[i], NULL, calculate_partial_sum, &thread_data[i]);
    }
    
    // 
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // 
    long total_sum = 0;
    for (int i = 0; i < NUM_THREADS; i++) {
        total_sum += partial_sums[i];
    }
    
    printf(": %ld\n", total_sum);
    
    return 0;
}
```

### 2. -

```c showLineNumbers
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 10

int buffer[BUFFER_SIZE];
int count = 0;
int in = 0;
int out = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void* producer(void* arg) {
    int id = *(int*)arg;
    
    for (int i = 0; i < 20; i++) {
        int item = rand() % 100;
        
        pthread_mutex_lock(&mutex);
        
        while (count == BUFFER_SIZE) {
            pthread_cond_wait(&not_full, &mutex);
        }
        
        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        count++;
        
        printf("%d:  %d (: %d)\n", id, item, count);
        
        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&mutex);
        
        usleep(100000);  // 0.1
    }
    
    return NULL;
}

void* consumer(void* arg) {
    int id = *(int*)arg;
    
    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&mutex);
        
        while (count == 0) {
            pthread_cond_wait(&not_empty, &mutex);
        }
        
        int item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        count--;
        
        printf("%d:  %d (: %d)\n", id, item, count);
        
        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&mutex);
        
        usleep(150000);  // 0.15
    }
    
    return NULL;
}

int main() {
    pthread_t prod_threads[2], cons_threads[2];
    int prod_ids[2] = {1, 2};
    int cons_ids[2] = {1, 2};
    
    for (int i = 0; i < 2; i++) {
        pthread_create(&prod_threads[i], NULL, producer, &prod_ids[i]);
        pthread_create(&cons_threads[i], NULL, consumer, &cons_ids[i]);
    }
    
    for (int i = 0; i < 2; i++) {
        pthread_join(prod_threads[i], NULL);
        pthread_join(cons_threads[i], NULL);
    }
    
    return 0;
}
```

## 

- [POSIX Threads Programming](https://computing.llnl.gov/tutorials/pthreads/)
- [Linux man pages - pthread](https://man7.org/linux/man-pages/man7/pthreads.7.html)
- [C11 Threads](https://en.cppreference.com/w/c/thread)
