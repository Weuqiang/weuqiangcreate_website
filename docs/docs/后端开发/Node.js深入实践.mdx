---
sidebar_position: 1
title: Node.js
tags: [, Node.js, Express, Koa, ]
---

# Node.js

Node.jsChrome V8JavaScriptNode.js

## Node.js

### 

```javascript
const eventLoopPhases = {
  // 6
  phases: {
    timers: {
      description: 'setTimeoutsetInterval',
      example: 'setTimeout(() => console.log("timer"), 0)'
    },
    
    pendingCallbacks: {
      description: 'I/O',
      example: 'TCP'
    },
    
    idle: {
      description: '',
      example: 'prepare'
    },
    
    poll: {
      description: 'I/OI/O',
      example: ''
    },
    
    check: {
      description: 'setImmediate',
      example: 'setImmediate(() => console.log("immediate"))'
    },
    
    closeCallbacks: {
      description: '',
      example: 'socket.on("close", callback)'
    }
  }
};

// 
console.log('1: ');

setTimeout(() => {
  console.log('2: setTimeout');
}, 0);

setImmediate(() => {
  console.log('3: setImmediate');
});

process.nextTick(() => {
  console.log('4: nextTick');
});

Promise.resolve().then(() => {
  console.log('5: Promise');
});

console.log('6: ');

// 1 -> 6 -> 4 -> 5 -> 2 -> 3
// nextTick > Promise > setTimeout > setImmediate
```

### 

```javascript
// 1. Callback
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});

// 
fs.readFile('file1.txt', (err, data1) => {
  if (err) return console.error(err);
  
  fs.readFile('file2.txt', (err, data2) => {
    if (err) return console.error(err);
    
    fs.readFile('file3.txt', (err, data3) => {
      if (err) return console.error(err);
      
      console.log(data1, data2, data3);
    });
  });
});

// 2. Promise
const readFilePromise = (filename) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
};

readFilePromise('file1.txt')
  .then(data1 => {
    console.log(data1);
    return readFilePromise('file2.txt');
  })
  .then(data2 => {
    console.log(data2);
    return readFilePromise('file3.txt');
  })
  .then(data3 => {
    console.log(data3);
  })
  .catch(err => console.error(err));

// 3. Async/Await
const fs_promises = require('fs').promises;

async function readFiles() {
  try {
    const data1 = await fs_promises.readFile('file1.txt', 'utf8');
    const data2 = await fs_promises.readFile('file2.txt', 'utf8');
    const data3 = await fs_promises.readFile('file3.txt', 'utf8');
    
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}

// 
async function readFilesParallel() {
  try {
    const [data1, data2, data3] = await Promise.all([
      fs_promises.readFile('file1.txt', 'utf8'),
      fs_promises.readFile('file2.txt', 'utf8'),
      fs_promises.readFile('file3.txt', 'utf8')
    ]);
    
    console.log(data1, data2, data3);
  } catch (err) {
    console.error(err);
  }
}
```

## Express

### 

```javascript
const express = require('express');
const app = express();

// 
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// 
app.get('/', (req, res) => {
  res.json({ message: 'Hello World' });
});

app.get('/users/:id', (req, res) => {
  const { id } = req.params;
  res.json({ id, name: 'John' });
});

app.post('/users', (req, res) => {
  const { name, email } = req.body;
  res.status(201).json({ id: 1, name, email });
});

// 
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### RESTful API

```javascript
const express = require('express');
const router = express.Router();

// 
class UserController {
  // GET /api/users
  async getUsers(req, res, next) {
    try {
      const { page = 1, pageSize = 20 } = req.query;
      
      const users = await User.find()
        .skip((page - 1) * pageSize)
        .limit(pageSize);
      
      const total = await User.countDocuments();
      
      res.json({
        data: users,
        pagination: {
          page: Number(page),
          pageSize: Number(pageSize),
          total,
          totalPages: Math.ceil(total / pageSize)
        }
      });
    } catch (err) {
      next(err);
    }
  }
  
  // GET /api/users/:id
  async getUser(req, res, next) {
    try {
      const { id } = req.params;
      const user = await User.findById(id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // POST /api/users
  async createUser(req, res, next) {
    try {
      const { name, email, password } = req.body;
      
      // 
      if (!name || !email || !password) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      // 
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(409).json({ error: 'Email already exists' });
      }
      
      // 
      const user = await User.create({
        name,
        email,
        password: await bcrypt.hash(password, 10)
      });
      
      res.status(201).json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // PUT /api/users/:id
  async updateUser(req, res, next) {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const user = await User.findByIdAndUpdate(
        id,
        updates,
        { new: true, runValidators: true }
      );
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (err) {
      next(err);
    }
  }
  
  // DELETE /api/users/:id
  async deleteUser(req, res, next) {
    try {
      const { id } = req.params;
      const user = await User.findByIdAndDelete(id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.status(204).send();
    } catch (err) {
      next(err);
    }
  }
}

const userController = new UserController();

router.get('/users', userController.getUsers);
router.get('/users/:id', userController.getUser);
router.post('/users', userController.createUser);
router.put('/users/:id', userController.updateUser);
router.delete('/users/:id', userController.deleteUser);

module.exports = router;
```

### 

```javascript
// 
const jwt = require('jsonwebtoken');

function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
}

// 
function requireRole(...roles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// 
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15
  max: 100, // 100
  message: 'Too many requests'
});

// 
const { body, validationResult } = require('express-validator');

const validateUser = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }),
  body('name').trim().notEmpty(),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  }
];

// 
app.post('/api/users',
  limiter,
  validateUser,
  authMiddleware,
  requireRole('admin'),
  userController.createUser
);
```

## Koa

### 

```javascript
const Koa = require('koa');
const Router = require('@koa/router');
const bodyParser = require('koa-bodyparser');

const app = new Koa();
const router = new Router();

// 
app.use(bodyParser());

// 
app.use(async (ctx, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});

// 
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    ctx.status = err.status || 500;
    ctx.body = {
      error: err.message
    };
    ctx.app.emit('error', err, ctx);
  }
});

// 
router.get('/', async (ctx) => {
  ctx.body = { message: 'Hello World' };
});

router.get('/users/:id', async (ctx) => {
  const { id } = ctx.params;
  ctx.body = { id, name: 'John' };
});

router.post('/users', async (ctx) => {
  const { name, email } = ctx.request.body;
  ctx.status = 201;
  ctx.body = { id: 1, name, email };
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### 

```javascript
// Koa
app.use(async (ctx, next) => {
  console.log('1: 1');
  await next();
  console.log('6: 1');
});

app.use(async (ctx, next) => {
  console.log('2: 2');
  await next();
  console.log('5: 2');
});

app.use(async (ctx, next) => {
  console.log('3: 3');
  ctx.body = 'Hello';
  console.log('4: 3');
});

// 1 -> 2 -> 3 -> 4 -> 5 -> 6

// 
function logger() {
  return async (ctx, next) => {
    const start = Date.now();
    await next();
    const ms = Date.now() - start;
    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
  };
}

function errorHandler() {
  return async (ctx, next) => {
    try {
      await next();
    } catch (err) {
      ctx.status = err.status || 500;
      ctx.body = { error: err.message };
    }
  };
}

app.use(errorHandler());
app.use(logger());
```

## 

### MongoDB + Mongoose

```javascript
const mongoose = require('mongoose');

// 
mongoose.connect('mongodb://localhost/myapp', {
  useNewUrlParser: true,
  useUnifiedTopology: true
});

// Schema
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// 
userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

// 
userSchema.methods.comparePassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

// 
userSchema.statics.findByEmail = function(email) {
  return this.findOne({ email });
};

const User = mongoose.model('User', userSchema);

// 
async function createUser() {
  const user = new User({
    name: 'John',
    email: 'john@example.com',
    password: 'password123'
  });
  
  await user.save();
}

async function findUsers() {
  const users = await User.find({ role: 'user' })
    .select('name email')
    .limit(10)
    .sort({ createdAt: -1 });
  
  return users;
}
```

### MySQL + Sequelize

```javascript
const { Sequelize, DataTypes } = require('sequelize');

// 
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: 'mysql',
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

// 
const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false
  }
}, {
  timestamps: true,
  hooks: {
    beforeCreate: async (user) => {
      user.password = await bcrypt.hash(user.password, 10);
    }
  }
});

// 
const Post = sequelize.define('Post', {
  title: DataTypes.STRING,
  content: DataTypes.TEXT
});

User.hasMany(Post);
Post.belongsTo(User);

// 
await sequelize.sync({ force: false });

// 
async function createUser() {
  const user = await User.create({
    name: 'John',
    email: 'john@example.com',
    password: 'password123'
  });
  
  return user;
}

async function findUsers() {
  const users = await User.findAll({
    where: {
      role: 'user'
    },
    attributes: ['id', 'name', 'email'],
    include: [{
      model: Post,
      attributes: ['title']
    }],
    limit: 10,
    order: [['createdAt', 'DESC']]
  });
  
  return users;
}
```

## 

```javascript
const multer = require('multer');
const path = require('path');

// 
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// 
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (extname && mimetype) {
    cb(null, true);
  } else {
    cb(new Error('Only images are allowed'));
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
});

// 
app.post('/upload', upload.single('file'), (req, res) => {
  res.json({
    filename: req.file.filename,
    path: req.file.path,
    size: req.file.size
  });
});

// 
app.post('/upload-multiple', upload.array('files', 10), (req, res) => {
  res.json({
    files: req.files.map(file => ({
      filename: file.filename,
      path: file.path,
      size: file.size
    }))
  });
});
```

## WebSocket

```javascript
const WebSocket = require('ws');
const http = require('http');
const express = require('express');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// WebSocket
wss.on('connection', (ws, req) => {
  console.log('Client connected');
  
  // 
  ws.on('message', (message) => {
    console.log('Received:', message);
    
    // 
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  // 
  ws.on('close', () => {
    console.log('Client disconnected');
  });
  
  // 
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
  
  // 
  ws.send(JSON.stringify({ type: 'welcome', message: 'Connected to server' }));
});

// 
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (ws.isAlive === false) {
      return ws.terminate();
    }
    
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

## 

```javascript
// 1. 
const cluster = require('cluster');
const os = require('os');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork();
  });
} else {
  // Worker
  const app = express();
  // ... 
  app.listen(3000);
}

// 2. 
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 });

app.get('/api/users/:id', async (req, res) => {
  const { id } = req.params;
  
  // 
  const cached = cache.get(`user:${id}`);
  if (cached) {
    return res.json(cached);
  }
  
  // 
  const user = await User.findById(id);
  
  // 
  cache.set(`user:${id}`, user);
  
  res.json(user);
});

// 3. 
const compression = require('compression');
app.use(compression());

// 4. 
const fs = require('fs');

app.get('/download', (req, res) => {
  const stream = fs.createReadStream('large-file.txt');
  stream.pipe(res);
});
```

## 

Node.js
-  ****
-  ****CallbackPromiseAsync/Await
-  ****ExpressKoa
-  ****MongoDBMySQL
-  ****
-  ****WebSocket
-  ****

**Node.jsI/OCPU**

