---
sidebar_position: 3
title: LeetCodeé«˜é¢‘é¢˜è§£
tags: [ç®—æ³•, LeetCode, é¢è¯•]
---

# LeetCodeé«˜é¢‘é¢˜è§£

æœ¬æ–‡ç²¾é€‰LeetCodeé«˜é¢‘é¢è¯•é¢˜ï¼Œæä¾›è¯¦ç»†è§£é¢˜æ€è·¯å’Œä»£ç å®ç°ã€‚

## æ•°ç»„ç±»

### 1. ä¸¤æ•°ä¹‹å’Œ

```javascript
/**
 * ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œç›®æ ‡å€¼ï¼Œæ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç›®æ ‡å€¼çš„ä¸¤ä¸ªæ•°
 * æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)
 */
function twoSum(nums, target) {
  const map = new Map();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    map.set(nums[i], i);
  }
  
  return [];
}

// æµ‹è¯•
console.log(twoSum([2, 7, 11, 15], 9)); // [0, 1]
```

### 15. ä¸‰æ•°ä¹‹å’Œ

```javascript
/**
 * æ‰¾å‡ºæ•°ç»„ä¸­æ‰€æœ‰å’Œä¸º0çš„ä¸‰å…ƒç»„
 * æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)
 */
function threeSum(nums) {
  const result = [];
  nums.sort((a, b) => a - b);
  
  for (let i = 0; i < nums.length - 2; i++) {
    // è·³è¿‡é‡å¤å…ƒç´ 
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        
        while (left < right && nums[left] === nums[left + 1]) left++;
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return result;
}
```

### 53. æœ€å¤§å­æ•°ç»„å’Œ

```javascript
/**
 * æ‰¾åˆ°è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ
 * åŠ¨æ€è§„åˆ’ï¼šdp[i] = max(dp[i-1] + nums[i], nums[i])
 */
function maxSubArray(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  
  for (let i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }
  
  return maxSum;
}

// åˆ†æ²»æ³•
function maxSubArrayDivide(nums, left = 0, right = nums.length - 1) {
  if (left === right) return nums[left];
  
  const mid = Math.floor((left + right) / 2);
  
  const leftMax = maxSubArrayDivide(nums, left, mid);
  const rightMax = maxSubArrayDivide(nums, mid + 1, right);
  const crossMax = maxCrossingSum(nums, left, mid, right);
  
  return Math.max(leftMax, rightMax, crossMax);
}

function maxCrossingSum(nums, left, mid, right) {
  let leftSum = -Infinity;
  let sum = 0;
  
  for (let i = mid; i >= left; i--) {
    sum += nums[i];
    leftSum = Math.max(leftSum, sum);
  }
  
  let rightSum = -Infinity;
  sum = 0;
  
  for (let i = mid + 1; i <= right; i++) {
    sum += nums[i];
    rightSum = Math.max(rightSum, sum);
  }
  
  return leftSum + rightSum;
}
```

### 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

```javascript
/**
 * åªèƒ½ä¹°å–ä¸€æ¬¡ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦
 */
function maxProfit(prices) {
  let minPrice = Infinity;
  let maxProfit = 0;
  
  for (const price of prices) {
    minPrice = Math.min(minPrice, price);
    maxProfit = Math.max(maxProfit, price - minPrice);
  }
  
  return maxProfit;
}

// 122. å¯ä»¥å¤šæ¬¡ä¹°å–
function maxProfitII(prices) {
  let profit = 0;
  
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit += prices[i] - prices[i - 1];
    }
  }
  
  return profit;
}
```

## é“¾è¡¨ç±»

### 206. åè½¬é“¾è¡¨

```javascript
/**
 * åè½¬å•é“¾è¡¨
 */
// è¿­ä»£æ³•
function reverseList(head) {
  let prev = null;
  let current = head;
  
  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }
  
  return prev;
}

// é€’å½’æ³•
function reverseListRecursive(head) {
  if (!head || !head.next) return head;
  
  const newHead = reverseListRecursive(head.next);
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
```

### 141. ç¯å½¢é“¾è¡¨

```javascript
/**
 * åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯
 * å¿«æ…¢æŒ‡é’ˆ
 */
function hasCycle(head) {
  let slow = head;
  let fast = head;
  
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) return true;
  }
  
  return false;
}

// 142. æ‰¾åˆ°ç¯çš„å…¥å£
function detectCycle(head) {
  let slow = head;
  let fast = head;
  
  // åˆ¤æ–­æ˜¯å¦æœ‰ç¯
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow === fast) {
      // æ‰¾å…¥å£
      let ptr = head;
      while (ptr !== slow) {
        ptr = ptr.next;
        slow = slow.next;
      }
      return ptr;
    }
  }
  
  return null;
}
```

### 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

```javascript
/**
 * åˆå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨
 */
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0);
  let current = dummy;
  
  while (l1 && l2) {
    if (l1.val < l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    current = current.next;
  }
  
  current.next = l1 || l2;
  
  return dummy.next;
}
```

## æ ‘ç±»

### 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```javascript
/**
 * è®¡ç®—äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
 */
// é€’å½’
function maxDepth(root) {
  if (!root) return 0;
  
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}

// è¿­ä»£ï¼ˆå±‚åºéå†ï¼‰
function maxDepthIterative(root) {
  if (!root) return 0;
  
  const queue = [root];
  let depth = 0;
  
  while (queue.length > 0) {
    const levelSize = queue.length;
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    depth++;
  }
  
  return depth;
}
```

### 226. ç¿»è½¬äºŒå‰æ ‘

```javascript
/**
 * ç¿»è½¬äºŒå‰æ ‘
 */
function invertTree(root) {
  if (!root) return null;
  
  [root.left, root.right] = [root.right, root.left];
  
  invertTree(root.left);
  invertTree(root.right);
  
  return root;
}
```

### 102. äºŒå‰æ ‘çš„å±‚åºéå†

```javascript
/**
 * å±‚åºéå†äºŒå‰æ ‘
 */
function levelOrder(root) {
  if (!root) return [];
  
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const level = [];
    const levelSize = queue.length;
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      level.push(node.val);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    result.push(level);
  }
  
  return result;
}
```

### 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```javascript
/**
 * æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
 */
function lowestCommonAncestor(root, p, q) {
  if (!root || root === p || root === q) return root;
  
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  
  if (left && right) return root;
  
  return left || right;
}
```

## åŠ¨æ€è§„åˆ’ç±»

### 70. çˆ¬æ¥¼æ¢¯

```javascript
/**
 * æ¯æ¬¡å¯ä»¥çˆ¬1æˆ–2ä¸ªå°é˜¶ï¼Œæ±‚çˆ¬åˆ°né˜¶çš„æ–¹æ³•æ•°
 */
function climbStairs(n) {
  if (n <= 2) return n;
  
  let prev = 1, curr = 2;
  
  for (let i = 3; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  
  return curr;
}
```

### 198. æ‰“å®¶åŠ«èˆ

```javascript
/**
 * ä¸èƒ½å·ç›¸é‚»çš„æˆ¿å­ï¼Œæ±‚æœ€å¤§é‡‘é¢
 */
function rob(nums) {
  if (nums.length === 0) return 0;
  if (nums.length === 1) return nums[0];
  
  let prev = 0, curr = 0;
  
  for (const num of nums) {
    [prev, curr] = [curr, Math.max(curr, prev + num)];
  }
  
  return curr;
}

// 213. æ‰“å®¶åŠ«èˆIIï¼ˆç¯å½¢ï¼‰
function robII(nums) {
  if (nums.length === 1) return nums[0];
  
  const robRange = (start, end) => {
    let prev = 0, curr = 0;
    
    for (let i = start; i < end; i++) {
      [prev, curr] = [curr, Math.max(curr, prev + nums[i])];
    }
    
    return curr;
  };
  
  return Math.max(
    robRange(0, nums.length - 1),
    robRange(1, nums.length)
  );
}
```

### 322. é›¶é’±å…‘æ¢

```javascript
/**
 * ç”¨æœ€å°‘çš„ç¡¬å¸å‡‘å‡ºé‡‘é¢
 */
function coinChange(coins, amount) {
  const dp = Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  
  for (let i = 1; i <= amount; i++) {
    for (const coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  
  return dp[amount] === Infinity ? -1 : dp[amount];
}
```

### 300. æœ€é•¿é€’å¢å­åºåˆ—

```javascript
/**
 * æ‰¾åˆ°æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
 */
// åŠ¨æ€è§„åˆ’ O(nÂ²)
function lengthOfLIS(nums) {
  if (nums.length === 0) return 0;
  
  const dp = Array(nums.length).fill(1);
  
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  
  return Math.max(...dp);
}

// äºŒåˆ†æŸ¥æ‰¾ O(n log n)
function lengthOfLISBinary(nums) {
  const tails = [];
  
  for (const num of nums) {
    let left = 0, right = tails.length;
    
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (tails[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }
    
    if (left === tails.length) {
      tails.push(num);
    } else {
      tails[left] = num;
    }
  }
  
  return tails.length;
}
```

## å­—ç¬¦ä¸²ç±»

### 3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

```javascript
/**
 * æ‰¾åˆ°æœ€é•¿æ— é‡å¤å­—ç¬¦å­ä¸²
 * æ»‘åŠ¨çª—å£
 */
function lengthOfLongestSubstring(s) {
  const map = new Map();
  let left = 0;
  let maxLen = 0;
  
  for (let right = 0; right < s.length; right++) {
    const char = s[right];
    
    if (map.has(char)) {
      left = Math.max(left, map.get(char) + 1);
    }
    
    map.set(char, right);
    maxLen = Math.max(maxLen, right - left + 1);
  }
  
  return maxLen;
}
```

### 5. æœ€é•¿å›æ–‡å­ä¸²

```javascript
/**
 * æ‰¾åˆ°æœ€é•¿å›æ–‡å­ä¸²
 */
// ä¸­å¿ƒæ‰©å±•æ³•
function longestPalindrome(s) {
  if (s.length < 2) return s;
  
  let start = 0, maxLen = 1;
  
  const expandAroundCenter = (left, right) => {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      left--;
      right++;
    }
    return right - left - 1;
  };
  
  for (let i = 0; i < s.length; i++) {
    const len1 = expandAroundCenter(i, i);
    const len2 = expandAroundCenter(i, i + 1);
    const len = Math.max(len1, len2);
    
    if (len > maxLen) {
      maxLen = len;
      start = i - Math.floor((len - 1) / 2);
    }
  }
  
  return s.substr(start, maxLen);
}
```

### 20. æœ‰æ•ˆçš„æ‹¬å·

```javascript
/**
 * åˆ¤æ–­æ‹¬å·æ˜¯å¦æœ‰æ•ˆ
 */
function isValid(s) {
  const stack = [];
  const pairs = { '(': ')', '[': ']', '{': '}' };
  
  for (const char of s) {
    if (char in pairs) {
      stack.push(char);
    } else {
      const top = stack.pop();
      if (pairs[top] !== char) return false;
    }
  }
  
  return stack.length === 0;
}
```

## æ€»ç»“

LeetCodeåˆ·é¢˜æŠ€å·§ï¼š
- ğŸ“Š **æ•°ç»„**ï¼šåŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£
- ğŸ”— **é“¾è¡¨**ï¼šå¿«æ…¢æŒ‡é’ˆã€è™šæ‹Ÿå¤´èŠ‚ç‚¹
- ğŸŒ² **æ ‘**ï¼šé€’å½’ã€å±‚åºéå†
- ğŸ“ˆ **åŠ¨æ€è§„åˆ’**ï¼šçŠ¶æ€å®šä¹‰ã€è½¬ç§»æ–¹ç¨‹
- ğŸ”¤ **å­—ç¬¦ä¸²**ï¼šå“ˆå¸Œè¡¨ã€æ»‘åŠ¨çª—å£
- ğŸ”™ **å›æº¯**ï¼šå‰ªæä¼˜åŒ–

è®°ä½ï¼š**å¤šåšé¢˜ã€å¤šæ€»ç»“ã€æ‰¾è§„å¾‹ï¼**

