---
sidebar_position: 4
title: 
tags: [, , URL]
---

# 



## 

### 

```javascript
const functionalRequirements = {
  // 
  core: {
    createShortURL: true,      // 
    redirect: true,            // URL
    customAlias: true,         // 
    expiration: true           // 
  },
  
  // 
  extended: {
    analytics: true,           // 
    qrCode: true,             // 
    bulkCreate: true,         // 
    apiAccess: true           // API
  }
};
```

### 

```python
# 
 = 100_000_000      # 1
 = 10_000_000_000   # 100
 = 100                      # 100:1

# QPS
QPS =  / 86400
QPS =  / 86400

print(f"QPS: {QPS:,.0f}")      # 1,157 QPS
print(f"QPS: {QPS:,.0f}")      # 115,740 QPS

# 
 = 500                # 500
 = 5
 =  * 365 * 
_TB = ( * ) / (1024 ** 4)

print(f": {_TB:.2f} TB")  # 8.53 TB

# 
 = 200              # 200
QPS = QPS * 2               # 2
_Gbps = (QPS *  * 8) / (1024 ** 3)

print(f": {_Gbps:.2f} Gbps")  # 0.04 Gbps
```

## 

### 

```

        

       

     CDN       ‚Üê 

       

    

       
   
          
 
 API   API 
 
 
          
   
       
   
           
 
Redis  MySQL 
     
 
```

### API

```typescript
// 1. 
interface CreateShortURLRequest {
  longURL: string;
  customAlias?: string;
  expireAt?: Date;
  userId?: string;
}

interface CreateShortURLResponse {
  shortURL: string;
  shortCode: string;
  longURL: string;
  createdAt: Date;
  expireAt?: Date;
}

// POST /api/v1/urls
async function createShortURL(req: CreateShortURLRequest): Promise<CreateShortURLResponse> {
  // 
}

// 2. 
// GET /:shortCode
async function redirect(shortCode: string): Promise<void> {
  const longURL = await getLongURL(shortCode);
  if (!longURL) {
    throw new Error('URL not found');
  }
  // 302
  response.redirect(302, longURL);
}

// 3. 
interface AnalyticsResponse {
  shortCode: string;
  totalClicks: number;
  uniqueClicks: number;
  clicksByDate: Record<string, number>;
  clicksByCountry: Record<string, number>;
  clicksByDevice: Record<string, number>;
}

// GET /api/v1/urls/:shortCode/analytics
async function getAnalytics(shortCode: string): Promise<AnalyticsResponse> {
  // 
}

// 4. 
// DELETE /api/v1/urls/:shortCode
async function deleteShortURL(shortCode: string): Promise<void> {
  // 
}
```

## 

### 

```javascript
// 1ID + Base62
class AutoIncrementGenerator {
  constructor() {
    this.chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  }
  
  encode(id) {
    if (id === 0) return this.chars[0];
    
    let result = '';
    while (id > 0) {
      result = this.chars[id % 62] + result;
      id = Math.floor(id / 62);
    }
    return result;
  }
  
  decode(shortCode) {
    let id = 0;
    for (let i = 0; i < shortCode.length; i++) {
      id = id * 62 + this.chars.indexOf(shortCode[i]);
    }
    return id;
  }
  
  async generate() {
    // ID
    const id = await db.getNextID();
    return this.encode(id);
  }
}

// 
// 

// 2 + 
class HashGenerator {
  async generate(longURL) {
    // MD57
    let shortCode = md5(longURL).substring(0, 7);
    let attempts = 0;
    
    // 
    while (await this.exists(shortCode) && attempts < 10) {
      shortCode = md5(longURL + attempts).substring(0, 7);
      attempts++;
    }
    
    if (attempts >= 10) {
      throw new Error('Failed to generate unique short code');
    }
    
    return shortCode;
  }
  
  async exists(shortCode) {
    return await redis.exists(`url:${shortCode}`);
  }
}

// URL
// 

// 3SnowflakeID
class SnowflakeGenerator {
  constructor(workerId, datacenterId) {
    this.workerId = workerId;
    this.datacenterId = datacenterId;
    this.sequence = 0;
    this.lastTimestamp = -1;
    this.epoch = 1609459200000; // 2021-01-01
  }
  
  generate() {
    let timestamp = Date.now();
    
    if (timestamp < this.lastTimestamp) {
      throw new Error('Clock moved backwards');
    }
    
    if (timestamp === this.lastTimestamp) {
      this.sequence = (this.sequence + 1) & 0xFFF;
      if (this.sequence === 0) {
        timestamp = this.waitNextMillis(this.lastTimestamp);
      }
    } else {
      this.sequence = 0;
    }
    
    this.lastTimestamp = timestamp;
    
    // 41 + 5 + 5 + 12
    const id = ((timestamp - this.epoch) << 22) |
                (this.datacenterId << 17) |
                (this.workerId << 12) |
                this.sequence;
    
    return this.base62Encode(id);
  }
  
  waitNextMillis(lastTimestamp) {
    let timestamp = Date.now();
    while (timestamp <= lastTimestamp) {
      timestamp = Date.now();
    }
    return timestamp;
  }
  
  base62Encode(num) {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    while (num > 0) {
      result = chars[num % 62] + result;
      num = Math.floor(num / 62);
    }
    return result || '0';
  }
}

// 
// 

// Snowflake + Base62
const generator = new SnowflakeGenerator(1, 1);
```

## 

### Schema

```sql
-- URL
CREATE TABLE url_mappings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    long_url TEXT NOT NULL,
    user_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_at TIMESTAMP NULL,
    is_active BOOLEAN DEFAULT TRUE,
    
    INDEX idx_short_code (short_code),
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at),
    INDEX idx_expire_at (expire_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 
CREATE TABLE url_clicks (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) NOT NULL,
    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),
    user_agent TEXT,
    referer TEXT,
    country VARCHAR(2),
    device_type VARCHAR(20),
    
    INDEX idx_short_code_time (short_code, clicked_at),
    INDEX idx_clicked_at (clicked_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
PARTITION BY RANGE (UNIX_TIMESTAMP(clicked_at)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    -- 
);

-- 
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    api_key VARCHAR(64) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    quota_limit INT DEFAULT 1000,
    quota_used INT DEFAULT 0,
    
    INDEX idx_api_key (api_key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 

```javascript
class ShardingStrategy {
  constructor(shardCount = 16) {
    this.shardCount = shardCount;
  }
  
  // 
  getShardByShortCode(shortCode) {
    // 
    const hash = this.hashCode(shortCode);
    return hash % this.shardCount;
  }
  
  // ID
  getShardByUserID(userID) {
    return userID % this.shardCount;
  }
  
  hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }
  
  // 
  getConnection(shortCode) {
    const shard = this.getShardByShortCode(shortCode);
    return this.connections[shard];
  }
}

// 
const sharding = new ShardingStrategy(16);
const db = sharding.getConnection('abc123');
```

## 

### 

```javascript
class CacheManager {
  constructor() {
    // L1: LRU
    this.localCache = new LRUCache({
      max: 10000,
      ttl: 60 * 1000 // 1
    });
    
    // L2: Redis
    this.redis = new Redis({
      host: 'localhost',
      port: 6379
    });
  }
  
  async get(shortCode) {
    // 1. 
    let longURL = this.localCache.get(shortCode);
    if (longURL) {
      return longURL;
    }
    
    // 2. Redis
    longURL = await this.redis.get(`url:${shortCode}`);
    if (longURL) {
      this.localCache.set(shortCode, longURL);
      return longURL;
    }
    
    // 3. 
    const record = await db.query(
      'SELECT long_url, expire_at FROM url_mappings WHERE short_code = ?',
      [shortCode]
    );
    
    if (!record) {
      // 
      await this.redis.setex(`url:${shortCode}`, 60, 'NULL');
      return null;
    }
    
    // 
    if (record.expire_at && new Date() > record.expire_at) {
      return null;
    }
    
    longURL = record.long_url;
    
    // 
    this.localCache.set(shortCode, longURL);
    await this.redis.setex(`url:${shortCode}`, 3600, longURL);
    
    return longURL;
  }
  
  async set(shortCode, longURL, ttl = 3600) {
    this.localCache.set(shortCode, longURL);
    await this.redis.setex(`url:${shortCode}`, ttl, longURL);
  }
  
  async delete(shortCode) {
    this.localCache.delete(shortCode);
    await this.redis.del(`url:${shortCode}`);
  }
}
```

### 

```javascript
class CacheWarmer {
  async warmup() {
    // 
    const hotURLs = await db.query(`
      SELECT short_code, long_url 
      FROM url_mappings 
      WHERE created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)
      ORDER BY (
        SELECT COUNT(*) 
        FROM url_clicks 
        WHERE url_clicks.short_code = url_mappings.short_code
      ) DESC
      LIMIT 10000
    `);
    
    // Redis
    const pipeline = redis.pipeline();
    for (const url of hotURLs) {
      pipeline.setex(`url:${url.short_code}`, 3600, url.long_url);
    }
    await pipeline.exec();
    
    console.log(`Warmed up ${hotURLs.length} URLs`);
  }
}
```

## 

### 

```javascript
class URLShortener {
  async createShortURL(longURL, options = {}) {
    const { customAlias, expireAt, userId } = options;
    
    // 1. URL
    if (!this.isValidURL(longURL)) {
      throw new Error('Invalid URL');
    }
    
    // 2. 
    if (!customAlias) {
      const existing = await this.findByLongURL(longURL, userId);
      if (existing && !existing.expire_at) {
        return existing;
      }
    }
    
    // 3. 
    let shortCode;
    if (customAlias) {
      // 
      if (await this.exists(customAlias)) {
        throw new Error('Custom alias already exists');
      }
      shortCode = customAlias;
    } else {
      // 
      shortCode = await this.generateShortCode();
    }
    
    // 4. 
    await db.query(
      `INSERT INTO url_mappings 
       (short_code, long_url, user_id, expire_at) 
       VALUES (?, ?, ?, ?)`,
      [shortCode, longURL, userId, expireAt]
    );
    
    // 5. 
    await cache.set(shortCode, longURL);
    
    // 6. 
    return {
      shortURL: `https://short.url/${shortCode}`,
      shortCode,
      longURL,
      createdAt: new Date(),
      expireAt
    };
  }
  
  isValidURL(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
  
  async findByLongURL(longURL, userId) {
    return await db.query(
      `SELECT * FROM url_mappings 
       WHERE long_url = ? AND user_id = ? AND is_active = TRUE
       ORDER BY created_at DESC LIMIT 1`,
      [longURL, userId]
    );
  }
  
  async exists(shortCode) {
    const count = await db.query(
      'SELECT COUNT(*) as count FROM url_mappings WHERE short_code = ?',
      [shortCode]
    );
    return count[0].count > 0;
  }
  
  async generateShortCode() {
    const generator = new SnowflakeGenerator(1, 1);
    return generator.generate();
  }
}
```

### 

```javascript
class RedirectService {
  async redirect(req, res, shortCode) {
    try {
      // 1. URL
      const longURL = await cache.get(shortCode);
      
      if (!longURL || longURL === 'NULL') {
        return res.status(404).send('URL not found');
      }
      
      // 2. 
      this.trackClick(shortCode, req).catch(err => {
        console.error('Failed to track click:', err);
      });
      
      // 3. 302
      res.redirect(302, longURL);
      
    } catch (error) {
      console.error('Redirect error:', error);
      res.status(500).send('Internal server error');
    }
  }
  
  async trackClick(shortCode, req) {
    // 
    const clickData = {
      shortCode,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      referer: req.headers['referer'],
      country: await this.getCountry(req.ip),
      deviceType: this.getDeviceType(req.headers['user-agent'])
    };
    
    // 
    await messageQueue.publish('url.click', clickData);
  }
  
  async getCountry(ip) {
    // IP
    return geoip.lookup(ip)?.country || 'Unknown';
  }
  
  getDeviceType(userAgent) {
    if (/mobile/i.test(userAgent)) return 'mobile';
    if (/tablet/i.test(userAgent)) return 'tablet';
    return 'desktop';
  }
}
```

### 

```javascript
class AnalyticsService {
  async getAnalytics(shortCode, startDate, endDate) {
    // 1. 
    const totalClicks = await db.query(
      `SELECT COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?`,
      [shortCode, startDate, endDate]
    );
    
    // 2. 
    const uniqueClicks = await db.query(
      `SELECT COUNT(DISTINCT ip_address) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?`,
      [shortCode, startDate, endDate]
    );
    
    // 3. 
    const clicksByDate = await db.query(
      `SELECT DATE(clicked_at) as date, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY DATE(clicked_at)
       ORDER BY date`,
      [shortCode, startDate, endDate]
    );
    
    // 4. 
    const clicksByCountry = await db.query(
      `SELECT country, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY country
       ORDER BY count DESC
       LIMIT 10`,
      [shortCode, startDate, endDate]
    );
    
    // 5. 
    const clicksByDevice = await db.query(
      `SELECT device_type, COUNT(*) as count 
       FROM url_clicks 
       WHERE short_code = ? AND clicked_at BETWEEN ? AND ?
       GROUP BY device_type`,
      [shortCode, startDate, endDate]
    );
    
    return {
      shortCode,
      totalClicks: totalClicks[0].count,
      uniqueClicks: uniqueClicks[0].count,
      clicksByDate: this.formatTimeSeries(clicksByDate),
      clicksByCountry: this.formatDistribution(clicksByCountry),
      clicksByDevice: this.formatDistribution(clicksByDevice)
    };
  }
  
  formatTimeSeries(data) {
    return data.reduce((acc, row) => {
      acc[row.date] = row.count;
      return acc;
    }, {});
  }
  
  formatDistribution(data) {
    return data.reduce((acc, row) => {
      acc[row.country || row.device_type] = row.count;
      return acc;
    }, {});
  }
}
```

## 

### 1. 

```javascript
class BloomFilter {
  constructor(size = 10000000, hashCount = 7) {
    this.size = size;
    this.hashCount = hashCount;
    this.bits = new Uint8Array(Math.ceil(size / 8));
  }
  
  add(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(item, i) % this.size;
      const byteIndex = Math.floor(hash / 8);
      const bitIndex = hash % 8;
      this.bits[byteIndex] |= (1 << bitIndex);
    }
  }
  
  contains(item) {
    for (let i = 0; i < this.hashCount; i++) {
      const hash = this.hash(item, i) % this.size;
      const byteIndex = Math.floor(hash / 8);
      const bitIndex = hash % 8;
      if ((this.bits[byteIndex] & (1 << bitIndex)) === 0) {
        return false;
      }
    }
    return true;
  }
  
  hash(item, seed) {
    let hash = seed;
    for (let i = 0; i < item.length; i++) {
      hash = ((hash << 5) - hash) + item.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}

// 
const bloomFilter = new BloomFilter();

async function exists(shortCode) {
  // 
  if (!bloomFilter.contains(shortCode)) {
    return false; // 
  }
  
  // 
  return await db.exists(shortCode);
}
```

### 2. 

```javascript
class BatchProcessor {
  constructor() {
    this.clickBuffer = [];
    this.batchSize = 1000;
    this.flushInterval = 5000; // 5
    
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  addClick(clickData) {
    this.clickBuffer.push(clickData);
    
    if (this.clickBuffer.length >= this.batchSize) {
      this.flush();
    }
  }
  
  async flush() {
    if (this.clickBuffer.length === 0) return;
    
    const batch = this.clickBuffer.splice(0, this.batchSize);
    
    try {
      await db.batchInsert('url_clicks', batch);
    } catch (error) {
      console.error('Failed to flush clicks:', error);
      // 
    }
  }
}
```

## 

### 1. 

```javascript
class RateLimiter {
  async checkLimit(userId, ip) {
    // 
    if (userId) {
      const userKey = `rate:user:${userId}`;
      const count = await redis.incr(userKey);
      if (count === 1) {
        await redis.expire(userKey, 3600); // 1
      }
      if (count > 100) {
        throw new Error('User rate limit exceeded');
      }
    }
    
    // IP
    const ipKey = `rate:ip:${ip}`;
    const ipCount = await redis.incr(ipKey);
    if (ipCount === 1) {
      await redis.expire(ipKey, 3600);
    }
    if (ipCount > 10) {
      throw new Error('IP rate limit exceeded');
    }
  }
}
```

### 2. URL

```javascript
class URLValidator {
  constructor() {
    this.blacklist = new Set([
      'malware.com',
      'phishing.com'
    ]);
  }
  
  async validate(url) {
    const domain = new URL(url).hostname;
    
    // 
    if (this.blacklist.has(domain)) {
      throw new Error('URL is blacklisted');
    }
    
    // API
    const isSafe = await this.checkSafeBrowsing(url);
    if (!isSafe) {
      throw new Error('URL is unsafe');
    }
    
    return true;
  }
  
  async checkSafeBrowsing(url) {
    // Google Safe Browsing API
    // 
    return true;
  }
}
```

## 

```javascript
class MonitoringSystem {
  async monitor() {
    // 1. QPS
    const qps = await this.getQPS();
    if (qps > 200000) {
      await this.alert('High QPS', { qps });
    }
    
    // 2. 
    const hitRate = await this.getCacheHitRate();
    if (hitRate < 0.8) {
      await this.alert('Low cache hit rate', { hitRate });
    }
    
    // 3. 
    const errorRate = await this.getErrorRate();
    if (errorRate > 0.01) {
      await this.alert('High error rate', { errorRate });
    }
    
    // 4. 
    const latency = await this.getLatency();
    if (latency > 100) {
      await this.alert('High latency', { latency });
    }
  }
}
```

## 


-  ****Snowflake + Base62
-  **** + 
-  **** + 
-  **** + 
-  **** + URL
-  **** + CDN

****

