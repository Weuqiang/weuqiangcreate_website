---
sidebar_position: 11
title: 
tags: [, , ShardingSphere, ]
---

# 

## 



### 

- ****1000
- ****
- ****
- **QPS**

## 

### 1. 

#### 



```sql
-- 
ecommerce_db
 users
 products
 orders
 payments
 logistics

-- 
user_db
 users

product_db
 products

order_db
 orders
 order_items
 order_logs

payment_db
 payments

logistics_db
 logistics
```

****
- 
- 
- 

****
- 
- 

#### 



```sql
-- 
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(255),
    email VARCHAR(100),
    phone VARCHAR(20),
    avatar VARCHAR(255),
    bio TEXT,
    settings JSON,
    login_count INT,
    last_login_at TIMESTAMP,
    created_at TIMESTAMP
);

--  + 
-- 
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status TINYINT,
    created_at TIMESTAMP
);

-- 
CREATE TABLE user_profiles (
    user_id BIGINT PRIMARY KEY,
    avatar VARCHAR(255),
    bio TEXT,
    settings JSON,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 
CREATE TABLE user_stats (
    user_id BIGINT PRIMARY KEY,
    login_count INT,
    order_count INT,
    total_amount DECIMAL(10, 2),
    last_login_at TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 2. 

#### 



```javascript
// 
class DatabaseSharding {
  constructor(dbCount = 4) {
    this.dbCount = dbCount;
    this.databases = [];
    
    // 
    for (let i = 0; i < dbCount; i++) {
      this.databases.push({
        name: `order_db_${i}`,
        connection: createConnection(`order_db_${i}`)
      });
    }
  }
  
  // ID
  getDatabase(userId) {
    const dbIndex = userId % this.dbCount;
    return this.databases[dbIndex];
  }
  
  // 
  async createOrder(order) {
    const db = this.getDatabase(order.userId);
    return await db.connection.query(
      'INSERT INTO orders SET ?',
      order
    );
  }
  
  // 
  async getUserOrders(userId) {
    const db = this.getDatabase(userId);
    return await db.connection.query(
      'SELECT * FROM orders WHERE user_id = ?',
      [userId]
    );
  }
  
  // 
  async getAllOrders(page, pageSize) {
    const results = [];
    
    for (const db of this.databases) {
      const orders = await db.connection.query(
        'SELECT * FROM orders LIMIT ?, ?',
        [(page - 1) * pageSize, pageSize]
      );
      results.push(...orders);
    }
    
    // 
    return results.sort((a, b) => b.created_at - a.created_at);
  }
}
```

#### 



```sql
-- 
orders_202401
orders_202402
orders_202403
...

-- ID
orders_0  -- user_id % 10 = 0
orders_1  -- user_id % 10 = 1
orders_2  -- user_id % 10 = 2
...
orders_9  -- user_id % 10 = 9
```

```javascript
// 
class TableSharding {
  constructor(tableCount = 10) {
    this.tableCount = tableCount;
  }
  
  // ID
  getTableName(userId) {
    const tableIndex = userId % this.tableCount;
    return `orders_${tableIndex}`;
  }
  
  // 
  async createOrder(order) {
    const tableName = this.getTableName(order.userId);
    return await db.query(
      `INSERT INTO ${tableName} SET ?`,
      order
    );
  }
  
  // 
  async getUserOrders(userId) {
    const tableName = this.getTableName(userId);
    return await db.query(
      `SELECT * FROM ${tableName} WHERE user_id = ?`,
      [userId]
    );
  }
}
```

## 

### 1. 

```javascript
// 
function getShardIndex(userId, shardCount) {
  return userId % shardCount;
}

// 
getShardIndex(12345, 4); // 1
getShardIndex(12346, 4); // 2
```

****
****

### 2. 

```javascript
// ID
function getShardByRange(userId) {
  if (userId < 1000000) return 0;
  if (userId < 2000000) return 1;
  if (userId < 3000000) return 2;
  return 3;
}

// 
function getShardByDate(date) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `orders_${year}${month.toString().padStart(2, '0')}`;
}
```

****
****

### 3. 

```javascript
class ConsistentHash {
  constructor(nodes = [], virtualNodes = 150) {
    this.virtualNodes = virtualNodes;
    this.ring = new Map();
    this.sortedKeys = [];
    
    nodes.forEach(node => this.addNode(node));
  }
  
  // 
  hash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash) + key.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  
  // 
  addNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualKey = `${node}#${i}`;
      const hash = this.hash(virtualKey);
      this.ring.set(hash, node);
      this.sortedKeys.push(hash);
    }
    this.sortedKeys.sort((a, b) => a - b);
  }
  
  // 
  removeNode(node) {
    for (let i = 0; i < this.virtualNodes; i++) {
      const virtualKey = `${node}#${i}`;
      const hash = this.hash(virtualKey);
      this.ring.delete(hash);
      const index = this.sortedKeys.indexOf(hash);
      if (index > -1) {
        this.sortedKeys.splice(index, 1);
      }
    }
  }
  
  // 
  getNode(key) {
    if (this.ring.size === 0) return null;
    
    const hash = this.hash(key.toString());
    
    // 
    for (const nodeHash of this.sortedKeys) {
      if (hash <= nodeHash) {
        return this.ring.get(nodeHash);
      }
    }
    
    // 
    return this.ring.get(this.sortedKeys[0]);
  }
}

// 
const ch = new ConsistentHash(['db0', 'db1', 'db2', 'db3']);
console.log(ch.getNode(12345)); // db2
console.log(ch.getNode(12346)); // db1

// 
ch.addNode('db4');
console.log(ch.getNode(12345)); // db2
```

****
****

### 4. 

```javascript
// 
function getShardByRegion(region) {
  const regionMap = {
    'beijing': 'db_north',
    'shanghai': 'db_east',
    'guangzhou': 'db_south',
    'chengdu': 'db_west'
  };
  return regionMap[region] || 'db_default';
}
```

## ShardingSphere 

### 1. 

```yaml
# application.yml
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1,ds2,ds3
      
      # 0
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_0
        username: root
        password: password
      
      # 1
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_1
        username: root
        password: password
      
      # 2
      ds2:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_2
        username: root
        password: password
      
      # 3
      ds3:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_3
        username: root
        password: password
    
    rules:
      sharding:
        # 
        sharding-algorithms:
          database-inline:
            type: INLINE
            props:
              algorithm-expression: ds$->{user_id % 4}
          
          table-inline:
            type: INLINE
            props:
              algorithm-expression: orders_$->{order_id % 10}
        
        # 
        tables:
          orders:
            # 
            actual-data-nodes: ds$->{0..3}.orders_$->{0..9}
            
            # 
            database-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: database-inline
            
            # 
            table-strategy:
              standard:
                sharding-column: order_id
                sharding-algorithm-name: table-inline
            
            # 
            key-generate-strategy:
              column: order_id
              key-generator-name: snowflake
        
        # 
        key-generators:
          snowflake:
            type: SNOWFLAKE
            props:
              worker-id: 1
    
    props:
      sql-show: true
```

### 2. Java 

```java
// 
@Data
@TableName("orders")
public class Order {
    @TableId(type = IdType.INPUT)
    private Long orderId;
    
    private Long userId;
    private BigDecimal totalAmount;
    private Integer status;
    private LocalDateTime createdAt;
}

// Mapper
@Mapper
public interface OrderMapper extends BaseMapper<Order> {
    // ID
    @Select("SELECT * FROM orders WHERE user_id = #{userId}")
    List<Order> selectByUserId(@Param("userId") Long userId);
    
    // ID
    @Select("SELECT * FROM orders WHERE order_id = #{orderId}")
    Order selectByOrderId(@Param("orderId") Long orderId);
}

// Service
@Service
public class OrderService {
    @Autowired
    private OrderMapper orderMapper;
    
    // 
    public void createOrder(Order order) {
        orderMapper.insert(order);
    }
    
    // 
    public List<Order> getUserOrders(Long userId) {
        return orderMapper.selectByUserId(userId);
    }
    
    // 
    public Order getOrder(Long orderId) {
        return orderMapper.selectByOrderId(orderId);
    }
}
```

### 3. 

```yaml
# 
spring:
  shardingsphere:
    rules:
      sharding:
        tables:
          # 
          dict:
            actual-data-nodes: ds$->{0..3}.dict
        
        broadcast-tables:
          - dict
```

### 4. 

```yaml
# 
spring:
  shardingsphere:
    rules:
      sharding:
        tables:
          orders:
            actual-data-nodes: ds$->{0..3}.orders_$->{0..9}
            database-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: database-inline
            table-strategy:
              standard:
                sharding-column: order_id
                sharding-algorithm-name: table-inline
          
          order_items:
            actual-data-nodes: ds$->{0..3}.order_items_$->{0..9}
            database-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: database-inline
            table-strategy:
              standard:
                sharding-column: order_id
                sharding-algorithm-name: table-inline
        
        # 
        binding-tables:
          - orders,order_items
```

## 

### 1. Snowflake

```javascript
class SnowflakeIdGenerator {
  constructor(workerId = 0, datacenterId = 0) {
    this.workerId = workerId;
    this.datacenterId = datacenterId;
    this.sequence = 0;
    this.lastTimestamp = -1;
    
    // 
    this.workerIdBits = 5;
    this.datacenterIdBits = 5;
    this.sequenceBits = 12;
    
    // 
    this.maxWorkerId = -1 ^ (-1 << this.workerIdBits);
    this.maxDatacenterId = -1 ^ (-1 << this.datacenterIdBits);
    this.maxSequence = -1 ^ (-1 << this.sequenceBits);
    
    // 
    this.workerIdShift = this.sequenceBits;
    this.datacenterIdShift = this.sequenceBits + this.workerIdBits;
    this.timestampShift = this.sequenceBits + this.workerIdBits + this.datacenterIdBits;
    
    // 2024-01-01
    this.epoch = 1704067200000;
  }
  
  nextId() {
    let timestamp = Date.now();
    
    // 
    if (timestamp < this.lastTimestamp) {
      throw new Error('Clock moved backwards');
    }
    
    // 
    if (timestamp === this.lastTimestamp) {
      this.sequence = (this.sequence + 1) & this.maxSequence;
      if (this.sequence === 0) {
        // 
        timestamp = this.waitNextMillis(this.lastTimestamp);
      }
    } else {
      this.sequence = 0;
    }
    
    this.lastTimestamp = timestamp;
    
    // ID
    return (
      ((timestamp - this.epoch) << this.timestampShift) |
      (this.datacenterId << this.datacenterIdShift) |
      (this.workerId << this.workerIdShift) |
      this.sequence
    );
  }
  
  waitNextMillis(lastTimestamp) {
    let timestamp = Date.now();
    while (timestamp <= lastTimestamp) {
      timestamp = Date.now();
    }
    return timestamp;
  }
}

// 
const idGen = new SnowflakeIdGenerator(1, 1);
console.log(idGen.nextId()); // 7234567890123456789
```

### 2. 

```sql
-- 
CREATE TABLE id_generator (
    biz_type VARCHAR(50) PRIMARY KEY,
    max_id BIGINT NOT NULL,
    step INT NOT NULL DEFAULT 1000,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 
INSERT INTO id_generator (biz_type, max_id, step) VALUES ('order', 0, 1000);
```

```javascript
class SegmentIdGenerator {
  constructor(bizType, db) {
    this.bizType = bizType;
    this.db = db;
    this.currentId = 0;
    this.maxId = 0;
    this.step = 1000;
  }
  
  async nextId() {
    // 
    if (this.currentId >= this.maxId) {
      await this.getNextSegment();
    }
    
    return ++this.currentId;
  }
  
  async getNextSegment() {
    // 
    const result = await this.db.query(`
      UPDATE id_generator 
      SET max_id = max_id + step 
      WHERE biz_type = ?
    `, [this.bizType]);
    
    const row = await this.db.query(`
      SELECT max_id, step 
      FROM id_generator 
      WHERE biz_type = ?
    `, [this.bizType]);
    
    this.maxId = row.max_id;
    this.currentId = row.max_id - row.step;
    this.step = row.step;
  }
}
```

### 3. Redis ID

```javascript
class RedisIdGenerator {
  constructor(redis, key) {
    this.redis = redis;
    this.key = key;
  }
  
  async nextId() {
    //  Redis INCR 
    return await this.redis.incr(this.key);
  }
  
  async nextIdWithDate() {
    // ID20240101000001
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    const key = `${this.key}:${dateStr}`;
    const seq = await this.redis.incr(key);
    
    // 2
    await this.redis.expire(key, 172800);
    
    return `${dateStr}${seq.toString().padStart(6, '0')}`;
  }
}
```

## 

### 1. 

```javascript
class DataMigration {
  constructor(oldDb, newDb) {
    this.oldDb = oldDb;
    this.newDb = newDb;
    this.migrationEnabled = false;
  }
  
  // 
  async insert(data) {
    // 
    await this.oldDb.insert(data);
    
    // 
    if (this.migrationEnabled) {
      try {
        await this.newDb.insert(data);
      } catch (error) {
        console.error('', error);
        // 
      }
    }
  }
  
  // 
  async query(id) {
    // 
    if (this.migrationEnabled) {
      const data = await this.newDb.query(id);
      if (data) return data;
    }
    
    // 
    return await this.oldDb.query(id);
  }
}
```

### 2. 

```javascript
class DataSync {
  constructor(sourceDb, targetDb, batchSize = 1000) {
    this.sourceDb = sourceDb;
    this.targetDb = targetDb;
    this.batchSize = batchSize;
  }
  
  async syncData(tableName) {
    let offset = 0;
    let hasMore = true;
    
    while (hasMore) {
      // 
      const rows = await this.sourceDb.query(`
        SELECT * FROM ${tableName}
        ORDER BY id
        LIMIT ${offset}, ${this.batchSize}
      `);
      
      if (rows.length === 0) {
        hasMore = false;
        break;
      }
      
      // 
      for (const row of rows) {
        const shardDb = this.getShardDb(row.user_id);
        const shardTable = this.getShardTable(row.user_id);
        
        await shardDb.query(`
          INSERT INTO ${shardTable} SET ?
          ON DUPLICATE KEY UPDATE
            total_amount = VALUES(total_amount),
            status = VALUES(status)
        `, row);
      }
      
      offset += this.batchSize;
      console.log(` ${offset} `);
      
      // 
      await this.sleep(100);
    }
    
    console.log('');
  }
  
  getShardDb(userId) {
    const dbIndex = userId % 4;
    return this.targetDb[dbIndex];
  }
  
  getShardTable(userId) {
    const tableIndex = userId % 10;
    return `orders_${tableIndex}`;
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## 

### 1. 

```javascript
// 
// 

async function getTotalOrders() {
  const results = await Promise.all([
    db0.query('SELECT COUNT(*) as count FROM orders'),
    db1.query('SELECT COUNT(*) as count FROM orders'),
    db2.query('SELECT COUNT(*) as count FROM orders'),
    db3.query('SELECT COUNT(*) as count FROM orders'),
  ]);
  
  return results.reduce((sum, r) => sum + r.count, 0);
}
```

### 2. 

```javascript
//  Seata 
@GlobalTransactional
public void createOrder(Order order) {
    // product_db
    productService.decreaseStock(order.getProductId(), order.getQuantity());
    
    // order_db
    orderService.create(order);
    
    // user_db
    userService.decreaseBalance(order.getUserId(), order.getTotalAmount());
}
```

### 3. 

```javascript
// 
//  N  N 

async function getOrders(page, pageSize) {
  //  pageSize 
  const results = await Promise.all([
    db0.query('SELECT * FROM orders ORDER BY created_at DESC LIMIT ?', [pageSize]),
    db1.query('SELECT * FROM orders ORDER BY created_at DESC LIMIT ?', [pageSize]),
    db2.query('SELECT * FROM orders ORDER BY created_at DESC LIMIT ?', [pageSize]),
    db3.query('SELECT * FROM orders ORDER BY created_at DESC LIMIT ?', [pageSize]),
  ]);
  
  // 
  const allOrders = results.flat();
  
  // 
  allOrders.sort((a, b) => b.created_at - a.created_at);
  
  // 
  const start = (page - 1) * pageSize;
  return allOrders.slice(start, start + pageSize);
}
```

## 

### 1. 

- ****user_id
- ****created_at
- ****order_idproduct_id 

### 2. 

- 
- 
- 

### 3. 

- 
- 
- 

### 4. 

- 
- 
- 

## 



1. **** vs 
2. **** vs  vs 
3. ****ID
4. ****

## 

- [ShardingSphere ](https://shardingsphere.apache.org/)
- [](https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html)
- [](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)

