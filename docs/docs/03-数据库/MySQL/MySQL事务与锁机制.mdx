---
sidebar_position: 2
title: MySQL
tags: [, MySQL, , , MVCC]
---

# MySQL

MySQLMVCC

## ACID

```javascript
const acidProperties = {
  // Atomicity
  atomicity: {
    definition: '',
    implementation: 'undo log',
    example: ''
  },
  
  // Consistency
  consistency: {
    definition: '',
    implementation: '',
    example: ''
  },
  
  // Isolation
  isolation: {
    definition: '',
    implementation: 'MVCC',
    example: ''
  },
  
  // Durability
  durability: {
    definition: '',
    implementation: 'redo logbinlog',
    example: ''
  }
};
```

## 

### 

```sql
-- 1. READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 
-- A
START TRANSACTION;
UPDATE accounts SET balance = 1000 WHERE id = 1;
-- 

-- B
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1;  -- 1000
COMMIT;

-- A
ROLLBACK;  -- balance1000

-- 2. READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 
-- A
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1;  -- 500

-- B
START TRANSACTION;
UPDATE accounts SET balance = 1000 WHERE id = 1;
COMMIT;

-- A
SELECT balance FROM accounts WHERE id = 1;  -- 1000
COMMIT;

-- 3. REPEATABLE READMySQL
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 
-- A
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 500;  -- 2

-- B
START TRANSACTION;
INSERT INTO accounts (id, balance) VALUES (3, 600);
COMMIT;

-- A
SELECT * FROM accounts WHERE balance > 500;  -- 2
UPDATE accounts SET balance = balance + 100 WHERE balance > 500;  -- 3
COMMIT;

-- 4. SERIALIZABLE
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1;  -- 
-- 
COMMIT;
```

### 

```javascript
const isolationLevels = {
  'READ UNCOMMITTED': {
    dirtyRead: true,      // 
    nonRepeatableRead: true,  // 
    phantomRead: true,    // 
    performance: '',
    usage: ''
  },
  
  'READ COMMITTED': {
    dirtyRead: false,
    nonRepeatableRead: true,
    phantomRead: true,
    performance: '',
    usage: 'OraclePostgreSQL'
  },
  
  'REPEATABLE READ': {
    dirtyRead: false,
    nonRepeatableRead: false,
    phantomRead: false,   // MySQLNext-Key Lock
    performance: '',
    usage: 'MySQL'
  },
  
  'SERIALIZABLE': {
    dirtyRead: false,
    nonRepeatableRead: false,
    phantomRead: false,
    performance: '',
    usage: ''
  }
};
```

## MVCC

### 

```sql
-- InnoDB
/*
DB_TRX_ID: ID6
DB_ROLL_PTR: 7
DB_ROW_ID: ID6
*/

-- 
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance INT,
    -- 
    -- DB_TRX_ID
    -- DB_ROLL_PTR
);

-- 
INSERT INTO accounts VALUES (1, 500);
-- 1: balance=500, trx_id=100

-- 101
UPDATE accounts SET balance = 600 WHERE id = 1;
-- 2: balance=600, trx_id=101, roll_ptr -> 1

-- 102
UPDATE accounts SET balance = 700 WHERE id = 1;
-- 3: balance=700, trx_id=102, roll_ptr -> 2

-- 3 -> 2 -> 1
```

### ReadView

```javascript
class ReadView {
  constructor(trxId) {
    this.creatorTrxId = trxId;           // ReadViewID
    this.trxIds = [];                     // ID
    this.minTrxId = Math.min(...this.trxIds);  // ID
    this.maxTrxId = Math.max(...this.trxIds);  // ID
  }
  
  // 
  isVisible(versionTrxId) {
    // 1. 
    if (versionTrxId === this.creatorTrxId) {
      return true;
    }
    
    // 2. ReadView
    if (versionTrxId < this.minTrxId) {
      return true;
    }
    
    // 3. ReadView
    if (versionTrxId >= this.maxTrxId) {
      return false;
    }
    
    // 4. 
    if (this.trxIds.includes(versionTrxId)) {
      return false;
    }
    
    // 5. 
    return true;
  }
}

// RCRR
const mvccDifference = {
  'READ COMMITTED': {
    readView: 'ReadView',
    result: ''
  },
  
  'REPEATABLE READ': {
    readView: 'ReadView',
    result: ''
  }
};
```

## 

### 

```sql
-- 1. S- 
SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;

-- 2. X- 
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- 3. Intention Lock
-- IS
-- IX

-- 
/*
        S    X    IS   IX
S                   
X                   
IS                  
IX                  
*/

-- 4. 
-- Record Lock
UPDATE accounts SET balance = 1000 WHERE id = 1;

-- Gap Lock
SELECT * FROM accounts WHERE id > 5 AND id < 10 FOR UPDATE;

-- Next-Key LockRecord Lock + Gap Lock
-- 
SELECT * FROM accounts WHERE id >= 5 FOR UPDATE;

-- 5. 
LOCK TABLES accounts READ;   -- 
LOCK TABLES accounts WRITE;  -- 
UNLOCK TABLES;

-- 6. 
-- AUTO-INC Lock
-- ID
```

### 

```sql
-- 
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance INT,
    INDEX idx_balance (balance)
);

INSERT INTO accounts VALUES 
(1, 100), (5, 500), (10, 1000), (15, 1500);

-- 1. Record Lock
-- A
START TRANSACTION;
SELECT * FROM accounts WHERE id = 5 FOR UPDATE;  -- id=5

-- B
UPDATE accounts SET balance = 600 WHERE id = 5;  -- 
UPDATE accounts SET balance = 200 WHERE id = 1;  -- 

-- 2. Gap Lock
-- A
START TRANSACTION;
SELECT * FROM accounts WHERE id > 5 AND id < 10 FOR UPDATE;

-- (5, 10)
-- B
INSERT INTO accounts VALUES (7, 700);  -- 
INSERT INTO accounts VALUES (11, 1100);  -- 

-- 3. Next-Key Lock
-- A
START TRANSACTION;
SELECT * FROM accounts WHERE id >= 5 FOR UPDATE;

-- (1, 5], (5, 10], (10, 15], (15, +âˆž)
-- B
INSERT INTO accounts VALUES (3, 300);   -- 
INSERT INTO accounts VALUES (7, 700);   -- 
INSERT INTO accounts VALUES (20, 2000); -- 
```

### 

```sql
-- 
-- A
START TRANSACTION;
UPDATE accounts SET balance = 1000 WHERE id = 1;  -- id=1

-- B
START TRANSACTION;
UPDATE accounts SET balance = 2000 WHERE id = 2;  -- id=2

-- A
UPDATE accounts SET balance = 1500 WHERE id = 2;  -- Bid=2

-- B
UPDATE accounts SET balance = 2500 WHERE id = 1;  -- Aid=1
-- MySQL

-- 
SHOW ENGINE INNODB STATUS;

-- 
-- 1. 
-- 2. 
-- 3. 
-- 4. 
-- 5. 
```

## 

### 1. 

```sql
--  
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- 
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

--  
-- 
-- 
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

### 2. 

```sql
--  
UPDATE accounts SET balance = 1000 WHERE name = 'John';

--  
CREATE INDEX idx_name ON accounts(name);
UPDATE accounts SET balance = 1000 WHERE name = 'John';
```

### 3. 

```sql
-- 
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance INT,
    version INT DEFAULT 0
);

-- 
UPDATE accounts 
SET balance = balance - 100, version = version + 1
WHERE id = 1 AND version = 10;

-- 
SELECT ROW_COUNT();  -- 0
```

### 4. 

```javascript
class SegmentLock {
  constructor(segmentCount = 16) {
    this.segmentCount = segmentCount;
    this.locks = Array(segmentCount).fill(null).map(() => new Lock());
  }
  
  getSegment(key) {
    const hash = this.hashCode(key);
    return hash % this.segmentCount;
  }
  
  async lock(key) {
    const segment = this.getSegment(key);
    await this.locks[segment].acquire();
  }
  
  unlock(key) {
    const segment = this.getSegment(key);
    this.locks[segment].release();
  }
  
  hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

## 

### 

```javascript
class TransferService {
  async transfer(fromId, toId, amount) {
    const connection = await db.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // 1. ID
      const [from, to] = fromId < toId ? [fromId, toId] : [toId, fromId];
      
      const [fromAccount] = await connection.query(
        'SELECT * FROM accounts WHERE id = ? FOR UPDATE',
        [from]
      );
      
      const [toAccount] = await connection.query(
        'SELECT * FROM accounts WHERE id = ? FOR UPDATE',
        [to]
      );
      
      // 2. 
      const actualFrom = fromId < toId ? fromAccount : toAccount;
      if (actualFrom.balance < amount) {
        throw new Error('');
      }
      
      // 3. 
      await connection.query(
        'UPDATE accounts SET balance = balance - ? WHERE id = ?',
        [amount, fromId]
      );
      
      // 4. 
      await connection.query(
        'UPDATE accounts SET balance = balance + ? WHERE id = ?',
        [amount, toId]
      );
      
      // 5. 
      await connection.query(
        'INSERT INTO transactions (from_id, to_id, amount) VALUES (?, ?, ?)',
        [fromId, toId, amount]
      );
      
      await connection.commit();
      
      return { success: true };
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}
```

### 

```javascript
// 2PC
class TwoPhaseCommit {
  async execute(operations) {
    const participants = [];
    
    try {
      // 1
      for (const op of operations) {
        const prepared = await op.prepare();
        participants.push({ op, prepared });
      }
      
      // 2
      for (const { op } of participants) {
        await op.commit();
      }
      
      return { success: true };
      
    } catch (error) {
      // 
      for (const { op, prepared } of participants) {
        if (prepared) {
          await op.rollback();
        }
      }
      
      throw error;
    }
  }
}

// TCCTry-Confirm-Cancel
class TCCTransaction {
  async execute(actions) {
    const tryResults = [];
    
    try {
      // Try
      for (const action of actions) {
        const result = await action.try();
        tryResults.push({ action, result });
      }
      
      // Confirm
      for (const { action, result } of tryResults) {
        await action.confirm(result);
      }
      
      return { success: true };
      
    } catch (error) {
      // Cancel
      for (const { action, result } of tryResults) {
        await action.cancel(result);
      }
      
      throw error;
    }
  }
}
```

## 

```sql
-- 
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;

-- 
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

-- 
SELECT * FROM performance_schema.data_locks;

-- 
SHOW ENGINE INNODB STATUS;

-- 
SELECT @@transaction_isolation;
SELECT @@global.transaction_isolation;
```

## 

MySQL
-  **ACID**
-  ****RURCRRSerializable
-  **MVCC**
-  ****
-  ****
-  ****

****

