---
sidebar_position: 11
title: 
tags: [, , , ]
---

# 



## 1

### 

```javascript
const requirements = {
  // 
  features: {
    post: '',
    timeline: '',
    follow: '',
    like: '',
    search: ''
  },
  
  // 
  scale: {
    users: 500_000_000,        // 5
    dau: 100_000_000,          // 1DAU
    postsPerDay: 100_000_000,  // 1/
    avgFollowers: 200,         // 200
    readWriteRatio: 100        // 100:1
  },
  
  // 
  performance: {
    timelineLatency: 200,      // 200ms
    postLatency: 500,          // 500ms
    availability: 99.99        // 49
  }
};
```

### 

```

              CDN                       
                        

                 

                                
  Nginx  LVS                             

                 

                                
                

                 

                                    
  Redis Cluster                           

                 

                                    
  MySQL  MongoDB  HBase                

```

### 

#### 1. 

```javascript
class PostService {
  async publishPost(userId, content, images) {
    // 1. ID
    const postId = snowflake.generate();
    
    // 2. 
    const post = {
      id: postId,
      userId,
      content,
      images,
      createdAt: Date.now()
    };
    
    await mongodb.posts.insertOne(post);
    
    // 3. 
    await this.fanoutToFollowers(userId, post);
    
    // 4. 
    await redis.hincrby(`user:${userId}`, 'postCount', 1);
    
    return post;
  }
  
  async fanoutToFollowers(userId, post) {
    // 
    const followers = await this.getFollowers(userId);
    
    // V
    if (followers.length > 10000) {
      // V
      await redis.zadd(`bigv:posts:${userId}`, post.createdAt, post.id);
    } else {
      // 
      const pipeline = redis.pipeline();
      
      for (const followerId of followers) {
        pipeline.zadd(
          `timeline:${followerId}`,
          post.createdAt,
          JSON.stringify(post)
        );
        
        // 1000
        pipeline.zremrangebyrank(`timeline:${followerId}`, 0, -1001);
      }
      
      await pipeline.exec();
    }
  }
}
```

#### 2. 

```javascript
class TimelineService {
  async getTimeline(userId, page = 1, pageSize = 20) {
    // 1. Redis
    const cacheKey = `timeline:${userId}`;
    const start = (page - 1) * pageSize;
    const end = start + pageSize - 1;
    
    let posts = await redis.zrevrange(cacheKey, start, end);
    
    if (posts.length === 0) {
      // 2. 
      posts = await this.rebuildTimeline(userId);
    }
    
    // 3. V
    const bigVPosts = await this.getBigVPosts(userId);
    posts = this.mergePosts(posts, bigVPosts);
    
    // 4. 
    return await this.enrichPosts(posts);
  }
  
  async rebuildTimeline(userId) {
    // 
    const followings = await this.getFollowings(userId);
    
    const allPosts = [];
    
    for (const followingId of followings) {
      // 
      const posts = await mongodb.posts
        .find({ userId: followingId })
        .sort({ createdAt: -1 })
        .limit(100)
        .toArray();
      
      allPosts.push(...posts);
    }
    
    // 
    allPosts.sort((a, b) => b.createdAt - a.createdAt);
    
    // 
    const pipeline = redis.pipeline();
    for (const post of allPosts.slice(0, 1000)) {
      pipeline.zadd(
        `timeline:${userId}`,
        post.createdAt,
        JSON.stringify(post)
      );
    }
    await pipeline.exec();
    
    return allPosts.slice(0, 20);
  }
  
  async getBigVPosts(userId) {
    // V
    const bigVs = await redis.smembers(`user:${userId}:bigv_followings`);
    
    const posts = [];
    
    for (const bigVId of bigVs) {
      // V
      const bigVPosts = await redis.zrevrange(
        `bigv:posts:${bigVId}`,
        0,
        9
      );
      posts.push(...bigVPosts);
    }
    
    return posts;
  }
  
  mergePosts(normalPosts, bigVPosts) {
    // 
    const all = [...normalPosts, ...bigVPosts];
    return all.sort((a, b) => b.createdAt - a.createdAt);
  }
}
```

#### 3. 

```javascript
class RelationService {
  async follow(followerId, followeeId) {
    // 1. 
    const isFollowing = await redis.sismember(
      `user:${followerId}:followings`,
      followeeId
    );
    
    if (isFollowing) {
      return { success: false, message: 'Already following' };
    }
    
    // 2. 
    const pipeline = redis.pipeline();
    
    // 
    pipeline.sadd(`user:${followerId}:followings`, followeeId);
    
    // 
    pipeline.sadd(`user:${followeeId}:followers`, followerId);
    
    // 
    pipeline.hincrby(`user:${followerId}`, 'followingCount', 1);
    pipeline.hincrby(`user:${followeeId}`, 'followerCount', 1);
    
    await pipeline.exec();
    
    // 3. 
    await this.pushRecentPosts(followerId, followeeId);
    
    return { success: true };
  }
  
  async unfollow(followerId, followeeId) {
    const pipeline = redis.pipeline();
    
    pipeline.srem(`user:${followerId}:followings`, followeeId);
    pipeline.srem(`user:${followeeId}:followers`, followerId);
    pipeline.hincrby(`user:${followerId}`, 'followingCount', -1);
    pipeline.hincrby(`user:${followeeId}`, 'followerCount', -1);
    
    await pipeline.exec();
    
    // 
    await this.removePostsFromTimeline(followerId, followeeId);
  }
}
```

## 2

### 

```javascript
const ecommerceArchitecture = {
  // 
  frontend: {
    web: 'React SPA',
    mobile: 'React Native',
    cdn: 'CloudFlare'
  },
  
  // 
  gateway: {
    apiGateway: 'Kong',
    rateLimiting: true,
    authentication: 'JWT'
  },
  
  // 
  services: {
    user: '',
    product: '',
    order: '',
    payment: '',
    inventory: '',
    cart: '',
    search: ''
  },
  
  // 
  data: {
    mysql: '',
    mongodb: '',
    redis: '',
    elasticsearch: ''
  }
};
```

### 

```javascript
class SeckillService {
  async initSeckill(productId, stock) {
    // 1. Redis
    await redis.set(`seckill:${productId}:stock`, stock);
    
    // 2. 
    await redis.set(`seckill:${productId}:tokens`, stock * 2);
    
    // 3. 
    const product = await this.getProduct(productId);
    await redis.setex(
      `seckill:${productId}:info`,
      3600,
      JSON.stringify(product)
    );
  }
  
  async seckill(userId, productId) {
    // 1. 
    const hasToken = await this.acquireToken(productId);
    if (!hasToken) {
      return { success: false, message: '' };
    }
    
    // 2. 
    const hasBought = await redis.sismember(
      `seckill:${productId}:buyers`,
      userId
    );
    
    if (hasBought) {
      return { success: false, message: '' };
    }
    
    // 3. Lua
    const stockKey = `seckill:${productId}:stock`;
    const result = await redis.eval(`
      local stock = redis.call('get', KEYS[1])
      if tonumber(stock) > 0 then
        redis.call('decr', KEYS[1])
        return 1
      else
        return 0
      end
    `, 1, stockKey);
    
    if (result === 0) {
      return { success: false, message: '' };
    }
    
    // 4. 
    await this.createOrderAsync(userId, productId);
    
    // 5. 
    await redis.sadd(`seckill:${productId}:buyers`, userId);
    
    return { success: true, message: '' };
  }
  
  async acquireToken(productId) {
    const tokenKey = `seckill:${productId}:tokens`;
    const tokens = await redis.decr(tokenKey);
    
    if (tokens < 0) {
      await redis.incr(tokenKey);
      return false;
    }
    
    return true;
  }
  
  async createOrderAsync(userId, productId) {
    // 
    await kafka.send('seckill-orders', [{
      value: {
        userId,
        productId,
        timestamp: Date.now()
      }
    }]);
  }
}
```

### 

```javascript
class OrderService {
  async createOrder(userId, items) {
    // 1. ID
    const orderId = snowflake.generate();
    
    // 2. 
    const transaction = await this.beginTransaction();
    
    try {
      // 3. 
      for (const item of items) {
        const locked = await this.lockInventory(
          item.productId,
          item.quantity,
          transaction
        );
        
        if (!locked) {
          throw new Error(`: ${item.productId}`);
        }
      }
      
      // 4. 
      const order = {
        id: orderId,
        userId,
        items,
        totalAmount: this.calculateTotal(items),
        status: 'pending',
        createdAt: Date.now()
      };
      
      await this.saveOrder(order, transaction);
      
      // 5. 
      await transaction.commit();
      
      // 6. 
      await this.publishOrderCreated(order);
      
      return order;
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
  
  async lockInventory(productId, quantity, transaction) {
    // SELECT FOR UPDATE
    const result = await transaction.query(`
      UPDATE inventory
      SET available = available - ?,
          locked = locked + ?
      WHERE product_id = ? AND available >= ?
    `, [quantity, quantity, productId, quantity]);
    
    return result.affectedRows > 0;
  }
  
  async payOrder(orderId, paymentInfo) {
    // 1. 
    const paymentResult = await paymentService.pay(paymentInfo);
    
    if (!paymentResult.success) {
      return { success: false, message: '' };
    }
    
    // 2. 
    await this.updateOrderStatus(orderId, 'paid');
    
    // 3. 
    const order = await this.getOrder(orderId);
    for (const item of order.items) {
      await this.deductInventory(item.productId, item.quantity);
    }
    
    // 4. 
    await this.publishOrderPaid(order);
    
    return { success: true };
  }
  
  async deductInventory(productId, quantity) {
    await db.query(`
      UPDATE inventory
      SET locked = locked - ?,
          sold = sold + ?
      WHERE product_id = ?
    `, [quantity, quantity, productId]);
  }
}
```

## 3

### 

```javascript
const videoArchitecture = {
  // 
  upload: {
    client: '',
    storage: 'OSS',
    transcode: '',
    cdn: 'CDN'
  },
  
  // 
  playback: {
    cdn: 'CDN',
    adaptiveBitrate: '',
    drm: 'DRM',
    analytics: ''
  },
  
  // 
  recommendation: {
    collaborative: '',
    contentBased: '',
    trending: '',
    personalized: ''
  }
};
```

### 

```javascript
class VideoUploadService {
  async uploadVideo(file, metadata) {
    // 1. 
    const chunks = this.splitFile(file, 5 * 1024 * 1024); // 5MB per chunk
    const uploadId = await this.initiateMultipartUpload(metadata);
    
    const uploadPromises = chunks.map((chunk, index) =>
      this.uploadChunk(uploadId, index, chunk)
    );
    
    const parts = await Promise.all(uploadPromises);
    
    // 2. 
    const videoUrl = await this.completeMultipartUpload(uploadId, parts);
    
    // 3. 
    const videoId = snowflake.generate();
    const video = {
      id: videoId,
      title: metadata.title,
      description: metadata.description,
      originalUrl: videoUrl,
      status: 'processing',
      createdAt: Date.now()
    };
    
    await mongodb.videos.insertOne(video);
    
    // 4. 
    await this.triggerTranscode(videoId, videoUrl);
    
    return video;
  }
  
  async triggerTranscode(videoId, videoUrl) {
    // 
    await kafka.send('video-transcode', [{
      value: {
        videoId,
        videoUrl,
        formats: [
          { resolution: '1080p', bitrate: '5000k' },
          { resolution: '720p', bitrate: '2500k' },
          { resolution: '480p', bitrate: '1000k' },
          { resolution: '360p', bitrate: '500k' }
        ]
      }
    }]);
  }
}

// 
class TranscodeService {
  async transcode(job) {
    const { videoId, videoUrl, formats } = job;
    
    const transcodePromises = formats.map(format =>
      this.transcodeFormat(videoUrl, format)
    );
    
    const results = await Promise.all(transcodePromises);
    
    // 
    await mongodb.videos.updateOne(
      { id: videoId },
      {
        $set: {
          status: 'ready',
          formats: results,
          updatedAt: Date.now()
        }
      }
    );
    
    // CDN
    await this.warmupCDN(results);
  }
  
  async transcodeFormat(videoUrl, format) {
    // FFmpeg
    const outputUrl = await ffmpeg.transcode({
      input: videoUrl,
      output: `${videoUrl}_${format.resolution}`,
      videoCodec: 'h264',
      audioCodec: 'aac',
      resolution: format.resolution,
      bitrate: format.bitrate
    });
    
    return {
      resolution: format.resolution,
      url: outputUrl,
      size: await this.getFileSize(outputUrl)
    };
  }
}
```

### 

```javascript
class VideoPlaybackService {
  async getPlaybackInfo(videoId, userId) {
    // 1. 
    const video = await this.getVideo(videoId);
    
    if (!video || video.status !== 'ready') {
      throw new Error('Video not available');
    }
    
    // 2. 
    const hasPermission = await this.checkPermission(userId, videoId);
    
    if (!hasPermission) {
      throw new Error('No permission');
    }
    
    // 3. CDN
    const cdnNode = await this.selectCDNNode(userId);
    
    // 4. URL
    const playbackUrls = video.formats.map(format => ({
      resolution: format.resolution,
      url: this.generateSignedUrl(format.url, cdnNode)
    }));
    
    // 5. 
    await this.logPlayback(userId, videoId);
    
    return {
      videoId,
      title: video.title,
      duration: video.duration,
      playbackUrls
    };
  }
  
  generateSignedUrl(url, cdnNode) {
    const expireTime = Date.now() + 3600 * 1000; // 1
    const signature = crypto
      .createHmac('sha256', process.env.CDN_SECRET)
      .update(`${url}${expireTime}`)
      .digest('hex');
    
    return `${cdnNode}${url}?expire=${expireTime}&sign=${signature}`;
  }
  
  async logPlayback(userId, videoId) {
    // Kafka
    await kafka.send('video-playback', [{
      value: {
        userId,
        videoId,
        timestamp: Date.now()
      }
    }]);
    
    // 
    await redis.hincrby(`video:${videoId}`, 'playCount', 1);
  }
}
```

## 

```javascript
const optimizationStrategies = {
  // 
  caching: {
    cdn: 'CDN',
    redis: 'Redis',
    localCache: '',
    cacheAside: 'Cache-Aside',
    writeThrough: 'Write-Through'
  },
  
  // 
  database: {
    indexing: '',
    sharding: '',
    readWriteSplit: '',
    denormalization: '',
    connectionPool: ''
  },
  
  // 
  async: {
    messageQueue: '',
    asyncTask: '',
    eventDriven: ''
  },
  
  // 
  protection: {
    rateLimiting: '',
    circuitBreaker: '',
    bulkhead: '',
    timeout: ''
  }
};
```

## 


-  **** + 
-  **** + 
-  **** + 
-  **** + 
-  **** + 
-  **** + 

****

