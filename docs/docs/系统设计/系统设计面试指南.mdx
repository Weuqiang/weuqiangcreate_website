---
sidebar_position: 2
title: 
tags: [, , ]
---

# 



## 

### 

```mermaid
graph LR
    A[] --> B[]
    B --> C[]
    C --> D[]
    D --> E[]
    
    style A fill:#e1f5ff
    style C fill:#ffe1e1
    style E fill:#e1ffe1
```

****45-60:
- 5-10
- 5-10
- 15-20
- 10-15
- 5-10

## 

### SNAKE

**S - Scenario**
- 
- 
- 

**N - Necessary**
- 
- 
- 

**A - Application**
- 
- 
- API

**K - Kilobit**
- 
- 
- 

**E - Evolve**
- 
- 
- 

## 

### 

```markdown
## 
- 
- 
- 
- 
- 

## 
- QPS/TPS
- 
- 9
- 
- 

## 
- 
- 
- 
- 
```

### 

```




1. 
   - URL
   - URL
   - 
   - 
   - 

2. 
   - 
   - 
   - 

3. 
   - 
   - 9
   - 

1001100:1
        100ms99.9%
```

## 

### 

```python
# 1. 
DAU = 100_000_000  # 
 = 10
QPS_ = (DAU * ) / 86400
QPS_ = QPS_ * 3  # 3

print(f"QPS: {QPS_:,.0f}")
print(f"QPS: {QPS_:,.0f}")

# 2. 
 = 1024  # 1KB
 = 1_000_000
_ = 365 * 5  # 5

 =  *  * _
_TB =  / (1024 ** 4)

print(f": {_TB:.2f} TB")

# 3. 
 = 100  # 100
 = 500  # 500

 = QPS_ *  * 8 / (1024 ** 2)  # Mbps
 = QPS_ *  * 8 / (1024 ** 2)  # Mbps

print(f": {:.2f} Mbps")
print(f": {:.2f} Mbps")

# 4. 
 = 0.2  # 20%80%
 = 0.8

 =  * 
_GB =  / (1024 ** 3)

print(f": {_GB:.2f} GB")
```

### 

```

- L10.5 ns
- L27 ns
- 100 ns
- SSD150 Î¼s
- HDD10 ms
- 0.5 ms
- 150 ms


- 1 KB = 1,024 
- 1 MB = 1,024 KB
- 1 GB = 1,024 MB
- 1 TB = 1,024 GB


- 99% = 3.65/
- 99.9% = 8.76/
- 99.99% = 52.56/
- 99.999% = 5.26/
```

## 

### 

```

    

     
     

    

       
   
          
 
 API   API 
 
 
          
   
       
   
           
 
     
 
```

### 

```javascript
// API
class URLShortenerAPI {
  // 
  async createShortURL(longURL, customAlias = null, expireTime = null) {
    // 1. URL
    if (!this.isValidURL(longURL)) {
      throw new Error('Invalid URL');
    }
    
    // 2. 
    const existing = await this.cache.get(longURL);
    if (existing) {
      return existing;
    }
    
    // 3. 
    const shortCode = customAlias || this.generateShortCode();
    
    // 4. 
    if (await this.db.exists(shortCode)) {
      return this.createShortURL(longURL, null, expireTime);
    }
    
    // 5. 
    await this.db.save({
      shortCode,
      longURL,
      createdAt: Date.now(),
      expireTime
    });
    
    // 6. 
    await this.cache.set(shortCode, longURL, expireTime);
    
    return `https://short.url/${shortCode}`;
  }
  
  // 
  async redirect(shortCode) {
    // 1. 
    let longURL = await this.cache.get(shortCode);
    
    // 2. 
    if (!longURL) {
      const record = await this.db.get(shortCode);
      if (!record) {
        throw new Error('URL not found');
      }
      
      // 
      if (record.expireTime && Date.now() > record.expireTime) {
        throw new Error('URL expired');
      }
      
      longURL = record.longURL;
      
      // 
      await this.cache.set(shortCode, longURL);
    }
    
    // 3. 
    this.analytics.track(shortCode);
    
    return longURL;
  }
  
  // 
  generateShortCode() {
    // Base62
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const id = this.getNextID();
    let shortCode = '';
    
    while (id > 0) {
      shortCode = chars[id % 62] + shortCode;
      id = Math.floor(id / 62);
    }
    
    return shortCode.padStart(7, '0');
  }
}
```

## 

### Schema

```sql
-- URL
CREATE TABLE url_mappings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    long_url TEXT NOT NULL,
    user_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_at TIMESTAMP,
    INDEX idx_short_code (short_code),
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- 
CREATE TABLE url_analytics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_code VARCHAR(10) NOT NULL,
    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),
    user_agent TEXT,
    referer TEXT,
    INDEX idx_short_code (short_code),
    INDEX idx_clicked_at (clicked_at)
);

-- 
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 

```javascript
// 
class ShardingStrategy {
  // 
  getShardByShortCode(shortCode) {
    const hash = this.hashCode(shortCode);
    return hash % this.shardCount;
  }
  
  // ID
  getShardByUserID(userID) {
    return userID % this.shardCount;
  }
  
  // 
  getShardByConsistentHash(key) {
    const hash = this.hashCode(key);
    // 
    for (const node of this.ring) {
      if (hash <= node.hash) {
        return node.shard;
      }
    }
    return this.ring[0].shard;
  }
}
```

## 

### 

```javascript
class CacheManager {
  constructor() {
    this.l1Cache = new LRUCache(10000);  // 
    this.l2Cache = new RedisCache();      // 
  }
  
  async get(key) {
    // 1. L1
    let value = this.l1Cache.get(key);
    if (value) {
      return value;
    }
    
    // 2. L2
    value = await this.l2Cache.get(key);
    if (value) {
      this.l1Cache.set(key, value);
      return value;
    }
    
    // 3. 
    value = await this.db.get(key);
    if (value) {
      this.l1Cache.set(key, value);
      await this.l2Cache.set(key, value, 3600);
    }
    
    return value;
  }
  
  async set(key, value, ttl) {
    // L1L2
    this.l1Cache.set(key, value);
    await this.l2Cache.set(key, value, ttl);
  }
}
```

### 

```javascript
// Cache-Aside
async function getURL(shortCode) {
  // 
  let url = await cache.get(shortCode);
  if (!url) {
    url = await db.get(shortCode);
    if (url) {
      await cache.set(shortCode, url);
    }
  }
  return url;
}

async function updateURL(shortCode, newURL) {
  // 
  await db.update(shortCode, newURL);
  await cache.delete(shortCode);
}

// Write-Through
async function updateURLWriteThrough(shortCode, newURL) {
  // 
  await Promise.all([
    cache.set(shortCode, newURL),
    db.update(shortCode, newURL)
  ]);
}
```

## 

### 

```javascript
// 1. 
async function warmupCache() {
  const hotURLs = await db.getTopURLs(1000);
  await Promise.all(
    hotURLs.map(url => cache.set(url.shortCode, url.longURL))
  );
}

// 2. 
class BloomFilter {
  async exists(shortCode) {
    // 
    return this.bloomFilter.contains(shortCode);
  }
}

async function getURLWithBloomFilter(shortCode) {
  // 
  if (!await bloomFilter.exists(shortCode)) {
    return null;  // 
  }
  
  // 
  return await getURL(shortCode);
}

// 3. 
async function getURLWithNullCache(shortCode) {
  let url = await cache.get(shortCode);
  
  if (url === null) {
    return null;  // 
  }
  
  if (!url) {
    url = await db.get(shortCode);
    // TTL
    await cache.set(shortCode, url || null, url ? 3600 : 60);
  }
  
  return url;
}
```

### 

```javascript
// 1. 
class BatchWriter {
  constructor() {
    this.buffer = [];
    this.batchSize = 1000;
    this.flushInterval = 5000;
    
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  async write(data) {
    this.buffer.push(data);
    
    if (this.buffer.length >= this.batchSize) {
      await this.flush();
    }
  }
  
  async flush() {
    if (this.buffer.length === 0) return;
    
    const batch = this.buffer.splice(0, this.batchSize);
    await db.batchInsert(batch);
  }
}

// 2. 
async function trackClick(shortCode) {
  // 
  analytics.track(shortCode).catch(err => {
    logger.error('Failed to track click', err);
  });
}

// 3. 
async function trackClickWithQueue(shortCode) {
  await messageQueue.publish('analytics', {
    shortCode,
    timestamp: Date.now(),
    ip: request.ip
  });
}
```

## 

### 

```javascript
// 
class StatelessAPIServer {
  // 
  // 
  
  async handleRequest(request) {
    // 
    const token = request.headers.authorization;
    const user = await this.auth.verify(token);
    
    // 
    return this.processRequest(request, user);
  }
}

// 
class DatabaseSharding {
  constructor(shards) {
    this.shards = shards;
  }
  
  getShard(key) {
    const hash = this.hash(key);
    return this.shards[hash % this.shards.length];
  }
  
  async get(key) {
    const shard = this.getShard(key);
    return await shard.get(key);
  }
  
  async set(key, value) {
    const shard = this.getShard(key);
    return await shard.set(key, value);
  }
}
```

## 

### Q1: 

```javascript
// 1ID + Base62
function generateShortCode(id) {
  const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  while (id > 0) {
    code = chars[id % 62] + code;
    id = Math.floor(id / 62);
  }
  return code;
}

// 2IDSnowflake
class SnowflakeIDGenerator {
  generate() {
    // 41 + 10ID + 12
    const timestamp = Date.now() - this.epoch;
    const id = (timestamp << 22) | (this.workerId << 12) | this.sequence;
    this.sequence = (this.sequence + 1) & 0xFFF;
    return id;
  }
}

// 3 + 
async function generateUniqueShortCode(longURL) {
  let shortCode = hash(longURL).substring(0, 7);
  let attempts = 0;
  
  while (await db.exists(shortCode) && attempts < 10) {
    shortCode = hash(longURL + attempts).substring(0, 7);
    attempts++;
  }
  
  if (attempts >= 10) {
    throw new Error('Failed to generate unique short code');
  }
  
  return shortCode;
}
```

### Q2: 

```javascript
// 1. 
const localCache = new LRUCache(1000);

// 2. 
async function getHotURL(shortCode) {
  // L1: 
  let url = localCache.get(shortCode);
  if (url) return url;
  
  // L2: Redis
  url = await redis.get(shortCode);
  if (url) {
    localCache.set(shortCode, url);
    return url;
  }
  
  // L3: 
  url = await db.get(shortCode);
  if (url) {
    localCache.set(shortCode, url);
    await redis.set(shortCode, url, 3600);
  }
  
  return url;
}

// 3. CDN
// CDN
```

### Q3: 

```javascript
// 1. 
const replicas = [db1, db2, db3];

async function writeWithReplication(key, value) {
  // 
  await replicas[0].write(key, value);
  
  // 
  Promise.all(
    replicas.slice(1).map(replica => replica.write(key, value))
  ).catch(err => logger.error('Replication failed', err));
}

// 2. 
async function readWithFailover(key) {
  for (const replica of replicas) {
    try {
      return await replica.read(key);
    } catch (err) {
      logger.warn(`Replica ${replica.id} failed`, err);
      continue;
    }
  }
  throw new Error('All replicas failed');
}

// 3. 
class CircuitBreaker {
  async call(fn) {
    if (this.state === 'OPEN') {
      throw new Error('Circuit breaker is open');
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (err) {
      this.onFailure();
      throw err;
    }
  }
}
```

## 

### DO
-  
-  
-  
-  
-  
-  

### DON'T
-  
-  
-  
-  
-  
-  

### 
```
1. 
   "..."
   "..."

2. 
   ""
   ""

3. 
   "A......"
   "XYZ"

4. 
   "..."
   "X"
```

## 


-  ****
-  ****QPS
-  ****
-  ****API
-  ****
-  ****

****

