---
sidebar_position: 5
title: 
tags: [, , WebSocket, ]
---

# 



## 

### 

```javascript
const requirements = {
  // 
  messaging: {
    oneToOne: true,        // 
    group: true,           // 
    typing: true,          // 
    readReceipt: true,     // 
    offline: true          // 
  },
  
  // 
  messageTypes: {
    text: true,            // 
    image: true,           // 
    video: true,           // 
    file: true,            // 
    voice: true,           // 
    location: true         // 
  },
  
  // 
  extended: {
    presence: true,        // 
    notification: true,    // 
    search: true,          // 
    sync: true            // 
  }
};
```

### 

```python
# 
 = 100_000_000        # 1DAU
 =  * 0.3      # 30%
 = 50

# 
 =  * 
QPS =  / 86400

print(f": {:,}")
print(f": {:,}")
print(f"QPS: {QPS:,.0f}")

# 
 = 1024           # 1KB
 = 3
_TB = ( * 365 *  * ) / (1024 ** 4)

print(f": {_TB:.2f} TB")

# 
 = 10000
 =  / 

print(f": {:,.0f}")
```

## 

### 

```

                                  
  iOS App    Android    Web    PC     

                 

           Gateway              
  WebSocket Server Cluster               

                 

                                
                

                 

                                    
  Redis    MySQL    MongoDB    OSS    

```

### 

```javascript
const techStack = {
  // 
  protocol: {
    websocket: 'Socket.IO / ws',
    fallback: 'Long Polling',
    mobile: 'TCP'
  },
  
  // 
  messageQueue: {
    kafka: '',
    redis: '',
    rabbitmq: ''
  },
  
  // 
  storage: {
    redis: '',
    mongodb: '',
    mysql: '',
    oss: ''
  }
};
```

## WebSocket

### 

```javascript
class WebSocketServer {
  constructor() {
    this.connections = new Map(); // userId -> WebSocket
    this.userSessions = new Map(); // userId -> sessionInfo
  }
  
  async handleConnection(ws, userId) {
    // 1. token
    const token = ws.handshake.auth.token;
    const user = await this.verifyToken(token);
    
    if (!user) {
      ws.close(4001, 'Unauthorized');
      return;
    }
    
    // 2. 
    this.connections.set(userId, ws);
    
    // 3. 
    await this.updatePresence(userId, 'online');
    
    // 4. 
    await this.loadOfflineMessages(userId, ws);
    
    // 5. 
    await this.syncConversations(userId, ws);
    
    // 6. 
    this.setupEventHandlers(ws, userId);
    
    console.log(`User ${userId} connected`);
  }
  
  setupEventHandlers(ws, userId) {
    // 
    ws.on('message', async (data) => {
      await this.handleMessage(userId, data);
    });
    
    // 
    ws.on('typing', async (data) => {
      await this.handleTyping(userId, data);
    });
    
    // 
    ws.on('read', async (data) => {
      await this.handleRead(userId, data);
    });
    
    // 
    ws.on('disconnect', async () => {
      await this.handleDisconnect(userId);
    });
    
    // 
    ws.on('ping', () => {
      ws.pong();
    });
  }
  
  async handleDisconnect(userId) {
    // 1. 
    this.connections.delete(userId);
    
    // 2. 
    await this.updatePresence(userId, 'offline');
    
    console.log(`User ${userId} disconnected`);
  }
  
  // 
  async sendToUser(userId, message) {
    const ws = this.connections.get(userId);
    
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
      return true;
    }
    
    // 
    await this.storeOfflineMessage(userId, message);
    return false;
  }
}
```

### 

```javascript
class MessageHandler {
  async handleMessage(senderId, data) {
    const { receiverId, content, type, conversationId } = data;
    
    // 1. 
    if (!this.validateMessage(content, type)) {
      throw new Error('Invalid message');
    }
    
    // 2. ID
    const messageId = this.generateMessageId();
    
    // 3. 
    const message = {
      id: messageId,
      conversationId,
      senderId,
      receiverId,
      content,
      type,
      timestamp: Date.now(),
      status: 'sent'
    };
    
    // 4. 
    await this.saveMessage(message);
    
    // 5. 
    const delivered = await wsServer.sendToUser(receiverId, {
      type: 'message',
      data: message
    });
    
    // 6. 
    if (delivered) {
      message.status = 'delivered';
      await this.updateMessageStatus(messageId, 'delivered');
    }
    
    // 7. 
    await wsServer.sendToUser(senderId, {
      type: 'ack',
      data: {
        messageId,
        status: message.status
      }
    });
    
    // 8. 
    await this.updateConversation(conversationId, message);
    
    // 9. 
    if (!delivered) {
      await this.sendPushNotification(receiverId, message);
    }
    
    return message;
  }
  
  generateMessageId() {
    // Snowflake ID
    return snowflake.generate();
  }
  
  async saveMessage(message) {
    // MongoDB
    await mongodb.collection('messages').insertOne(message);
    
    // Redis
    await redis.zadd(
      `conversation:${message.conversationId}:messages`,
      message.timestamp,
      JSON.stringify(message)
    );
  }
  
  async updateConversation(conversationId, message) {
    await redis.hset(`conversation:${conversationId}`, {
      lastMessage: JSON.stringify(message),
      lastMessageTime: message.timestamp,
      unreadCount: await this.incrementUnreadCount(conversationId, message.receiverId)
    });
  }
}
```

## 

### 

```javascript
class GroupManager {
  async createGroup(creatorId, members, groupName) {
    // 1. 
    const groupId = this.generateGroupId();
    
    const group = {
      id: groupId,
      name: groupName,
      creatorId,
      members: [creatorId, ...members],
      createdAt: Date.now()
    };
    
    await db.groups.insertOne(group);
    
    // 2. 
    for (const memberId of group.members) {
      await this.createConversation(memberId, groupId, 'group');
    }
    
    // 3. 
    await this.sendSystemMessage(groupId, `${creatorId} `);
    
    return group;
  }
  
  async sendGroupMessage(senderId, groupId, content) {
    // 1. 
    const isMember = await this.isMember(senderId, groupId);
    if (!isMember) {
      throw new Error('Not a group member');
    }
    
    // 2. 
    const members = await this.getGroupMembers(groupId);
    
    // 3. 
    const message = {
      id: this.generateMessageId(),
      groupId,
      senderId,
      content,
      timestamp: Date.now()
    };
    
    // 4. 
    await this.saveMessage(message);
    
    // 5. 
    const deliveryPromises = members
      .filter(m => m !== senderId)
      .map(memberId => 
        wsServer.sendToUser(memberId, {
          type: 'group_message',
          data: message
        })
      );
    
    await Promise.all(deliveryPromises);
    
    return message;
  }
  
  async isMember(userId, groupId) {
    const group = await db.groups.findOne({ id: groupId });
    return group && group.members.includes(userId);
  }
}
```

## 

### Presence

```javascript
class PresenceService {
  async updatePresence(userId, status) {
    // 1. Redis
    await redis.hset('user:presence', userId, JSON.stringify({
      status,
      lastSeen: Date.now()
    }));
    
    // 2. 
    await redis.expire(`user:presence:${userId}`, 300); // 5
    
    // 3. 
    const friends = await this.getFriends(userId);
    
    for (const friendId of friends) {
      await wsServer.sendToUser(friendId, {
        type: 'presence',
        data: {
          userId,
          status,
          timestamp: Date.now()
        }
      });
    }
  }
  
  async getPresence(userId) {
    const data = await redis.hget('user:presence', userId);
    return data ? JSON.parse(data) : { status: 'offline' };
  }
  
  async batchGetPresence(userIds) {
    const pipeline = redis.pipeline();
    
    for (const userId of userIds) {
      pipeline.hget('user:presence', userId);
    }
    
    const results = await pipeline.exec();
    
    return userIds.reduce((acc, userId, index) => {
      const data = results[index][1];
      acc[userId] = data ? JSON.parse(data) : { status: 'offline' };
      return acc;
    }, {});
  }
}
```

### 

```javascript
class HeartbeatManager {
  constructor() {
    this.heartbeatInterval = 30000; // 30
    this.heartbeatTimeout = 60000;  // 60
  }
  
  startHeartbeat(ws, userId) {
    // 
    const timer = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        clearInterval(timer);
      }
    }, this.heartbeatInterval);
    
    // 
    let lastHeartbeat = Date.now();
    
    ws.on('pong', () => {
      lastHeartbeat = Date.now();
    });
    
    const checkTimer = setInterval(() => {
      if (Date.now() - lastHeartbeat > this.heartbeatTimeout) {
        console.log(`User ${userId} heartbeat timeout`);
        ws.close();
        clearInterval(timer);
        clearInterval(checkTimer);
      }
    }, this.heartbeatInterval);
  }
}
```

## 

### 

```javascript
class SyncService {
  async syncMessages(userId, lastSyncTime) {
    // 1. 
    const conversations = await this.getConversations(userId);
    
    // 2. 
    const syncData = await Promise.all(
      conversations.map(async (conv) => {
        const messages = await this.getNewMessages(
          conv.id,
          lastSyncTime
        );
        
        return {
          conversationId: conv.id,
          messages,
          unreadCount: await this.getUnreadCount(userId, conv.id)
        };
      })
    );
    
    return {
      conversations: syncData,
      syncTime: Date.now()
    };
  }
  
  async getNewMessages(conversationId, since) {
    // MongoDB
    return await mongodb.collection('messages').find({
      conversationId,
      timestamp: { $gt: since }
    }).sort({ timestamp: 1 }).toArray();
  }
}
```

### 

```javascript
class OfflineMessageManager {
  async storeOfflineMessage(userId, message) {
    // 1. Redis
    await redis.lpush(
      `offline:${userId}`,
      JSON.stringify(message)
    );
    
    // 2. 7
    await redis.expire(`offline:${userId}`, 7 * 24 * 3600);
    
    // 3. 
    await redis.hincrby('unread_count', userId, 1);
  }
  
  async loadOfflineMessages(userId) {
    // 1. 
    const messages = await redis.lrange(`offline:${userId}`, 0, -1);
    
    // 2. 
    const parsedMessages = messages.map(msg => JSON.parse(msg));
    
    // 3. 
    await redis.del(`offline:${userId}`);
    
    // 4. 
    await redis.hdel('unread_count', userId);
    
    return parsedMessages;
  }
}
```

## 

### 

```javascript
class PushNotificationService {
  async sendPushNotification(userId, message) {
    // 1. token
    const devices = await this.getUserDevices(userId);
    
    if (devices.length === 0) {
      return;
    }
    
    // 2. 
    const notification = {
      title: this.getSenderName(message.senderId),
      body: this.getMessagePreview(message),
      data: {
        messageId: message.id,
        conversationId: message.conversationId
      }
    };
    
    // 3. 
    const promises = devices.map(device => {
      switch (device.platform) {
        case 'ios':
          return this.sendAPNS(device.token, notification);
        case 'android':
          return this.sendFCM(device.token, notification);
        default:
          return Promise.resolve();
      }
    });
    
    await Promise.all(promises);
  }
  
  async sendAPNS(token, notification) {
    // Apple Push Notification Service
    const apn = require('apn');
    const provider = new apn.Provider({
      token: {
        key: process.env.APN_KEY,
        keyId: process.env.APN_KEY_ID,
        teamId: process.env.APN_TEAM_ID
      }
    });
    
    const note = new apn.Notification();
    note.alert = notification.body;
    note.payload = notification.data;
    note.badge = 1;
    note.sound = 'default';
    
    await provider.send(note, token);
  }
  
  async sendFCM(token, notification) {
    // Firebase Cloud Messaging
    const admin = require('firebase-admin');
    
    await admin.messaging().send({
      token,
      notification: {
        title: notification.title,
        body: notification.body
      },
      data: notification.data
    });
  }
}
```

## 

### 1. 

```javascript
class ConnectionLoadBalancer {
  constructor() {
    this.servers = [
      { host: 'ws1.example.com', connections: 0 },
      { host: 'ws2.example.com', connections: 0 },
      { host: 'ws3.example.com', connections: 0 }
    ];
  }
  
  getServer() {
    // 
    return this.servers.reduce((min, server) => 
      server.connections < min.connections ? server : min
    );
  }
  
  async assignServer(userId) {
    const server = this.getServer();
    
    // 
    await redis.hset('user:server', userId, server.host);
    
    server.connections++;
    
    return server.host;
  }
}
```

### 2. 

```javascript
class MessageSharding {
  constructor(shardCount = 16) {
    this.shardCount = shardCount;
  }
  
  getShardKey(conversationId) {
    const hash = this.hashCode(conversationId);
    return hash % this.shardCount;
  }
  
  async saveMessage(message) {
    const shard = this.getShardKey(message.conversationId);
    const collection = `messages_${shard}`;
    
    await mongodb.collection(collection).insertOne(message);
  }
  
  async getMessages(conversationId, limit = 50) {
    const shard = this.getShardKey(conversationId);
    const collection = `messages_${shard}`;
    
    return await mongodb.collection(collection)
      .find({ conversationId })
      .sort({ timestamp: -1 })
      .limit(limit)
      .toArray();
  }
}
```

### 3. 

```javascript
class MessageCompressor {
  compress(message) {
    const zlib = require('zlib');
    const json = JSON.stringify(message);
    return zlib.gzipSync(json).toString('base64');
  }
  
  decompress(compressed) {
    const zlib = require('zlib');
    const buffer = Buffer.from(compressed, 'base64');
    const json = zlib.gunzipSync(buffer).toString();
    return JSON.parse(json);
  }
}
```

## 

### 1. 

```javascript
class MessageEncryption {
  encrypt(message, key) {
    const crypto = require('crypto');
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    
    let encrypted = cipher.update(JSON.stringify(message), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
      iv: iv.toString('hex'),
      data: encrypted
    };
  }
  
  decrypt(encrypted, key) {
    const crypto = require('crypto');
    const iv = Buffer.from(encrypted.iv, 'hex');
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    
    let decrypted = decipher.update(encrypted.data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}
```

### 2. 

```javascript
class ContentFilter {
  constructor() {
    this.sensitiveWords = new Set([
      '1',
      '2'
    ]);
  }
  
  filter(content) {
    let filtered = content;
    
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      filtered = filtered.replace(regex, '*'.repeat(word.length));
    }
    
    return filtered;
  }
  
  containsSensitiveWord(content) {
    for (const word of this.sensitiveWords) {
      if (content.includes(word)) {
        return true;
      }
    }
    return false;
  }
}
```

## 

```javascript
class MonitoringSystem {
  async monitor() {
    // 1. 
    const onlineUsers = await redis.hlen('user:presence');
    
    // 2. QPS
    const messageQPS = await this.getMessageQPS();
    
    // 3. WebSocket
    const connections = wsServer.connections.size;
    
    // 4. 
    const latency = await this.getMessageLatency();
    
    // 5. 
    const pushSuccessRate = await this.getPushSuccessRate();
    
    // 
    await this.recordMetrics({
      onlineUsers,
      messageQPS,
      connections,
      latency,
      pushSuccessRate
    });
    
    // 
    if (latency > 1000) {
      await this.alert('High message latency', { latency });
    }
  }
}
```

## 


-  ****WebSocket + 
-  **** +  + 
-  **** + 
-  ****APNS + FCM
-  **** +  + 
-  **** + 
-  **** + 

****

