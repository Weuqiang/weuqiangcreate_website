---
sidebarDepth: 4
---
# 

## 

### [94. ](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

``` js
var inorderTraversal = function(root) {
    return Array.from(fn(root))
};

function* fn(root) {
    if (root) {
        yield* fn(root.left)
        yield root.val
        yield* fn(root.right)
    }
}
```

### [98. ](https://leetcode.cn/problems/validate-binary-search-tree/)

``` js
var isValidBST = function(root) {
    return helper(root)
};

function helper(root, min = -Infinity, max = Infinity) {
    if (!root) return true;
    const { val, left, right } = root    
    if (val <= min || val >= max) return false;

    return helper(left, min, val) && helper(right, val, max);
}
```

``` js
var isValidBST = function(root) {
    try {
        helper(root)
        return true;
    } catch {
        return false;
    }
}

function helper(root, result = []) {
    if (root) {
        helper(root.left, result);
        if (result.length === 0 || root.val > result[result.length - 1]) {
            result.push(root.val)
        } else {
            throw new Error('')
        }
        helper(root.right, result);
    }

    return result;
}
```

### [101. ](https://leetcode.cn/problems/symmetric-tree/)

``` js
var isSymmetric = function(root) {
    return check(root.left, root.right)
};

function check(root1, root2) {
    if (!root1 && !root2) return true;
    if (!root1 || !root2) return false;

    return root1.val === root2.val && check(root1.left, root2.right) && check(root1.right, root2.left);
}
```

### [102. ](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

``` js
var levelOrder = function(root) {
    return helper(root)
};

function helper(root, level = 0, result = []) {
    if (root) {
        result[level] = (result[level] || []).concat(root.val);
        helper(root.left, level + 1, result);
        helper(root.right, level + 1, result);
    }
    
    return result;
}
```

### [104. ](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

``` js
var maxDepth = function(root) {
    return helper(root)
};

function helper(root, level = 0) {
    if (root) {
        return Math.max(helper(root.left, level + 1), helper(root.right, level + 1))
    }

    return level;
} 
```

### [226. ](https://leetcode.cn/problems/invert-binary-tree/)

``` js
var invertTree = function(root) {
    if (!root) return null;
    const newRoot = {
        val: root.val,
        left: null,
        right: null
    }

    newRoot.left = invertTree(root.right);
    newRoot.right = invertTree(root.left);

    return newRoot;
};
```





## 

### 

 nums  target  ****leetcode.1 easy

```javascript
// Map
function twoSum(arr, target) {
    const map = new Map()
    for (let i = 0; i < arr.length; i++) {
        let value = arr[i]
        let diff = target - value
        if (map.has(diff)) {
            return [map.get(diff), i]
        } else {
            map.set(value, i)
        }
    }
}

twoSum([1, 2, 3, 4], 7)
```



### 

 n  nums nums  abc  a + b + c = 0 ****(leetcode.15 medium)

**** 

``` js
function threeSum(arr, sum = 0) {
    let res = []
    let n = arr.length
    arr.sort((a, b) => a - b) // 
    for (let i = 0; i < n - 2; i++) {
        if (arr[i] === arr[i - 1]) continue // 
        // 
        let l = i + 1
        let r = n - 1 
        while(l < r) {
            let m = arr[i] + arr[l] + arr[r]
            if (m === sum) {
                res.push([arr[i], arr[l], arr[r]])
                while(l < r && arr[l] === arr[l + 1]) l++ // 
                while(l < r && arr[r] === arr[r - 1]) r-- // 
                l++
                r--
            }
            if (m > sum) {
                r--
            }
            if (m < sum) {
                l++
            }
        }
    }
    return res
}
```



### 

 n  nums  target nums  abc  d  a + b + c + d  target ****(leetcode.18 medium)



``` js
function fourSum(arr, sum) {
    let res = []
    let n = arr.length
    arr.sort((a, b) => a - b) // 
    for (let j = 0; j < n - 3; j++) {
        if (arr[j] === arr[j - 1]) continue // 
        for (let i = j + 1; i < n - 2; i++) {
            if (i > j + 1 && arr[i] === arr[i - 1]) continue //  i > j + 1
            // 
            let l = i + 1
            let r = n - 1 
            while(l < r) {
                let m = arr[j] + arr[i] + arr[l] + arr[r]
                if (m === sum) {
                    res.push([arr[j], arr[i], arr[l], arr[r]])
                    while(l < r && arr[l] === arr[l + 1]) l++ // 
                    while(l < r && arr[r] === arr[r - 1]) r-- // 
                    l++
                    r--
                }
                if (m > sum) {
                    r--
                }
                if (m < sum) {
                    l++
                }
            }
        }       
    }

    return res
}
```





### n

 n  sum

``` js
function getArr(arr, n, m, temp = []) {
    if (temp.length === n) {
        let sum = temp.reduce((a, b) => a + b)
        if (sum === m) {
            return temp
        } else {
            return
        }
    }
    
    for (let i = 0; i < arr.length; i++) {
        temp.push(arr.shift())
        let ret = getArr(arr, n, m, temp)
        if (ret) {
            return ret
        } else {
            arr.push(temp.pop())
        }
    }
}


let myArr = [1, 2, 3, 4]
getArr(myArr, 2, 7, [])
```



### 

      (leetcode.2 medium)



 0  0 



(2 -> 4 -> 3) + (5 -> 6 -> 4)
7 -> 0 -> 8
342 + 465 = 807

``` js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let carry = 0
    let res = new ListNode(-1)
    let cur = res
    while (l1 !== null || l2 !== null) {
        let v1 = l1 ? l1.val : 0
        let v2 = l2 ? l2.val : 0
        let sum = v1 + v2 + carry
        carry = sum >= 10 ? 1 : 0
        cur.next = new ListNode(sum % 10)
        
        cur = cur.next
        l1 = l1 ? l1.next : l1
        l2 = l2 ? l2.next : l2
    }
    if (carry === 1) {
        cur.next = new ListNode(1)
    }
    return res.next
};

// test
class ListNode {
    constructor(val) {
        this.val = val
        this.next = null
    }
}
const l1 = new ListNode(2)
l1.next = new ListNode(4)
l1.next.next = new ListNode(3)

const l2 = new ListNode(5)
l2.next = new ListNode(6)
l2.next.next = new ListNode(4)

addTwoNumbers(l1, l2) // 7 => 0 => 8
```



### 

 **** (leetcode.3 medium)

1 

``` js
function getLength(str) {
    let length = 0
    for (let i = 0; i < str.length; i++) {
        for (let j = i + 1; j <= str.length; j++) {
            if (isUnique(str, i, j)) {
                length = Math.max(length, j - i)
            }
        }
    }
    return length
}

function isUnique(str, i, j) {
    let set = new Set()
    while (i < j) {
        let char = str.charAt(i)
        if (set.has(char)) {
            return false
        } else {
            set.add(char)
        }
        i++
    }
    
    return true
}
getLength('aaabcdd')
```

2 ****

``` js
function getLength(str) {
    let n = str.length
    let set = new Set()
    let [len, i, j] = [0, 0, 0]

    while (i < n && j < n) {
        if (set.has(str.charAt(j))) {
            set.delete(str.charAt(i++))
        } else {
            set.add(str.charAt(j++))
            len = Math.max(len, j - i)
        }
    }
    return len
}
```



### 

123211221(leetcode.9 easy)



``` js
function isHuiWen(num) {
    return num == num.toString().split('').reverse().join('')
}
```



``` js
function isHuiWen(num) {
    // 0-121
    // 10000
    if (num < 0 || (num % 10 === 0 && num !==0 )) return false 
    let revertNum = 0
    while (num > revertNum) {
        revertNum = num % 10 + revertNum * 10
        num = Math.floor(num / 10)
    }
    
    return num === revertNum || num === Math.floor(revertNum / 10)
}

isHuiWen(12321)
// 1232 1
// 123 12
// 12 123
// 12 === ~~(123 / 10)
```





### ()



```js
// add
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;
```



``` javascript
function sum (...args) {
    function fn(...newArgs) {
        return sum(...args, ...newArgs)
    }

  	// toString
  	// toString
    fn.toString = () => {
        return args.reduce((a, b) => {
            return a + b
        })
    }

    return fn
}
```

### repeat



```javascript
function repeat(func, times, wait) {
  // TODO
}
const repeatFunc = repeat(alert, 4, 3000);
repeatFunc("hellworld");
//alert4 helloworld3
```



setInterval

``` javascript
function repeat(fn, times, wait) {
    let timer
    let count = 0
    return function (...args) {
        if (times > 0) {
            fn(...args)
        }
        timer = setInterval(() => {
            if (count < times - 1) {
                fn(...args)
                count++
            }
            else {
                clearInterval(timer)
            }
        }, wait)
    }
}
```

async/await + setTimeout

``` javascript
function repeat(fn, times, wait) {
    async function func(...args) {
        for (let i = 0; i < times; i++) {
            fn(...args)
            await new Promise((resolve, reject) => {
                setTimeout(resolve, wait)
            })
        }
    }
    return func
}
```

### sleep

``` js
const sleep = (wait) => new Promise((resolve, reject) => {
    setTimeout(resolve, wait)
}) 

// 
async function test () {
	await sleep(1000)
	console.log('awake')
}
```



### LazyMan





``` javascript
HardMan(“jack”) :
I am jack

HardMan(“jack”).rest(10).learn(“computer”) 
I am jack
//10
Start learning after 10 seconds
Learning computer

HardMan(“jack”).restFirst(5).learn(“chinese”) 
//5
Start learning after 5 seconds
I am jack
Learning chinese
```



``` javascript
class _HardMan {
    constructor(name) {
        this.tasks = []

        setTimeout(async () => {
            for (let task of this.tasks) {
                await task()
            }
        })

        this.tasks.push(() =>
            new Promise(resolve => {
                console.log(`I am ${name}`)
                resolve()
            })
        )
    }

    wait(sec) {
        return new Promise(resolve => {
            console.log(`//${sec}..`)
            setTimeout(() => {
                console.log(`Start learning after ${sec} seconds`)
                resolve()
            }, sec * 1000);
        })
    }


    rest(sec) {
        this.tasks.push(() => this.wait(sec))
        return this
    }

    restFirst(sec) {
        this.tasks.unshift(() => this.wait(sec))
        return this
    }

    learn(params) {
        this.tasks.push(() =>
            new Promise(resolve => {
                console.log(`Learning ${params}`)
                resolve()
            })
        )
        return this
    }
}

function HardMan(name) {
    return new _HarnMan(name)
}

// 
// 1. this
// 2. SetTimeout
// 3. sleep/wait setTimeoutPromisesetTimeout
// 4. Promise
	next() {
        let task = this.tasks.shift()
        task && task()
    }

    wait(sec) {
      setTimeout(() => {
        //do something
        this.next()
      }, sec)
    }

```