---
sidebar_position: 10
title: 数据库设计最佳实践
tags: [系统设计, 数据库设计, MySQL, 索引优化]
---

# 数据库设计最佳实践

数据库设计是系统架构的基石，本文将详细讲解数据库设计的最佳实践和优化技巧。

## 表设计原则

### 三范式

```sql
-- 第一范式（1NF）：列不可分割
-- ❌ 违反1NF
CREATE TABLE users_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    phones VARCHAR(200)  -- 存储多个电话号码，用逗号分隔
);

-- ✅ 符合1NF
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE user_phones (
    id INT PRIMARY KEY,
    user_id INT,
    phone VARCHAR(20),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 第二范式（2NF）：消除部分依赖
-- ❌ 违反2NF
CREATE TABLE order_items_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100),  -- 依赖于product_id
    product_price DECIMAL(10,2), -- 依赖于product_id
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);

-- ✅ 符合2NF
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2)
);

CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 第三范式（3NF）：消除传递依赖
-- ❌ 违反3NF
CREATE TABLE employees_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    department_name VARCHAR(100),  -- 依赖于department_id
    department_location VARCHAR(100) -- 依赖于department_id
);

-- ✅ 符合3NF
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location VARCHAR(100)
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);
```

### 反范式化

```sql
-- 适当的反范式化可以提高查询性能

-- 订单表（反范式化）
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    user_name VARCHAR(100),        -- 冗余用户名
    total_amount DECIMAL(10,2),    -- 冗余总金额
    item_count INT,                -- 冗余商品数量
    created_at TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- 使用触发器保持数据一致性
DELIMITER $$
CREATE TRIGGER update_order_summary
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT SUM(price * quantity)
        FROM order_items
        WHERE order_id = NEW.order_id
    ),
    item_count = (
        SELECT COUNT(*)
        FROM order_items
        WHERE order_id = NEW.order_id
    )
    WHERE id = NEW.order_id;
END$$
DELIMITER ;
```

## 索引设计

### 索引类型

```sql
-- 1. 主键索引
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    name VARCHAR(100)
);

-- 2. 唯一索引
CREATE UNIQUE INDEX idx_email ON users(email);

-- 3. 普通索引
CREATE INDEX idx_name ON users(name);

-- 4. 组合索引
CREATE INDEX idx_name_email ON users(name, email);

-- 5. 全文索引
CREATE TABLE articles (
    id BIGINT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT INDEX idx_content (title, content)
);

-- 全文搜索
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('搜索关键词' IN NATURAL LANGUAGE MODE);

-- 6. 前缀索引
CREATE INDEX idx_email_prefix ON users(email(10));

-- 7. 覆盖索引
CREATE INDEX idx_covering ON users(name, email, created_at);

-- 查询只需要索引中的列，不需要回表
SELECT name, email, created_at
FROM users
WHERE name = 'John';
```

### 索引优化

```sql
-- 最左前缀原则
CREATE INDEX idx_abc ON table_name(a, b, c);

-- ✅ 可以使用索引
SELECT * FROM table_name WHERE a = 1;
SELECT * FROM table_name WHERE a = 1 AND b = 2;
SELECT * FROM table_name WHERE a = 1 AND b = 2 AND c = 3;

-- ❌ 不能使用索引
SELECT * FROM table_name WHERE b = 2;
SELECT * FROM table_name WHERE c = 3;
SELECT * FROM table_name WHERE b = 2 AND c = 3;

-- 索引选择性
-- 选择性 = 不同值的数量 / 总行数
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS selectivity
FROM table_name;

-- 选择性高的列适合建索引
-- 性别（2个值）：选择性低，不适合
-- 邮箱（唯一）：选择性高，适合

-- 避免索引失效
-- ❌ 在索引列上使用函数
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- ✅ 改写查询
SELECT * FROM users 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';

-- ❌ 隐式类型转换
SELECT * FROM users WHERE phone = 12345678;  -- phone是VARCHAR

-- ✅ 使用正确类型
SELECT * FROM users WHERE phone = '12345678';

-- ❌ 使用OR连接不同列
SELECT * FROM users WHERE name = 'John' OR email = 'john@example.com';

-- ✅ 使用UNION
SELECT * FROM users WHERE name = 'John'
UNION
SELECT * FROM users WHERE email = 'john@example.com';
```

## 分区表

```sql
-- 范围分区
CREATE TABLE orders (
    id BIGINT,
    user_id BIGINT,
    amount DECIMAL(10,2),
    created_at TIMESTAMP
)
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 列表分区
CREATE TABLE users (
    id BIGINT,
    name VARCHAR(100),
    country VARCHAR(50)
)
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_asia VALUES IN ('CN', 'JP', 'KR'),
    PARTITION p_europe VALUES IN ('UK', 'FR', 'DE'),
    PARTITION p_america VALUES IN ('US', 'CA', 'MX')
);

-- 哈希分区
CREATE TABLE logs (
    id BIGINT,
    user_id BIGINT,
    action VARCHAR(50),
    created_at TIMESTAMP
)
PARTITION BY HASH(user_id)
PARTITIONS 10;

-- 分区管理
-- 添加分区
ALTER TABLE orders ADD PARTITION (
    PARTITION p2025 VALUES LESS THAN (2026)
);

-- 删除分区
ALTER TABLE orders DROP PARTITION p2022;

-- 查询分区信息
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'orders';
```

## 查询优化

### EXPLAIN分析

```sql
-- 查看执行计划
EXPLAIN SELECT * FROM users WHERE name = 'John';

-- 执行计划字段说明
/*
id: 查询序号
select_type: 查询类型（SIMPLE, PRIMARY, SUBQUERY等）
table: 表名
type: 访问类型（ALL, index, range, ref, eq_ref, const）
  - ALL: 全表扫描（最差）
  - index: 索引全扫描
  - range: 索引范围扫描
  - ref: 非唯一索引扫描
  - eq_ref: 唯一索引扫描
  - const: 常量查询（最优）
possible_keys: 可能使用的索引
key: 实际使用的索引
rows: 扫描的行数
Extra: 额外信息
  - Using index: 覆盖索引
  - Using where: 使用WHERE过滤
  - Using filesort: 文件排序（需优化）
  - Using temporary: 使用临时表（需优化）
*/

-- 优化示例
-- ❌ 全表扫描
EXPLAIN SELECT * FROM orders WHERE amount > 100;
-- type: ALL, rows: 1000000

-- ✅ 添加索引
CREATE INDEX idx_amount ON orders(amount);
EXPLAIN SELECT * FROM orders WHERE amount > 100;
-- type: range, rows: 50000
```

### 慢查询优化

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 1秒

-- 查看慢查询
SELECT * FROM mysql.slow_log
ORDER BY start_time DESC
LIMIT 10;

-- 常见优化技巧

-- 1. 避免SELECT *
-- ❌
SELECT * FROM users WHERE id = 1;

-- ✅
SELECT id, name, email FROM users WHERE id = 1;

-- 2. 使用LIMIT
-- ❌
SELECT * FROM orders ORDER BY created_at DESC;

-- ✅
SELECT * FROM orders ORDER BY created_at DESC LIMIT 100;

-- 3. 避免子查询
-- ❌
SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE amount > 1000);

-- ✅
SELECT DISTINCT u.* FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.amount > 1000;

-- 4. 使用JOIN代替多次查询
-- ❌
SELECT * FROM users WHERE id = 1;
SELECT * FROM orders WHERE user_id = 1;

-- ✅
SELECT u.*, o.*
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.id = 1;

-- 5. 批量操作
-- ❌
INSERT INTO users (name) VALUES ('User1');
INSERT INTO users (name) VALUES ('User2');
INSERT INTO users (name) VALUES ('User3');

-- ✅
INSERT INTO users (name) VALUES 
('User1'), ('User2'), ('User3');
```

## 事务与锁

```sql
-- 事务隔离级别
-- READ UNCOMMITTED: 读未提交
-- READ COMMITTED: 读已提交
-- REPEATABLE READ: 可重复读（MySQL默认）
-- SERIALIZABLE: 串行化

-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 事务示例
START TRANSACTION;

-- 悲观锁：FOR UPDATE
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;

-- 乐观锁：版本号
UPDATE accounts 
SET balance = balance - 100, version = version + 1
WHERE id = 1 AND version = 10;

-- 检查影响行数
IF ROW_COUNT() = 0 THEN
    -- 版本冲突，重试
END IF;

-- 死锁检测
SHOW ENGINE INNODB STATUS;

-- 避免死锁
-- 1. 按相同顺序访问资源
-- 2. 缩短事务时间
-- 3. 降低隔离级别
-- 4. 使用乐观锁
```

## 分库分表

```javascript
// 分库分表策略
class ShardingStrategy {
  constructor(dbCount = 4, tableCount = 16) {
    this.dbCount = dbCount;
    this.tableCount = tableCount;
  }
  
  // 根据用户ID分库分表
  getShardInfo(userId) {
    const dbIndex = userId % this.dbCount;
    const tableIndex = userId % this.tableCount;
    
    return {
      database: `db_${dbIndex}`,
      table: `users_${tableIndex}`
    };
  }
  
  // 范围查询需要查询所有分片
  async rangeQuery(startId, endId) {
    const results = [];
    
    for (let db = 0; db < this.dbCount; db++) {
      for (let table = 0; table < this.tableCount; table++) {
        const sql = `
          SELECT * FROM db_${db}.users_${table}
          WHERE id BETWEEN ${startId} AND ${endId}
        `;
        
        const rows = await this.query(sql);
        results.push(...rows);
      }
    }
    
    return results;
  }
}

// 使用示例
const sharding = new ShardingStrategy(4, 16);

// 插入数据
const userId = 12345;
const { database, table } = sharding.getShardInfo(userId);
const sql = `INSERT INTO ${database}.${table} (id, name) VALUES (?, ?)`;
await db.query(sql, [userId, 'John']);

// 查询数据
const { database: db, table: tbl } = sharding.getShardInfo(userId);
const sql2 = `SELECT * FROM ${db}.${tbl} WHERE id = ?`;
const user = await db.query(sql2, [userId]);
```

## 读写分离

```javascript
class MasterSlaveRouter {
  constructor(masterConfig, slaveConfigs) {
    this.master = createConnection(masterConfig);
    this.slaves = slaveConfigs.map(config => createConnection(config));
    this.currentSlaveIndex = 0;
  }
  
  // 写操作走主库
  async write(sql, params) {
    return await this.master.query(sql, params);
  }
  
  // 读操作走从库（轮询）
  async read(sql, params) {
    const slave = this.getNextSlave();
    return await slave.query(sql, params);
  }
  
  getNextSlave() {
    const slave = this.slaves[this.currentSlaveIndex];
    this.currentSlaveIndex = (this.currentSlaveIndex + 1) % this.slaves.length;
    return slave;
  }
  
  // 事务必须走主库
  async transaction(callback) {
    const connection = await this.master.getConnection();
    
    try {
      await connection.beginTransaction();
      await callback(connection);
      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}

// 使用示例
const router = new MasterSlaveRouter(
  { host: 'master.db', port: 3306 },
  [
    { host: 'slave1.db', port: 3306 },
    { host: 'slave2.db', port: 3306 }
  ]
);

// 写操作
await router.write('INSERT INTO users (name) VALUES (?)', ['John']);

// 读操作
const users = await router.read('SELECT * FROM users WHERE id = ?', [1]);

// 事务
await router.transaction(async (conn) => {
  await conn.query('UPDATE accounts SET balance = balance - 100 WHERE id = 1');
  await conn.query('UPDATE accounts SET balance = balance + 100 WHERE id = 2');
});
```

## 监控与维护

```sql
-- 查看表大小
SELECT 
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY size_mb DESC;

-- 查看索引使用情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'your_database';

-- 查看未使用的索引
SELECT 
    s.TABLE_NAME,
    s.INDEX_NAME
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN INFORMATION_SCHEMA.INDEX_STATISTICS i
    ON s.TABLE_SCHEMA = i.TABLE_SCHEMA
    AND s.TABLE_NAME = i.TABLE_NAME
    AND s.INDEX_NAME = i.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND i.INDEX_NAME IS NULL;

-- 优化表
OPTIMIZE TABLE users;

-- 分析表
ANALYZE TABLE users;

-- 检查表
CHECK TABLE users;

-- 修复表
REPAIR TABLE users;
```

## 总结

数据库设计最佳实践：
- 📐 **表设计**：三范式 + 适度反范式
- 🔍 **索引优化**：合理建索引 + 避免失效
- 📊 **查询优化**：EXPLAIN分析 + 慢查询优化
- 🔒 **事务锁**：隔离级别 + 死锁避免
- 🗂️ **分库分表**：水平拆分 + 垂直拆分
- 📈 **读写分离**：主从复制 + 负载均衡

记住：**好的数据库设计是高性能系统的基础！**

