---
sidebar_position: 1
title: æ•°æ®ç»“æ„åŸºç¡€
tags: [ç®—æ³•, æ•°æ®ç»“æ„, é¢è¯•]
---

# æ•°æ®ç»“æ„åŸºç¡€

æ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºå­˜å‚¨ã€ç»„ç»‡æ•°æ®çš„æ–¹å¼ï¼Œæœ¬æ–‡è®²è§£å¸¸ç”¨æ•°æ®ç»“æ„çš„å®ç°å’Œåº”ç”¨ã€‚

## æ•°ç»„ä¸é“¾è¡¨

### æ•°ç»„

```javascript
// æ•°ç»„åŸºç¡€æ“ä½œ
class ArrayList {
  constructor() {
    this.data = [];
  }
  
  // æ·»åŠ å…ƒç´  O(1)
  push(value) {
    this.data[this.data.length] = value;
  }
  
  // åˆ é™¤æœ«å°¾å…ƒç´  O(1)
  pop() {
    if (this.data.length === 0) return undefined;
    const value = this.data[this.data.length - 1];
    this.data.length--;
    return value;
  }
  
  // æ’å…¥å…ƒç´  O(n)
  insert(index, value) {
    for (let i = this.data.length; i > index; i--) {
      this.data[i] = this.data[i - 1];
    }
    this.data[index] = value;
  }
  
  // åˆ é™¤å…ƒç´  O(n)
  remove(index) {
    const value = this.data[index];
    for (let i = index; i < this.data.length - 1; i++) {
      this.data[i] = this.data[i + 1];
    }
    this.data.length--;
    return value;
  }
  
  // æŸ¥æ‰¾å…ƒç´  O(n)
  indexOf(value) {
    for (let i = 0; i < this.data.length; i++) {
      if (this.data[i] === value) return i;
    }
    return -1;
  }
}

// åŠ¨æ€æ•°ç»„
class DynamicArray {
  constructor(capacity = 10) {
    this.data = new Array(capacity);
    this.size = 0;
    this.capacity = capacity;
  }
  
  push(value) {
    if (this.size === this.capacity) {
      this.resize(this.capacity * 2);
    }
    this.data[this.size++] = value;
  }
  
  resize(newCapacity) {
    const newData = new Array(newCapacity);
    for (let i = 0; i < this.size; i++) {
      newData[i] = this.data[i];
    }
    this.data = newData;
    this.capacity = newCapacity;
  }
}
```

### é“¾è¡¨

```javascript
// å•é“¾è¡¨èŠ‚ç‚¹
class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

// å•é“¾è¡¨
class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  
  // æ·»åŠ åˆ°å¤´éƒ¨ O(1)
  addFirst(value) {
    const node = new ListNode(value);
    node.next = this.head;
    this.head = node;
    this.size++;
  }
  
  // æ·»åŠ åˆ°å°¾éƒ¨ O(n)
  addLast(value) {
    const node = new ListNode(value);
    
    if (!this.head) {
      this.head = node;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = node;
    }
    this.size++;
  }
  
  // åˆ é™¤å¤´èŠ‚ç‚¹ O(1)
  removeFirst() {
    if (!this.head) return null;
    
    const value = this.head.value;
    this.head = this.head.next;
    this.size--;
    return value;
  }
  
  // åè½¬é“¾è¡¨ O(n)
  reverse() {
    let prev = null;
    let current = this.head;
    
    while (current) {
      const next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }
    
    this.head = prev;
  }
  
  // æ£€æµ‹ç¯
  hasCycle() {
    let slow = this.head;
    let fast = this.head;
    
    while (fast && fast.next) {
      slow = slow.next;
      fast = fast.next.next;
      
      if (slow === fast) return true;
    }
    
    return false;
  }
}

// åŒå‘é“¾è¡¨
class DoublyListNode {
  constructor(value) {
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }
  
  addFirst(value) {
    const node = new DoublyListNode(value);
    
    if (!this.head) {
      this.head = this.tail = node;
    } else {
      node.next = this.head;
      this.head.prev = node;
      this.head = node;
    }
    this.size++;
  }
  
  addLast(value) {
    const node = new DoublyListNode(value);
    
    if (!this.tail) {
      this.head = this.tail = node;
    } else {
      node.prev = this.tail;
      this.tail.next = node;
      this.tail = node;
    }
    this.size++;
  }
}
```

## æ ˆä¸é˜Ÿåˆ—

### æ ˆ

```javascript
// æ•°ç»„å®ç°æ ˆ
class Stack {
  constructor() {
    this.items = [];
  }
  
  push(element) {
    this.items.push(element);
  }
  
  pop() {
    return this.items.pop();
  }
  
  peek() {
    return this.items[this.items.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
}

// é“¾è¡¨å®ç°æ ˆ
class LinkedStack {
  constructor() {
    this.top = null;
    this.size = 0;
  }
  
  push(value) {
    const node = new ListNode(value);
    node.next = this.top;
    this.top = node;
    this.size++;
  }
  
  pop() {
    if (!this.top) return null;
    
    const value = this.top.value;
    this.top = this.top.next;
    this.size--;
    return value;
  }
}

// åº”ç”¨ï¼šæ‹¬å·åŒ¹é…
function isValidParentheses(s) {
  const stack = new Stack();
  const pairs = { '(': ')', '[': ']', '{': '}' };
  
  for (const char of s) {
    if (char in pairs) {
      stack.push(char);
    } else {
      const top = stack.pop();
      if (pairs[top] !== char) return false;
    }
  }
  
  return stack.isEmpty();
}
```

### é˜Ÿåˆ—

```javascript
// æ•°ç»„å®ç°é˜Ÿåˆ—
class Queue {
  constructor() {
    this.items = [];
  }
  
  enqueue(element) {
    this.items.push(element);
  }
  
  dequeue() {
    return this.items.shift();
  }
  
  front() {
    return this.items[0];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
}

// å¾ªç¯é˜Ÿåˆ—
class CircularQueue {
  constructor(capacity) {
    this.items = new Array(capacity);
    this.capacity = capacity;
    this.front = 0;
    this.rear = 0;
    this.size = 0;
  }
  
  enqueue(element) {
    if (this.isFull()) return false;
    
    this.items[this.rear] = element;
    this.rear = (this.rear + 1) % this.capacity;
    this.size++;
    return true;
  }
  
  dequeue() {
    if (this.isEmpty()) return null;
    
    const element = this.items[this.front];
    this.front = (this.front + 1) % this.capacity;
    this.size--;
    return element;
  }
  
  isFull() {
    return this.size === this.capacity;
  }
  
  isEmpty() {
    return this.size === 0;
  }
}

// åŒç«¯é˜Ÿåˆ—
class Deque {
  constructor() {
    this.items = [];
  }
  
  addFront(element) {
    this.items.unshift(element);
  }
  
  addRear(element) {
    this.items.push(element);
  }
  
  removeFront() {
    return this.items.shift();
  }
  
  removeRear() {
    return this.items.pop();
  }
}
```

## æ ‘

### äºŒå‰æ ‘

```javascript
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinaryTree {
  constructor() {
    this.root = null;
  }
  
  // å‰åºéå†ï¼šæ ¹-å·¦-å³
  preorder(node = this.root, result = []) {
    if (!node) return result;
    
    result.push(node.value);
    this.preorder(node.left, result);
    this.preorder(node.right, result);
    return result;
  }
  
  // ä¸­åºéå†ï¼šå·¦-æ ¹-å³
  inorder(node = this.root, result = []) {
    if (!node) return result;
    
    this.inorder(node.left, result);
    result.push(node.value);
    this.inorder(node.right, result);
    return result;
  }
  
  // ååºéå†ï¼šå·¦-å³-æ ¹
  postorder(node = this.root, result = []) {
    if (!node) return result;
    
    this.postorder(node.left, result);
    this.postorder(node.right, result);
    result.push(node.value);
    return result;
  }
  
  // å±‚åºéå†
  levelOrder() {
    if (!this.root) return [];
    
    const result = [];
    const queue = [this.root];
    
    while (queue.length > 0) {
      const level = [];
      const levelSize = queue.length;
      
      for (let i = 0; i < levelSize; i++) {
        const node = queue.shift();
        level.push(node.value);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      
      result.push(level);
    }
    
    return result;
  }
  
  // æ ‘çš„é«˜åº¦
  height(node = this.root) {
    if (!node) return 0;
    
    return 1 + Math.max(
      this.height(node.left),
      this.height(node.right)
    );
  }
  
  // æ ‘çš„èŠ‚ç‚¹æ•°
  size(node = this.root) {
    if (!node) return 0;
    
    return 1 + this.size(node.left) + this.size(node.right);
  }
}
```

### äºŒå‰æœç´¢æ ‘

```javascript
class BST {
  constructor() {
    this.root = null;
  }
  
  // æ’å…¥èŠ‚ç‚¹
  insert(value) {
    this.root = this._insert(this.root, value);
  }
  
  _insert(node, value) {
    if (!node) return new TreeNode(value);
    
    if (value < node.value) {
      node.left = this._insert(node.left, value);
    } else if (value > node.value) {
      node.right = this._insert(node.right, value);
    }
    
    return node;
  }
  
  // æŸ¥æ‰¾èŠ‚ç‚¹
  search(value) {
    return this._search(this.root, value);
  }
  
  _search(node, value) {
    if (!node) return null;
    
    if (value === node.value) return node;
    if (value < node.value) return this._search(node.left, value);
    return this._search(node.right, value);
  }
  
  // åˆ é™¤èŠ‚ç‚¹
  delete(value) {
    this.root = this._delete(this.root, value);
  }
  
  _delete(node, value) {
    if (!node) return null;
    
    if (value < node.value) {
      node.left = this._delete(node.left, value);
    } else if (value > node.value) {
      node.right = this._delete(node.right, value);
    } else {
      // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
      if (!node.left) return node.right;
      if (!node.right) return node.left;
      
      // æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼šæ‰¾å³å­æ ‘æœ€å°å€¼æ›¿æ¢
      const minNode = this._findMin(node.right);
      node.value = minNode.value;
      node.right = this._delete(node.right, minNode.value);
    }
    
    return node;
  }
  
  _findMin(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
}
```

## å“ˆå¸Œè¡¨

```javascript
class HashTable {
  constructor(size = 53) {
    this.keyMap = new Array(size);
  }
  
  // å“ˆå¸Œå‡½æ•°
  _hash(key) {
    let total = 0;
    const PRIME = 31;
    
    for (let i = 0; i < Math.min(key.length, 100); i++) {
      const char = key[i];
      const value = char.charCodeAt(0) - 96;
      total = (total * PRIME + value) % this.keyMap.length;
    }
    
    return total;
  }
  
  // è®¾ç½®é”®å€¼å¯¹
  set(key, value) {
    const index = this._hash(key);
    
    if (!this.keyMap[index]) {
      this.keyMap[index] = [];
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    for (let i = 0; i < this.keyMap[index].length; i++) {
      if (this.keyMap[index][i][0] === key) {
        this.keyMap[index][i][1] = value;
        return;
      }
    }
    
    this.keyMap[index].push([key, value]);
  }
  
  // è·å–å€¼
  get(key) {
    const index = this._hash(key);
    
    if (this.keyMap[index]) {
      for (let i = 0; i < this.keyMap[index].length; i++) {
        if (this.keyMap[index][i][0] === key) {
          return this.keyMap[index][i][1];
        }
      }
    }
    
    return undefined;
  }
  
  // åˆ é™¤é”®å€¼å¯¹
  delete(key) {
    const index = this._hash(key);
    
    if (this.keyMap[index]) {
      for (let i = 0; i < this.keyMap[index].length; i++) {
        if (this.keyMap[index][i][0] === key) {
          this.keyMap[index].splice(i, 1);
          return true;
        }
      }
    }
    
    return false;
  }
  
  // è·å–æ‰€æœ‰é”®
  keys() {
    const keys = [];
    
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          keys.push(this.keyMap[i][j][0]);
        }
      }
    }
    
    return keys;
  }
  
  // è·å–æ‰€æœ‰å€¼
  values() {
    const values = [];
    
    for (let i = 0; i < this.keyMap.length; i++) {
      if (this.keyMap[i]) {
        for (let j = 0; j < this.keyMap[i].length; j++) {
          if (!values.includes(this.keyMap[i][j][1])) {
            values.push(this.keyMap[i][j][1]);
          }
        }
      }
    }
    
    return values;
  }
}
```

## å †

```javascript
// æœ€å°å †
class MinHeap {
  constructor() {
    this.heap = [];
  }
  
  // è·å–çˆ¶èŠ‚ç‚¹ç´¢å¼•
  parent(i) {
    return Math.floor((i - 1) / 2);
  }
  
  // è·å–å·¦å­èŠ‚ç‚¹ç´¢å¼•
  leftChild(i) {
    return 2 * i + 1;
  }
  
  // è·å–å³å­èŠ‚ç‚¹ç´¢å¼•
  rightChild(i) {
    return 2 * i + 2;
  }
  
  // äº¤æ¢å…ƒç´ 
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
  
  // æ’å…¥å…ƒç´ 
  insert(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  
  // ä¸Šæµ®
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = this.parent(index);
      
      if (this.heap[index] >= this.heap[parentIndex]) break;
      
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  
  // åˆ é™¤æœ€å°å…ƒç´ 
  extractMin() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    
    return min;
  }
  
  // ä¸‹æ²‰
  bubbleDown(index) {
    while (true) {
      const left = this.leftChild(index);
      const right = this.rightChild(index);
      let smallest = index;
      
      if (left < this.heap.length && this.heap[left] < this.heap[smallest]) {
        smallest = left;
      }
      
      if (right < this.heap.length && this.heap[right] < this.heap[smallest]) {
        smallest = right;
      }
      
      if (smallest === index) break;
      
      this.swap(index, smallest);
      index = smallest;
    }
  }
  
  // è·å–æœ€å°å…ƒç´ 
  peek() {
    return this.heap[0];
  }
  
  size() {
    return this.heap.length;
  }
}
```

## å›¾

```javascript
// é‚»æ¥è¡¨è¡¨ç¤ºå›¾
class Graph {
  constructor() {
    this.adjacencyList = new Map();
  }
  
  // æ·»åŠ é¡¶ç‚¹
  addVertex(vertex) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }
  
  // æ·»åŠ è¾¹
  addEdge(v1, v2) {
    this.adjacencyList.get(v1).push(v2);
    this.adjacencyList.get(v2).push(v1); // æ— å‘å›¾
  }
  
  // æ·±åº¦ä¼˜å…ˆéå†
  dfs(start) {
    const result = [];
    const visited = new Set();
    
    const traverse = (vertex) => {
      if (!vertex) return;
      
      visited.add(vertex);
      result.push(vertex);
      
      for (const neighbor of this.adjacencyList.get(vertex)) {
        if (!visited.has(neighbor)) {
          traverse(neighbor);
        }
      }
    };
    
    traverse(start);
    return result;
  }
  
  // å¹¿åº¦ä¼˜å…ˆéå†
  bfs(start) {
    const result = [];
    const visited = new Set();
    const queue = [start];
    
    visited.add(start);
    
    while (queue.length > 0) {
      const vertex = queue.shift();
      result.push(vertex);
      
      for (const neighbor of this.adjacencyList.get(vertex)) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
    
    return result;
  }
}
```

## æ€»ç»“

æ•°æ®ç»“æ„çš„æ ¸å¿ƒï¼š
- ğŸ“Š **æ•°ç»„ä¸é“¾è¡¨**ï¼šéšæœºè®¿é—® vs æ’å…¥åˆ é™¤
- ğŸ“š **æ ˆä¸é˜Ÿåˆ—**ï¼šLIFO vs FIFO
- ğŸŒ² **æ ‘**ï¼šäºŒå‰æ ‘ã€BSTã€AVLæ ‘
- #ï¸âƒ£ **å“ˆå¸Œè¡¨**ï¼šO(1)æŸ¥æ‰¾
- â›°ï¸ **å †**ï¼šä¼˜å…ˆé˜Ÿåˆ—
- ğŸ•¸ï¸ **å›¾**ï¼šDFSã€BFS

è®°ä½ï¼š**é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„æ˜¯ä¼˜åŒ–ç®—æ³•çš„å…³é”®ï¼**

