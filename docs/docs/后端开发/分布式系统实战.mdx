---
sidebar_position: 4
title: åˆ†å¸ƒå¼ç³»ç»Ÿå®æˆ˜
tags: [åç«¯, åˆ†å¸ƒå¼, é«˜å¯ç”¨, è´Ÿè½½å‡è¡¡]
---

# åˆ†å¸ƒå¼ç³»ç»Ÿå®æˆ˜

åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯å°†åº”ç”¨éƒ¨ç½²åœ¨å¤šå°æœºå™¨ä¸ŠååŒå·¥ä½œçš„ç³»ç»Ÿæ¶æ„ï¼Œæœ¬æ–‡è®²è§£åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µå’Œå®è·µã€‚

## åˆ†å¸ƒå¼ç†è®º

### CAPå®šç†

```javascript
// CAPå®šç†ï¼šä¸€è‡´æ€§(Consistency)ã€å¯ç”¨æ€§(Availability)ã€åˆ†åŒºå®¹é”™æ€§(Partition tolerance)
// åªèƒ½åŒæ—¶æ»¡è¶³ä¸¤ä¸ª

// CPç³»ç»Ÿï¼šä¿è¯ä¸€è‡´æ€§å’Œåˆ†åŒºå®¹é”™æ€§ï¼ˆå¦‚ï¼šZookeeperã€HBaseï¼‰
class CPSystem {
  async write(key, value) {
    // å†™å…¥ä¸»èŠ‚ç‚¹
    await this.master.write(key, value);
    
    // åŒæ­¥åˆ°æ‰€æœ‰ä»èŠ‚ç‚¹ï¼ˆå¼ºä¸€è‡´æ€§ï¼‰
    await Promise.all(
      this.slaves.map(slave => slave.write(key, value))
    );
    
    // å¦‚æœç½‘ç»œåˆ†åŒºï¼Œå†™å…¥å¤±è´¥ï¼ˆç‰ºç‰²å¯ç”¨æ€§ï¼‰
    return { success: true };
  }
}

// APç³»ç»Ÿï¼šä¿è¯å¯ç”¨æ€§å’Œåˆ†åŒºå®¹é”™æ€§ï¼ˆå¦‚ï¼šCassandraã€DynamoDBï¼‰
class APSystem {
  async write(key, value) {
    // å†™å…¥ä»»æ„å¯ç”¨èŠ‚ç‚¹
    const availableNode = this.getAvailableNode();
    await availableNode.write(key, value);
    
    // å¼‚æ­¥åŒæ­¥åˆ°å…¶ä»–èŠ‚ç‚¹ï¼ˆæœ€ç»ˆä¸€è‡´æ€§ï¼‰
    this.asyncSync(key, value);
    
    // å³ä½¿ç½‘ç»œåˆ†åŒºä¹Ÿèƒ½å†™å…¥ï¼ˆç‰ºç‰²ä¸€è‡´æ€§ï¼‰
    return { success: true };
  }
}

// CAç³»ç»Ÿï¼šä¿è¯ä¸€è‡´æ€§å’Œå¯ç”¨æ€§ï¼ˆå¦‚ï¼šå•æœºæ•°æ®åº“ï¼‰
// æ— æ³•å®¹å¿ç½‘ç»œåˆ†åŒº
```

### BASEç†è®º

```javascript
// BASEï¼šåŸºæœ¬å¯ç”¨(Basically Available)ã€è½¯çŠ¶æ€(Soft state)ã€æœ€ç»ˆä¸€è‡´æ€§(Eventually consistent)

class EventualConsistency {
  async transferMoney(fromAccount, toAccount, amount) {
    // 1. åŸºæœ¬å¯ç”¨ï¼šç³»ç»Ÿåœ¨å‡ºç°æ•…éšœæ—¶ä»èƒ½æä¾›åŸºæœ¬æœåŠ¡
    try {
      // æ‰£æ¬¾
      await this.debit(fromAccount, amount);
      
      // åˆ›å»ºè½¬è´¦äº‹ä»¶
      await this.createEvent({
        type: 'TRANSFER',
        from: fromAccount,
        to: toAccount,
        amount: amount,
        status: 'PENDING'
      });
      
      return { success: true, message: 'è½¬è´¦å¤„ç†ä¸­' };
    } catch (err) {
      return { success: false, message: 'ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•' };
    }
  }
  
  // 2. è½¯çŠ¶æ€ï¼šå…è®¸ç³»ç»Ÿä¸­çš„æ•°æ®å­˜åœ¨ä¸­é—´çŠ¶æ€
  async processEvents() {
    const events = await this.getPendingEvents();
    
    for (const event of events) {
      try {
        // åŠ æ¬¾
        await this.credit(event.to, event.amount);
        
        // æ›´æ–°äº‹ä»¶çŠ¶æ€
        await this.updateEventStatus(event.id, 'COMPLETED');
      } catch (err) {
        // é‡è¯•æœºåˆ¶
        await this.retryLater(event);
      }
    }
  }
  
  // 3. æœ€ç»ˆä¸€è‡´æ€§ï¼šç³»ç»Ÿæœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´çŠ¶æ€
  async reconcile() {
    setInterval(async () => {
      await this.processEvents();
    }, 5000);
  }
}
```

## åˆ†å¸ƒå¼é”

### Rediså®ç°

```javascript
const Redis = require('ioredis');

class RedisLock {
  constructor() {
    this.redis = new Redis();
  }
  
  // è·å–é”
  async acquire(key, ttl = 10000) {
    const lockKey = `lock:${key}`;
    const lockValue = `${Date.now()}-${Math.random()}`;
    
    // SET key value NX PX ttl
    const result = await this.redis.set(
      lockKey,
      lockValue,
      'PX',
      ttl,
      'NX'
    );
    
    if (result === 'OK') {
      return lockValue;
    }
    
    return null;
  }
  
  // é‡Šæ”¾é”ï¼ˆä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
  async release(key, lockValue) {
    const lockKey = `lock:${key}`;
    
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await this.redis.eval(script, 1, lockKey, lockValue);
  }
  
  // ä½¿ç”¨é”
  async withLock(key, fn, ttl = 10000) {
    const lockValue = await this.acquire(key, ttl);
    
    if (!lockValue) {
      throw new Error('Failed to acquire lock');
    }
    
    try {
      return await fn();
    } finally {
      await this.release(key, lockValue);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const lock = new RedisLock();

async function updateInventory(productId, quantity) {
  await lock.withLock(`product:${productId}`, async () => {
    const product = await Product.findById(productId);
    product.inventory -= quantity;
    await product.save();
  });
}
```

### Redlockç®—æ³•

```javascript
// å¤šä¸ªRediså®ä¾‹çš„åˆ†å¸ƒå¼é”
class Redlock {
  constructor(redisClients) {
    this.clients = redisClients;
    this.quorum = Math.floor(redisClients.length / 2) + 1;
  }
  
  async acquire(key, ttl = 10000) {
    const lockValue = `${Date.now()}-${Math.random()}`;
    const startTime = Date.now();
    
    let successCount = 0;
    
    // å°è¯•åœ¨æ‰€æœ‰å®ä¾‹ä¸Šè·å–é”
    const results = await Promise.all(
      this.clients.map(async (client) => {
        try {
          const result = await client.set(
            `lock:${key}`,
            lockValue,
            'PX',
            ttl,
            'NX'
          );
          return result === 'OK';
        } catch (err) {
          return false;
        }
      })
    );
    
    successCount = results.filter(r => r).length;
    
    const elapsedTime = Date.now() - startTime;
    const validityTime = ttl - elapsedTime;
    
    // æ£€æŸ¥æ˜¯å¦è·å–åˆ°è¶³å¤Ÿå¤šçš„é”
    if (successCount >= this.quorum && validityTime > 0) {
      return { lockValue, validityTime };
    }
    
    // è·å–å¤±è´¥ï¼Œé‡Šæ”¾å·²è·å–çš„é”
    await this.release(key, lockValue);
    return null;
  }
  
  async release(key, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    await Promise.all(
      this.clients.map(client =>
        client.eval(script, 1, `lock:${key}`, lockValue)
      )
    );
  }
}
```

## åˆ†å¸ƒå¼äº‹åŠ¡

### ä¸¤é˜¶æ®µæäº¤(2PC)

```javascript
class TwoPhaseCommit {
  constructor() {
    this.participants = [];
  }
  
  async execute(transaction) {
    // é˜¶æ®µ1ï¼šå‡†å¤‡é˜¶æ®µ
    const prepareResults = await this.prepare(transaction);
    
    // æ£€æŸ¥æ‰€æœ‰å‚ä¸è€…æ˜¯å¦å‡†å¤‡å¥½
    const allPrepared = prepareResults.every(r => r.prepared);
    
    if (allPrepared) {
      // é˜¶æ®µ2ï¼šæäº¤é˜¶æ®µ
      await this.commit(transaction);
      return { success: true };
    } else {
      // å›æ»š
      await this.rollback(transaction);
      return { success: false };
    }
  }
  
  async prepare(transaction) {
    return await Promise.all(
      this.participants.map(async (participant) => {
        try {
          await participant.prepare(transaction);
          return { prepared: true };
        } catch (err) {
          return { prepared: false, error: err };
        }
      })
    );
  }
  
  async commit(transaction) {
    await Promise.all(
      this.participants.map(participant =>
        participant.commit(transaction)
      )
    );
  }
  
  async rollback(transaction) {
    await Promise.all(
      this.participants.map(participant =>
        participant.rollback(transaction)
      )
    );
  }
}
```

### TCCæ¨¡å¼

```javascript
// Try-Confirm-Cancel
class TCCTransaction {
  async transfer(fromAccount, toAccount, amount) {
    const transactionId = generateId();
    
    try {
      // Tryé˜¶æ®µï¼šé¢„ç•™èµ„æº
      await this.tryDebit(fromAccount, amount, transactionId);
      await this.tryCredit(toAccount, amount, transactionId);
      
      // Confirmé˜¶æ®µï¼šç¡®è®¤æ“ä½œ
      await this.confirmDebit(fromAccount, transactionId);
      await this.confirmCredit(toAccount, transactionId);
      
      return { success: true };
    } catch (err) {
      // Cancelé˜¶æ®µï¼šå–æ¶ˆæ“ä½œ
      await this.cancelDebit(fromAccount, transactionId);
      await this.cancelCredit(toAccount, transactionId);
      
      return { success: false, error: err };
    }
  }
  
  async tryDebit(account, amount, transactionId) {
    // å†»ç»“é‡‘é¢
    await Account.update(
      { id: account },
      {
        $inc: { balance: -amount, frozen: amount }
      }
    );
    
    // è®°å½•äº‹åŠ¡
    await Transaction.create({
      id: transactionId,
      account: account,
      amount: amount,
      type: 'DEBIT',
      status: 'TRY'
    });
  }
  
  async confirmDebit(account, transactionId) {
    // æ‰£é™¤å†»ç»“é‡‘é¢
    await Account.update(
      { id: account },
      { $inc: { frozen: -amount } }
    );
    
    // æ›´æ–°äº‹åŠ¡çŠ¶æ€
    await Transaction.update(
      { id: transactionId },
      { status: 'CONFIRMED' }
    );
  }
  
  async cancelDebit(account, transactionId) {
    // è§£å†»é‡‘é¢
    const tx = await Transaction.findById(transactionId);
    await Account.update(
      { id: account },
      {
        $inc: { balance: tx.amount, frozen: -tx.amount }
      }
    );
    
    // æ›´æ–°äº‹åŠ¡çŠ¶æ€
    await Transaction.update(
      { id: transactionId },
      { status: 'CANCELLED' }
    );
  }
}
```

### Sagaæ¨¡å¼

```javascript
// é•¿äº‹åŠ¡æ‹†åˆ†ä¸ºå¤šä¸ªæœ¬åœ°äº‹åŠ¡
class SagaOrchestrator {
  async executeOrder(orderData) {
    const saga = new Saga();
    
    try {
      // æ­¥éª¤1ï¼šåˆ›å»ºè®¢å•
      const order = await saga.execute(
        () => this.createOrder(orderData),
        (order) => this.cancelOrder(order.id)
      );
      
      // æ­¥éª¤2ï¼šæ‰£å‡åº“å­˜
      await saga.execute(
        () => this.reduceInventory(order.productId, order.quantity),
        () => this.restoreInventory(order.productId, order.quantity)
      );
      
      // æ­¥éª¤3ï¼šæ‰£æ¬¾
      await saga.execute(
        () => this.debitAccount(order.userId, order.amount),
        () => this.creditAccount(order.userId, order.amount)
      );
      
      // æ­¥éª¤4ï¼šå‘é€é€šçŸ¥
      await saga.execute(
        () => this.sendNotification(order.userId, order.id),
        () => {} // é€šçŸ¥æ— éœ€è¡¥å¿
      );
      
      return { success: true, order };
    } catch (err) {
      // æ‰§è¡Œè¡¥å¿æ“ä½œ
      await saga.compensate();
      return { success: false, error: err };
    }
  }
}

class Saga {
  constructor() {
    this.steps = [];
  }
  
  async execute(action, compensation) {
    const result = await action();
    this.steps.push({ result, compensation });
    return result;
  }
  
  async compensate() {
    // åå‘æ‰§è¡Œè¡¥å¿æ“ä½œ
    for (let i = this.steps.length - 1; i >= 0; i--) {
      const { result, compensation } = this.steps[i];
      await compensation(result);
    }
  }
}
```

## è´Ÿè½½å‡è¡¡

```javascript
// è´Ÿè½½å‡è¡¡ç®—æ³•
class LoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
  }
  
  // è½®è¯¢
  roundRobin() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }
  
  // éšæœº
  random() {
    const index = Math.floor(Math.random() * this.servers.length);
    return this.servers[index];
  }
  
  // åŠ æƒè½®è¯¢
  weightedRoundRobin() {
    let totalWeight = 0;
    let maxWeight = 0;
    let selectedServer = null;
    
    for (const server of this.servers) {
      server.currentWeight += server.weight;
      totalWeight += server.weight;
      
      if (server.currentWeight > maxWeight) {
        maxWeight = server.currentWeight;
        selectedServer = server;
      }
    }
    
    selectedServer.currentWeight -= totalWeight;
    return selectedServer;
  }
  
  // æœ€å°‘è¿æ¥
  leastConnections() {
    return this.servers.reduce((min, server) =>
      server.connections < min.connections ? server : min
    );
  }
  
  // ä¸€è‡´æ€§å“ˆå¸Œ
  consistentHash(key) {
    const hash = this.hash(key);
    
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhashå€¼çš„èŠ‚ç‚¹
    for (const server of this.servers) {
      if (server.hash >= hash) {
        return server;
      }
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    return this.servers[0];
  }
  
  hash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash) + key.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
```

## æœåŠ¡é™çº§ä¸ç†”æ–­

```javascript
// ç†”æ–­å™¨æ¨¡å¼
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.resetTimeout = options.resetTimeout || 30000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      
      // å°è¯•åŠå¼€çŠ¶æ€
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await Promise.race([
        fn(),
        this.timeoutPromise()
      ]);
      
      this.onSuccess();
      return result;
    } catch (err) {
      this.onFailure();
      throw err;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
    }
  }
  
  timeoutPromise() {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Timeout')), this.timeout);
    });
  }
}

// ä½¿ç”¨ç†”æ–­å™¨
const breaker = new CircuitBreaker({
  failureThreshold: 5,
  timeout: 3000,
  resetTimeout: 30000
});

async function callExternalService() {
  try {
    return await breaker.execute(async () => {
      const response = await axios.get('https://api.example.com/data');
      return response.data;
    });
  } catch (err) {
    // é™çº§å¤„ç†
    return getDefaultData();
  }
}
```

## æ€»ç»“

åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒï¼š
- ğŸ“š **ç†è®ºåŸºç¡€**ï¼šCAPã€BASE
- ğŸ”’ **åˆ†å¸ƒå¼é”**ï¼šRedisã€Redlock
- ğŸ’³ **åˆ†å¸ƒå¼äº‹åŠ¡**ï¼š2PCã€TCCã€Saga
- âš–ï¸ **è´Ÿè½½å‡è¡¡**ï¼šè½®è¯¢ã€ä¸€è‡´æ€§å“ˆå¸Œ
- ğŸ›¡ï¸ **å®¹é”™æœºåˆ¶**ï¼šç†”æ–­ã€é™çº§ã€é™æµ

è®°ä½ï¼š**åˆ†å¸ƒå¼ç³»ç»Ÿè¦è€ƒè™‘ç½‘ç»œå»¶è¿Ÿã€èŠ‚ç‚¹æ•…éšœã€æ•°æ®ä¸€è‡´æ€§ï¼**

